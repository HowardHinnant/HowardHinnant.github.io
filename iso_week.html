<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>iso_week</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
	code {white-space:pre;}
	</style>
</head>
<body>

<address align=right>
<br/>
<br/>
<a href="mailto:howard.hinnant@gmail.com">Howard E. Hinnant</a><br/>
2015-12-20<br/>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"> <img alt="Creative
Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br /> This work is licensed
under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
Commons Attribution 4.0 International License</a>.
</address>
<hr/>
<h1 align=center><code>iso_week</code></h1>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Implementation">Implementation</a></li>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Reference">Reference</a></li>
</ul>

<a name="Introduction"></a><h2>Introduction</h2>

<p>
This paper fully documents an
<a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO week date calendar</a>
that is fully interoperable with
<a href="date_v2.html"><code>date</code></a>.
</p>

<a name="Implementation"></a><h2>Implementation</h2>

<p>
This entire library is implemented in a single header:
<a href="https://github.com/HowardHinnant/date/blob/master/iso_week.h">iso_week.h</a>
and is open source using the MIT license.
</p>

<a name="Overview"></a><h2>Overview</h2>

<p>
This library creates field types that hold the year, week number and weekday
associated with a <a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO week date</a>.
For example, to specify the Saturday of the 51st week of 2015 one can say:
</p>

<blockquote><pre>
#include "iso_week.h"
#include &lt;iostream&gt;

int
main()
{
    using namespace iso_week::literals;
    auto iso_date = sat/51/2015;
    std::cout &lt;&lt; iso_date &lt;&lt; '\n';
}
</pre></blockquote>

<p>
The output of this program is:
</p>

<blockquote><pre>
2015-W51-Sat
</pre></blockquote>

<p>
In this example <code>iso_date</code> has type <code>iso_week::year_weeknum_weekday</code>,
and this type does nothing but hold the three quantities: <code>year</code>,
<code>weeknum</code> and <code>weekday</code>.  This is such trivial functionality that
it almost seems useless.  Anyone can write a type to be constructed from three values,
and then print them back out when requested.
</p>

<p>
The real power of <code>year_weeknum_weekday</code> is that it can implicitly convert to
and from <a href="date_v2.html#day_point"><code>day_point</code></a>.  And
 <a href="date_v2.html#day_point"><code>day_point</code></a> is just a type alias for:
</p>

<blockquote><pre>
std::chrono::time_point&lt;std::chrono::system_clock, days&gt;
</pre></blockquote>

<p>
This is the exact same <code>day_point</code> used by the
<a href="date_v2.html"><code>date</code></a> and <a href="tz.html">time zone</a>
libraries.  And so by simply having conversions to and from <code>day_point</code>,
<code>iso_week::year_weeknum_weekday</code> becomes seamlessly interoperable with all
of the types in <a href="date_v2.html"><code>date</code></a> and
<a href="tz.html">time zone</a> such as <code>date::year_month_day</code> and
<code>date::Zone</code>:
</p>

<blockquote><pre>
#include "date.h"
#include "iso_week.h"
#include "tz.h"
#include &lt;iostream&gt;

int
main()
{
    using namespace std::chrono;
    using namespace date;
    using namespace iso_week;
    auto zone = locate_zone("America/New_York");
    auto now = zone-&gt;to_local(system_clock::now());
    auto dp = floor&lt;days&gt;(now.first);
    auto iso_date = year_weeknum_weekday{dp};
    auto civil_date = year_month_day{dp};
    auto time = make_time(duration_cast&lt;minutes&gt;(now.first-dp));
    std::cout &lt;&lt; "It is currently " &lt;&lt; time &lt;&lt; ' ' &lt;&lt; now.second &lt;&lt; " on "
              &lt;&lt; iso_date &lt;&lt; " which is also " &lt;&lt; civil_date &lt;&lt; '\n';
}
</pre></blockquote>

<p>
Which just output for me:
</p>

<blockquote><pre>
It is currently 18:33 EST on 2015-W51-Sat which is also 2015-12-19
</pre></blockquote>

<p>
Or if you want to find the civil date of the last day of the ISO week year for 2015, then
(knowning the last day of the week is Sunday in this calendar) it is:
</p>

<blockquote><pre>
using namespace iso_week::literals;
std::cout &lt;&lt; date::year_month_day{2015_y/last/sun} &lt;&lt; '\n';
</pre></blockquote>

<p>
Which will output:
</p>

<blockquote><pre>
2016-01-03
</pre></blockquote>

<p>
And of course one can convert in the opposite direction:
</p>

<blockquote><pre>
using namespace date::literals;
std::cout &lt;&lt; iso_week::year_weeknum_weekday{2016_y/1/3} &lt;&lt; '\n';
</pre></blockquote>

<p>
Which will output:
</p>

<blockquote><pre>
2015-W53-Sun
</pre></blockquote>

<p>
In particular, note that for this day, the <code>iso_week::year</code> is 2015 and the
<code>date::year</code> is 2016.
</p>

<p>
This brings us to an important type-safety feature of these libraries:  The
<code>iso_week::year</code> and the <code>date::year</code> are two <i>distinct</i> types.
They represent concepts that are <i>very</i> similar.  They almost always have the same
value for the same <code>day_point</code>.  But as in this example, they are occasionally
different.  It is not unheard of for computer systems to conflate these two very similar
types, resulting in bugs that are hard to find because they are relatively rare.  Having
the C++ type system help you keep these similar but different concepts distinct is a
solid step towards finding bugs at compile time!
</p>

<a name="Reference"></a><h2>Reference</h2>

<p>
Here is a detailed specification of the entire library.  This specification is detailed
enough that you could write your own implementation from it if desired.  But feel free
to use <a href="https://github.com/HowardHinnant/date/blob/master/iso_week.h">this one</a>
instead.  Each type, and each operation is simple
and predictable.
</p>

<table>
<tr><td>durations</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#days"><code>days</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#weeks"><code>weeks</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#years"><code>years</code></a></td></tr>

<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>time_point</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#day_point"><code>day_point</code></a></td></tr>

<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>types</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#last_week"><code>last_week</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>

</table>

<p>
Everything here is contained in the namespace <code>iso_week</code>. The literal
operators, and the constexpr field literals (e.g. <code>sun</code>, <code>last</code>,
etc.) are in namespace <code>iso_week::literals</code> and imported into namespace
<code>iso_week</code>.
</p>

<a name="days"></a><h3><code>days</code></h3>

<blockquote>
<p>
<code>days</code> is a <code>std::chrono::duration</code> with a tick period of 24 hours.
This definition is not an SI unit but <a
href="http://www.bipm.org/en/publications/si-brochure/table6.html">is accepted for use
with SI</a>.  <code>days</code> is the resultant type when subtracting two
<code>day_point</code>s.
</p>
<pre>
using days = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;24&gt;, std::chrono::hours::period&gt;&gt;;
</pre></blockquote>

<a name="weeks"></a><h3><code>weeks</code></h3>

<blockquote>
<p>
<code>weeks</code> is a <code>std::chrono::duration</code> with a tick period of 7 days.
This definition is widely recognized and predates the Gregorian calendar.  It is
consistent with <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>.
<code>weeks</code> will implicitly convert to <code>days</code> but not vice-versa.
</p>
<pre>
using weeks = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;7&gt;, days::period&gt;&gt;;
</pre></blockquote>

<a name="years"></a><h3><code>years</code></h3>

<blockquote>
<p>
<code>years</code> is a <code>std::chrono::duration</code> with a tick period of 365.2425
days.  This definition accurately describes the length of the average year in the
ISO week calendar.  <code>years</code> is the resultant type when subtracting two
<code>year</code> field-based time points.  <code>years</code> is not implicitly
convertible to <code>days</code> or <code>weeks</code> nor vice-versa.
</p>
<pre>
using years = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;146097, 400&gt;, days::period&gt;&gt;;
</pre></blockquote>

<a name="day_point"></a><h3><code>day_point</code></h3>

<blockquote>
<p>
<code>day_point</code> is a <code>std::chrono::time_point</code> using
<code>std::chrono::system_clock</code> and <code>days</code>.  This makes
<code>day_point</code> interoperable with
<code>std::chrono::system_clock::time_point</code>.  It is simply a count of days since
the epoch of <code>std::chrono::system_clock</code> which in every implementation is
Jan. 1, 1970.  <code>day_point</code> is a serial-based time point with a resolution of
<code>days</code>.
</p>
<pre>
using day_point = std::chrono::time_point&lt;std::chrono::system_clock, days&gt;;
</pre>
</blockquote>

<a name="last_week"></a><h3><code>last_week</code></h3>

<blockquote>
<p>
<code>last_week</code> is a <code>struct</code> that is <code>CopyConstructible</code>.
There exists a <code>constexpr</code> instance of <code>last_week</code> named
<code>last</code>.  This is simply a tag type.  It is used to indicate the last day of
a month, or the last weekday of a month.
</p>
<pre>
struct last_week
{
    explicit last_week() = default;
};

inline namespace literals
{

constexpr iso_week::last_week last{};

}
</pre>

<p>
I am leading the C++ standard here a little with the <code>explicit</code> qualifier on
the default constructor.  This compiles today, but doesn't have quite the desired
semantics.  But it will when
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_toc.html#1518">CWG 1518</a>
passes.  This will make it so that <code>{}</code> won't implicitly convert to
<code>last_week</code>.  This addresses the concern expressed in
<a href="http://cplusplus.github.io/LWG/lwg-toc.html#2510">LWG 2510</a>.
</p>

</blockquote>

<p><i>Under construction!</i></p>

</body>
</html>
