<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>iso_week</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
	code {white-space:pre;}
	</style>
</head>
<body>

<address align=right>
<br/>
<br/>
<a href="mailto:howard.hinnant@gmail.com">Howard E. Hinnant</a><br/>
2015-12-22<br/>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"> <img alt="Creative
Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br /> This work is licensed
under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
Commons Attribution 4.0 International License</a>.
</address>
<hr/>
<h1 align=center><code>iso_week</code></h1>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Implementation">Implementation</a></li>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Reference">Reference</a></li>
</ul>

<a name="Introduction"></a><h2>Introduction</h2>

<p>
This paper fully documents an
<a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO week date calendar</a>
that is fully interoperable with
<a href="date_v2.html"><code>date</code></a>.
</p>

<a name="Implementation"></a><h2>Implementation</h2>

<p>
This entire library is implemented in a single header:
<a href="https://github.com/HowardHinnant/date/blob/master/iso_week.h">iso_week.h</a>
and is open source using the MIT license.
</p>

<a name="Overview"></a><h2>Overview</h2>

<p>
This library creates field types that hold the year, week number and weekday
associated with a <a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO week date</a>.
For example, to specify the Saturday of the 51st week of 2015 one can say:
</p>

<blockquote><pre>
#include "iso_week.h"
#include &lt;iostream&gt;

int
main()
{
    using namespace iso_week::literals;
    auto iso_date = sat/51/2015;
    std::cout &lt;&lt; iso_date &lt;&lt; '\n';
}
</pre></blockquote>

<p>
The output of this program is:
</p>

<blockquote><pre>
2015-W51-Sat
</pre></blockquote>

<p>
In this example <code>iso_date</code> has type <code>iso_week::year_weeknum_weekday</code>,
and this type does nothing but hold the three quantities: <code>year</code>,
<code>weeknum</code> and <code>weekday</code>.  This is such trivial functionality that
it almost seems useless.  Anyone can write a type to be constructed from three values,
and then print them back out when requested.
</p>

<p>
The real power of <code>year_weeknum_weekday</code> is that it can implicitly convert to
and from <a href="date_v2.html#day_point"><code>day_point</code></a>.  And
 <a href="date_v2.html#day_point"><code>day_point</code></a> is just a type alias for:
</p>

<blockquote><pre>
std::chrono::time_point&lt;std::chrono::system_clock, days&gt;
</pre></blockquote>

<p>
This is the exact same <code>day_point</code> used by the
<a href="date_v2.html"><code>date</code></a> and <a href="tz.html">time zone</a>
libraries.  And so by simply having conversions to and from <code>day_point</code>,
<code>iso_week::year_weeknum_weekday</code> becomes seamlessly interoperable with all
of the types in <a href="date_v2.html"><code>date</code></a> and
<a href="tz.html">time zone</a> such as <code>date::year_month_day</code> and
<code>date::Zone</code>:
</p>

<blockquote><pre>
#include "date.h"
#include "iso_week.h"
#include "tz.h"
#include &lt;iostream&gt;

int
main()
{
    using namespace std::chrono;
    using namespace date;
    using namespace iso_week;
    auto zone = locate_zone("America/New_York");
    auto now = zone-&gt;to_local(system_clock::now());
    auto dp = floor&lt;days&gt;(now.first);
    auto iso_date = year_weeknum_weekday{dp};
    auto civil_date = year_month_day{dp};
    auto time = make_time(duration_cast&lt;minutes&gt;(now.first-dp));
    std::cout &lt;&lt; "It is currently " &lt;&lt; time &lt;&lt; ' ' &lt;&lt; now.second &lt;&lt; " on "
              &lt;&lt; iso_date &lt;&lt; " which is also " &lt;&lt; civil_date &lt;&lt; '\n';
}
</pre></blockquote>

<p>
Which just output for me:
</p>

<blockquote><pre>
It is currently 18:33 EST on 2015-W51-Sat which is also 2015-12-19
</pre></blockquote>

<p>
Or if you want to find the civil date of the last day of the ISO week year for 2015, then
(knowning the last day of the week is Sunday in this calendar) it is:
</p>

<blockquote><pre>
using namespace iso_week::literals;
std::cout &lt;&lt; date::year_month_day{2015_y/last/sun} &lt;&lt; '\n';
</pre></blockquote>

<p>
Which will output:
</p>

<blockquote><pre>
2016-01-03
</pre></blockquote>

<p>
And of course one can convert in the opposite direction:
</p>

<blockquote><pre>
using namespace date::literals;
std::cout &lt;&lt; iso_week::year_weeknum_weekday{2016_y/1/3} &lt;&lt; '\n';
</pre></blockquote>

<p>
Which will output:
</p>

<blockquote><pre>
2015-W53-Sun
</pre></blockquote>

<p>
In particular, note that for this day, the <code>iso_week::year</code> is 2015 and the
<code>date::year</code> is 2016.
</p>

<p>
This brings us to an important type-safety feature of these libraries:  The
<code>iso_week::year</code> and the <code>date::year</code> are two <i>distinct</i> types.
They represent concepts that are <i>very</i> similar.  They almost always have the same
value for the same <code>day_point</code>.  But as in this example, they are occasionally
different.  It is not unheard of for computer systems to conflate these two very similar
types, resulting in bugs that are hard to find because they are relatively rare.  Having
the C++ type system help you keep these similar but different concepts distinct is a
solid step towards finding bugs at compile time!
</p>

<a name="Reference"></a><h2>Reference</h2>

<p><i>Under construction!</i></p>

<p>
Here is a detailed specification of the entire library.  This specification is detailed
enough that you could write your own implementation from it if desired.  But feel free
to use <a href="https://github.com/HowardHinnant/date/blob/master/iso_week.h">this one</a>
instead.  Each type, and each operation is simple
and predictable.
</p>

<table>
<tr><td>durations</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#days"><code>days</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#weeks"><code>weeks</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#years"><code>years</code></a></td></tr>

<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>time_point</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#day_point"><code>day_point</code></a></td></tr>

<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>types</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#last_week"><code>last_week</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>

<tr><td>&nbsp;</td><td><a href="#weekday"><code>weekday</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#weeknum"><code>weeknum</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#year"><code>year</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>

<tr><td>&nbsp;</td><td><a href="#year_weeknum"><code>year_weeknum</code></a></td></tr>

</table>

<p>
Everything here is contained in the namespace <code>iso_week</code>. The literal
operators, and the constexpr field literals (e.g. <code>sun</code>, <code>last</code>,
etc.) are in namespace <code>iso_week::literals</code> and imported into namespace
<code>iso_week</code>.
</p>

<a name="days"></a><h3><code>days</code></h3>

<blockquote>
<p>
<code>days</code> is a <code>std::chrono::duration</code> with a tick period of 24 hours.
This definition is not an SI unit but <a
href="http://www.bipm.org/en/publications/si-brochure/table6.html">is accepted for use
with SI</a>.  <code>days</code> is the resultant type when subtracting two
<code>day_point</code>s.
</p>
<pre>
using days = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;24&gt;, std::chrono::hours::period&gt;&gt;;
</pre></blockquote>

<a name="weeks"></a><h3><code>weeks</code></h3>

<blockquote>
<p>
<code>weeks</code> is a <code>std::chrono::duration</code> with a tick period of 7 days.
This definition is widely recognized and predates the Gregorian calendar.  It is
consistent with <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>.
<code>weeks</code> will implicitly convert to <code>days</code> but not vice-versa.
</p>
<pre>
using weeks = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;7&gt;, days::period&gt;&gt;;
</pre></blockquote>

<a name="years"></a><h3><code>years</code></h3>

<blockquote>
<p>
<code>years</code> is a <code>std::chrono::duration</code> with a tick period of 365.2425
days.  This definition accurately describes the length of the average year in the
ISO week calendar.  <code>years</code> is the resultant type when subtracting two
<code>year</code> field-based time points.  <code>years</code> is not implicitly
convertible to <code>days</code> or <code>weeks</code> nor vice-versa.
</p>
<pre>
using years = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;146097, 400&gt;, days::period&gt;&gt;;
</pre></blockquote>

<a name="day_point"></a><h3><code>day_point</code></h3>

<blockquote>
<p>
<code>day_point</code> is a <code>std::chrono::time_point</code> using
<code>std::chrono::system_clock</code> and <code>days</code>.  This makes
<code>day_point</code> interoperable with
<code>std::chrono::system_clock::time_point</code>.  It is simply a count of days since
the epoch of <code>std::chrono::system_clock</code> which in every implementation is
Jan. 1, 1970.  <code>day_point</code> is a serial-based time point with a resolution of
<code>days</code>.
</p>
<pre>
using day_point = std::chrono::time_point&lt;std::chrono::system_clock, days&gt;;
</pre>
</blockquote>

<a name="last_week"></a><h3><code>last_week</code></h3>

<blockquote>
<p>
<code>last_week</code> is a <code>struct</code> that is <code>CopyConstructible</code>.
There exists a <code>constexpr</code> instance of <code>last_week</code> named
<code>last</code>.  This is simply a tag type.  It is used to indicate the last week of
the year.
</p>

<pre>
struct last_week
{
    explicit last_week() = default;
};

inline namespace literals
{

constexpr iso_week::last_week last{};

}
</pre>

<p>
I am leading the C++ standard here a little with the <code>explicit</code> qualifier on
the default constructor.  This compiles today, but doesn't have quite the desired
semantics.  But it will when
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_toc.html#1518">CWG 1518</a>
passes.  This will make it so that <code>{}</code> won't implicitly convert to
<code>last_week</code>.  This addresses the concern expressed in
<a href="http://cplusplus.github.io/LWG/lwg-toc.html#2510">LWG 2510</a>.
</p>

</blockquote>

<a name="weekday"></a><h3><code>weekday</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class weekday
{
    unsigned char wd_;  // exposition only
public:
    explicit constexpr weekday(unsigned wd) noexcept;
    constexpr weekday(const day_point&amp; dp) noexcept;
    constexpr weekday(date::weekday wd) noexcept;
    explicit weekday(int) = delete;

    weekday&amp; operator++() noexcept;
    weekday operator++(int) noexcept;
    weekday&amp; operator--() noexcept;
    weekday operator--(int) noexcept;

    weekday&amp; operator+=(const days&amp; d) noexcept;
    weekday&amp; operator-=(const days&amp; d) noexcept;

    constexpr explicit operator unsigned() const noexcept;
    constexpr operator date::weekday() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const weekday&amp; x, const weekday&amp; y) noexcept;
constexpr bool operator!=(const weekday&amp; x, const weekday&amp; y) noexcept;

constexpr weekday operator+(const weekday&amp; x, const days&amp;    y) noexcept;
constexpr weekday operator+(const days&amp;    x, const weekday&amp; y) noexcept;
constexpr weekday operator-(const weekday&amp; x, const days&amp;    y) noexcept;
constexpr days    operator-(const weekday&amp; x, const weekday&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weekday&amp; wd);

inline namespace literals
{
constexpr weekday mon{1u};
constexpr weekday tue{2u};
constexpr weekday wed{3u};
constexpr weekday thu{4u};
constexpr weekday fri{5u};
constexpr weekday sat{6u};
constexpr weekday sun{7u};
}  // namespace literals
</pre>

<p><b>Overview</b></p>

<p>
<code>weekday</code> represents a day of the week in the ISO week calendar.  It should
only be representing values in the range 1 to 7, corresponding to Monday thru Sunday. 
However it may hold values outside this range.  It can be constructed with any
<code>unsigned</code> value, which will be subsequently truncated to fit into
<code>weekday</code>'s internal storage.  <code>weekday</code> is equality comparable.
<code>weekday</code> is not less-than comparable because there is no universal consensus
on which day is the first day of the week.  This design chooses the encoding of 1 to 7 to
represent Monday thru Sunday only because this is consistent with ISO 8601.
 However  <code>weekday</code>'s comparison and arithmetic operations treat the
days of the week as a circular range, with no beginning and no end.   One can stream out a
<code>weekday</code> for debugging purposes. <code>weekday</code> has explicit conversions
to and from <code>unsigned</code>.  There are 7 <code>weekday</code> constants, one for each
day of the week.
</p>

<p>
A <code>weekday</code> can be implicitly constructed from a <code>day_point</code>. This
is the computation that discovers the day of the week of an arbitrary date.
</p>

<p>
A <code>weekday</code> can be implicitly converted to or from a <code>date::weekday</code>.
<code>iso_week::weekday</code> and <code>date::weekday</code> are distinct types, though
they represent very similar concepts.  <code>date::weekday</code> can be indexed, and
<code>iso_week::weekday</code> can not.  <code>date::weekday</code> is encoded as
[0, 6] representing [Sunday, Saturday], while <code>iso_week::weekday</code> is encoded as
[1, 7] representing [Monday, Sunday].  The conversion functions will correctly translate
between these encodings.
</p>

<p><b>Specification</b></p>

<p>
<code>weekday</code> is a trivially copyable class type.</br>
<code>weekday</code> is a standard-layout class type.</br>
<code>weekday</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr weekday::weekday(unsigned wd) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday</code> by constructing
<code>wd_</code> with <code>wd</code>.
</p>
</blockquote>

<pre>
constexpr weekday(const day_point&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday</code> by computing what day
of the week corresponds to the <code>day_point dp</code>, and representing that day of
the week in <code>wd_</code>.
</p>
<p>
<i>Example:</i> If <code>dp</code> represents 1970-01-01, the constructed
<code>weekday</code> shall represent Thursday by storing 4 in <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr weekday(date::weekday wd) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday</code> from a
<code>date::weekday</code>.  This changes the underlying encoding from [0, 6] -&gt;
[sun, sat] to [1, 7] -&gt; [mon, sun].
</p>
</blockquote>

<pre>
weekday&amp; weekday::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>wd_ != 6</code>, <code>++wd_</code>.  Otherwise sets
<code>wd_</code> to 0.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weekday weekday::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
weekday&amp; weekday::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>wd_ != 0</code>, <code>--wd_</code>.  Otherwise sets
<code>wd_</code> to 6.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weekday weekday::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
weekday&amp; weekday::operator+=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weekday&amp; weekday::operator-=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit weekday::operator unsigned() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr operator date::weekday() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> An object of type <code>date::weekday</code> constructed from
<code>*this</code>.  This changes the underlying encoding from [1, 7] -&gt; [mon, sun] to
[0, 6] -&gt; [sun, sat].
</p>
</blockquote>

<pre>
constexpr bool weekday::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>1 &lt;= wd_ &amp;&amp; wd_ &lt;= 7</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const weekday&amp; x, const weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>unsigned{x} == unsigned{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const weekday&amp; x, const weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator+(const weekday&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>weekday</code> for which <code>ok() == true</code> and is found as
if by incrementing (or decrementing if <code>y &lt; days{0}</code>) <code>x</code>,
<code>y</code> times.  If <code>weekday.ok() == false</code> prior to this operation,
behaves as if <code>*this</code> is first brought into the range [1, 7] by modular
arithmetic. [<i>Note:</i> For example <code>weekday{0}</code> becomes
<code>weekday{7}</code>. &mdash; <i>end note</i>]
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>y</code>.  That is, repeated
increments or decrements is not a valid implementation.
</p>
<p>
<i>Example:</i> <code>sun + days{6} == sat</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator+(const days&amp; x, const weekday&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator-(const weekday&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr days operator-(const weekday&amp;  x, const weekday&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>x.ok() == true</code> and <code>y.ok() == true</code>.
</p>
<p>
<i>Returns:</i> A value of <code>days</code> in the range of <code>days{0}</code> to
<code>days{6}</code> inclusive.
</p>
<p>
<i>Remarks:</i> The returned value <code>d</code> shall satisfy the equality:
<code>y + d == x</code>.
</p>
<p>
<i>Example:</i> <code>sat - sun == days{6}</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weekday&amp; wd);
</pre>

<blockquote>
<p>
<i>Effects:</i>  If <code>ok() == true</code> outputs the same string that would be
output for the weekday field by <code>asctime</code>, assuming the conversion
<code>unsigned{date::weekday{*this}}</code>.  Otherwise outputs
<code>unsigned{wd} &lt;&lt; " is not a valid weekday"</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="weeknum"></a><h3><code>weeknum</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class weeknum
{
    unsigned char wn_;  // exposition only

public:
    explicit constexpr weeknum(unsigned wn) noexcept;

    weeknum&amp; operator++() noexcept;
    weeknum operator++(int) noexcept;
    weeknum&amp; operator--() noexcept;
    weeknum operator--(int) noexcept;

    weeknum&amp; operator+=(const weeks&amp; w) noexcept;
    weeknum&amp; operator-=(const weeks&amp; w) noexcept;

    constexpr explicit operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const weeknum&amp; x, const weeknum&amp; y) noexcept;
constexpr bool operator!=(const weeknum&amp; x, const weeknum&amp; y) noexcept;
constexpr bool operator&lt; (const weeknum&amp; x, const weeknum&amp; y) noexcept;
constexpr bool operator&gt; (const weeknum&amp; x, const weeknum&amp; y) noexcept;
constexpr bool operator&lt;=(const weeknum&amp; x, const weeknum&amp; y) noexcept;
constexpr bool operator&gt;=(const weeknum&amp; x, const weeknum&amp; y) noexcept;

constexpr weeknum operator+(const weeknum&amp; x, const weeks&amp;   y) noexcept;
constexpr weeknum operator+(const weeks&amp;   x, const weeknum&amp; y) noexcept;
constexpr weeknum operator-(const weeknum&amp; x, const weeks&amp;   y) noexcept;
constexpr weeks   operator-(const weeknum&amp; x, const weeknum&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weeknum&amp; wn);

inline namespace literals
{

constexpr weeknum operator "" _w(unsigned long long wn) noexcept;

}
</pre>

<p><b>Overview</b></p>

<p>
<code>weeknum</code> represents a week number of of the ISO week-year [1, 53]. It should
only be representing values in the range 1 to 53.  However it may hold values outside this
range.  It can be constructed with any <code>unsigned</code> value, which will be
subsequently truncated to fit into <code>weeknum</code>'s internal storage. 
<code>weeknum</code> is equality and less-than comparable, and participates in basic
arithmetic with <code>weeks</code> representing the quantity between any two
<code>weeknum</code>'s.   One can stream out a <code>weeknum</code> for debugging
purposes. <code>weeknum</code> has explicit conversions to and from <code>unsigned</code>.
</p>

<p><b>Specification</b></p>

<p>
<code>weeknum</code> is a trivially copyable class type.</br>
<code>weeknum</code> is a standard-layout class type.</br>
<code>weeknum</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr weeknum::weeknum(unsigned wn) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weeknum</code> by constructing
<code>wn_</code> with <code>wn</code>.
</p>
</blockquote>

<pre>
weeknum&amp; weeknum::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++wn_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weeknum weeknum::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
weeknum&amp; weeknum::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--wn_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weeknum weeknum::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
weeknum&amp; weeknum::operator+=(const weeks&amp; w) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + w</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weeknum&amp; weeknum::operator-=(const weeks&amp; w) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - w</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit weeknum::operator unsigned() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wn_</code>.
</p>
</blockquote>

<pre>
constexpr bool weeknum::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>1 &lt;= wn_ && wn_ &lt;= 53</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const weeknum&amp; x, const weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>unsigned{x} == unsigned{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const weeknum&amp; x, const weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const weeknum&amp; x, const weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>unsigned{x} &lt; unsigned{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const weeknum&amp; x, const weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const weeknum&amp; x, const weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const weeknum&amp; x, const weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr weeknum  operator+(const weeknum&amp;  x, const weeks&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>weeknum{unsigned{x} + static_cast&lt;unsigned&gt;(y.count())}</code>
</p>
</blockquote>

<pre>
constexpr weeknum  operator+(const weeks&amp; x, const weeknum&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr weeknum  operator-(const weeknum&amp;  x, const weeks&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr weeks operator-(const weeknum&amp;  x, const weeknum&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>weeks{static_cast&lt;weeks::rep&gt;(unsigned{x}) -
              static_cast&lt;weeks::rep&gt;(unsigned{y})}</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weeknum&amp; wn);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts 'W' followed by a decimal integral text representation of
length 2, prefixed by '0' if the value is less than or equal to 9.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i> <code>5_w</code> is output as <code>W05</code>.</i>
</p>
</blockquote>

<pre>
constexpr weeknum operator "" _w(unsigned long long wn) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>weeknum{static_cast&lt;unsigned&gt;(wn)}</code>.
</p>
</blockquote>

</blockquote>

<a name="year"></a><h3><code>year</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class year
{
    short y_;  // exposition only

public:
    explicit constexpr year(int y) noexcept;

    year&amp; operator++() noexcept;
    year operator++(int) noexcept;
    year&amp; operator--() noexcept;
    year operator--(int) noexcept;

    year&amp; operator+=(const years&amp; y) noexcept;
    year&amp; operator-=(const years&amp; y) noexcept;

    constexpr explicit operator int() const noexcept;
    constexpr bool ok() const noexcept;

    static constexpr year min() noexcept;
    static constexpr year max() noexcept;
};

constexpr bool operator==(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator!=(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&lt; (const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&gt; (const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&lt;=(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&gt;=(const year&amp; x, const year&amp; y) noexcept;

constexpr year  operator+(const year&amp;  x, const years&amp; y) noexcept;
constexpr year  operator+(const years&amp; x, const year&amp;  y) noexcept;
constexpr year  operator-(const year&amp;  x, const years&amp; y) noexcept;
constexpr years operator-(const year&amp;  x, const year&amp;  y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year&amp; y);

inline namespace literals
{
constexpr year operator "" _y(unsigned long long y) noexcept;
}
</pre>

<p><b>Overview</b></p>

<p>
<code>year</code> represents a year in the
<a href="https://en.wikipedia.org/wiki/ISO_week_date">ISO week date calendar</a>.
It shall represent values in the range <code>[min(), max()]</code>.  It can be constructed
with any <code>int</code> value, which will be subsequently truncated to fit into
<code>year</code>'s internal storage.  <code>year</code> is equality and less-than
comparable, and participates in basic arithmetic with <code>years</code> representing the
quantity between any two <code>year</code>'s.  One can form a <code>year</code> literal
with <code>_y</code>.  And one can stream out a <code>year</code> for debugging purposes.
<code>year</code> has explicit conversions to and from <code>int</code>.
</p>

<p><b>Specification</b></p>

<p>
<code>year</code> is a trivially copyable class type.</br>
<code>year</code> is a standard-layout class type.</br>
<code>year</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr year::year(int y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year</code> by constructing
<code>y_</code> with <code>y</code>.
</p>
</blockquote>

<pre>
year&amp; year::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++y_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year year::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
year&amp; year::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--y_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year year::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
year&amp; year::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year&amp; year::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit year::operator int() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr bool year::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>min() &lt;= *this &amp;&amp; *this &lt;= max()</code>.
</p>
</blockquote>

<pre>
static constexpr year year::min() noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>year</code> constructed with the minimum representable year
number. This year shall be a value such that
<code>day_point{min()/1_w/mon} + Unit{0}</code>, where <code>Unit</code> is one of
<code>microseconds</code>, <code>milliseconds</code>, <code>seconds</code>,
<code>minutes</code>, or <code>hours</code>, there shall be no overflow.  [<i>Note:</i>
<code>nanoseconds</code> is intentionally omitted from this list. &mdash; <i>end note</i>]
</p>
</blockquote>

<pre>
static constexpr year year::max() noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>year</code> constructed with the maximum representable year
number. This year shall be a value such that
<code>day_point{max()/last/sun} + Unit{0}</code>, where <code>Unit</code> is one of
<code>microseconds</code>, <code>milliseconds</code>, <code>seconds</code>,
<code>minutes</code>, or <code>hours</code>, there shall be no overflow.  [<i>Note:</i>
<code>nanoseconds</code> is intentionally omitted from this list. &mdash; <i>end note</i>]
</p>
</blockquote>

<pre>
constexpr bool operator==(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>int{x} == int{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>int{x} &lt; int{y}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year  operator+(const year&amp;  x, const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{int{x} + y.count()}</code>.
</p>
</blockquote>

<pre>
constexpr year  operator+(const years&amp; x, const year&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr year  operator-(const year&amp;  x, const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr years operator-(const year&amp;  x, const year&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>years{int{x} - int{y}}</code>.
</p>
</blockquote>

<pre>
constexpr year operator "" _y(unsigned long long y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{static_cast&lt;int&gt;(y)}</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year&amp; y);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts a signed decimal integral text representation of <code>y</code>
into <code>os</code>. If the year is less than four decimal digits, pads the year with
<code>'0'</code> to four digits.  If the year is negative, prefixes with <code>'-'</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

<pre>
constexpr year operator "" _y(unsigned long long y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{static_cast&lt;int&gt;(y)}</code>.
</p>
</blockquote>

</blockquote>

<a name="year_weeknum"></a><h3><code>year_weeknum</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class year_weeknum
{
    iso_week::year    y_;
    iso_week::weeknum wn_;

public:
    constexpr year_weeknum(const iso_week::year&amp; y, const iso_week::weeknum&amp; wn) noexcept;

    constexpr iso_week::year    year()    const noexcept;
    constexpr iso_week::weeknum weeknum() const noexcept;

    year_weeknum&amp; operator+=(const years&amp; dy) noexcept;
    year_weeknum&amp; operator-=(const years&amp; dy) noexcept;

    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
constexpr bool operator!=(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
constexpr bool operator&lt; (const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
constexpr bool operator&gt; (const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
constexpr bool operator&lt;=(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
constexpr bool operator&gt;=(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;

constexpr year_weeknum operator+(const year_weeknum&amp; ym, const years&amp; dy) noexcept;
constexpr year_weeknum operator+(const years&amp; dy, const year_weeknum&amp; ym) noexcept;
constexpr year_weeknum operator-(const year_weeknum&amp; ym, const years&amp; dy) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_weeknum&amp; ym);
</pre>

<p><b>Overview</b></p>

<p>
<code>year_weeknum</code> is simply a collection of a <code>year</code> and a
<code>weeknum</code>.  It represents a specific week of a year, but not the day of the
week.  One can perform year-oriented arithmetic with a <code>year_weeknum</code>.  And
<code>year_weeknum</code> is equality and less-than comparable.
</p>

<p><b>Specification</b></p>

<p>
<code>year_weeknum</code> is a trivially copyable class type.</br>
<code>year_weeknum</code> is a standard-layout class type.</br>
<code>year_weeknum</code> is a literal class type.</br>
</p>

<pre>
constexpr year_weeknum::year_weeknum(const iso_week::year&amp; y, const iso_week::weeknum&amp; wn) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_weeknum</code> by constructing
<code>y_</code> with <code>y</code> and <code>wn_</code> with <code>wn</code>.
</p>
</blockquote>

<pre>
constexpr iso_week::year year_weeknum::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr iso_week::weeknum year_weeknum::weeknum() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wn_</code>.
</p>
</blockquote>

<pre>
year_weeknum&amp; year_weeknum::operator+=(const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + dy</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_weeknum&amp; year_weeknum::operator-=(const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - dy</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr bool year_weeknum::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_.ok() &amp;&amp; 1_w &lt;= wn_ &amp;&amp; wn_ &lt;= (y_/last).weeknum()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.weeknum() == y.weeknum()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() &lt; y.year() ? true
     : (x.year() &gt; y.year() ? false
     : (x.weeknum() &lt; y.weeknum()))</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year_weeknum&amp; x, const year_weeknum&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year_weeknum operator+(const year_weeknum&amp; ym, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>(ym.year() + dy) / ym.weeknum()</code>.
</p>
</blockquote>

<pre>
constexpr year_weeknum operator+(const years&amp; dy, const year_weeknum&amp; ym) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_weeknum operator-(const year_weeknum&amp; ym, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + -dy</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_weeknum&amp; ym);
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>os &lt;&lt; ywn.year() &lt;&lt; '-' &lt;&lt; ywn.weeknum()</code>.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

</body>
</html>
