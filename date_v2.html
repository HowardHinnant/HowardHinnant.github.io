<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>date v2</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
	code {white-space:pre;}
	</style>
</head>
<body>

<address align=right>
<br/>
<br/>
<a href="mailto:howard.hinnant@gmail.com">Howard E. Hinnant</a><br/>
2015-04-18<br/>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"> <img alt="Creative
Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br /> This work is licensed
under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
Commons Attribution 4.0 International License</a>.
</address>
<hr/>
<h1 align=center><code>date</code> v2</h1>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Implementation">Implementation</a></li>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Reference">Reference</a></li>
</ul>

<a name="Introduction"></a><h2>Introduction</h2>

<p>
Whoa, I think I missed version 1...
</p>

<p>
Version 1 is documented <a href="http://howardhinnant.github.io/date.html">here</a>.  It
was never an official standards proposal, though I did take the liberty of presenting it
to the LWG in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3244.pdf">
Bloomington, IN in Aug. of 2011</a>.  That proposal was met with several strong objections
including:
</p>

<ul>
<li>
Efficiency concerns
<ul>
<li>Excessive checking for date validity</li>
<li>Use of operator overloading to construct dates -- excessive copying</li>
</ul>
</li>
<li>The use of <code>operator/()</code> is too cute.</li>
<li>The runtime state of the date is mysterious.</li>
</ul>

<p>
Additionally a criticism I have developed of v1 is that there was no recognized need for
separate data structures representing <code>{year, month, day}</code> and
<code>{sequential count of days}</code>.  Recognition of this fact is crucial in
establishing performance expectations.  Just as you would never routinely randomly access
a <code>std::list</code>, or insert on the front of a <code>std::vector</code>, one should
also recognize the basic performance differences between <code>{year, month, day}</code>
and <code>{sequential count of days}</code>.
</p>

<p>
For example:
</p>

<ul>
<li><p>
One can very efficiently return <code>year</code>, <code>month</code> and <code>day</code>
from a <code>{year, month, day}</code> data structure.  However significant computation is
required to return this information from a <code>{sequential count of days}</code> data
structure.
</p></li>

<li><p>
One can very efficiently return <code>day of week</code>, from a
<code>{sequential count of days}</code> data structure.  However significant computation
is required to return this information from a <code>{year, month, day}</code> data
structure.
</p></li>

<li><p>
One can very efficiently return the number of days between two
<code>{sequential count of days}</code> data structures.  But it requires significant
computation to return the number of days between two <code>{year, month, day}</code> data
structures.
</p></li>
</ul>

<p>
Each data structure (<code>{year, month, day}</code> and
<code>{sequential count of days}</code>) has strengths and weaknesses.  Neither is always
superior to the other. Just like <code>std::list</code> and <code>std::vector</code>, it
is beneficial to offer both data structures, and give the client the ability to chose the
correct data structure for his task.  Obviously this should include the ability to convert
between <code>{year, month, day}</code> and <code>{sequential count of days}</code>.  Such
conversions will mark significant computational expenses as demonstrated in
<a href="http://howardhinnant.github.io/date_algorithms.html#days_from_civil"><code> days_from_civil</code></a>
and
<a href="http://howardhinnant.github.io/date_algorithms.html#civil_from_days"><code> civil_from_days</code></a>.
</p>

<p>
The design presented herein has been strongly influenced by two language features, which
were not used in version 1:
</p>

<ul>
<li><code>auto</code>:  The design herein has a plethora of types. However with
<code>auto</code> one often doesn't have to bother to spell a type.  The compiler
knows what type it is.  And the syntax of the code shows what the type is supposed
to do.</li>
<li><code>constexpr</code>:  In C++14 many things can be made <code>constexpr</code>,
and thus much less attention is paid to clever template meta programming tricks.
<code>constexpr</code> code is simpler to read and write.</li>
</ul>

<a name="Implementation"></a><h2>Implementation</h2>

<p>
This entire library is implemented in a single header: <a href="date.h">date.h</a> and is
open source (with generous open source terms &mdash; not generous enough? Contact me, I'm
flexible).
</p>

<p>
It uses the algorithms from
<a href="http://howardhinnant.github.io/date_algorithms.html"><code>chrono</code>-Compatible Low-Level Date Algorithms</a>.
If you want detailed explanations of the algorithms, go there.
</p>

<p>
It requires C++14, but really only for the <code>constexpr</code> bits.  The code will
auto-adopt to C++11, sacrificing several <code>constexpr</code> declarations.  In C++11,
this will effectively transfer some computations that should be done at compile-time to
run-time.  Porting to C++98/03 has not been attempted.
</p>

<a name="Overview"></a><h2>Overview</h2>

<p>
The entire library is in namespace <code>date</code>.  It is interoperable with the
<code>std::chrono</code> library.  Indeed it even builds major components out of
<code>std::chrono</code> <code>duration</code> and <code>time_point</code>.  The examples
in this overview assume:
</p>

<blockquote><pre>
using namespace date;
using namespace std::chrono;
</pre></blockquote>

<p>
in order to cut down on the verbosity.
</p>

<h3>Major Concepts</h3>

<p>
A date on a calendar is a time point with a resolution of one day.  This is not
conceptually different from <code>std::chrono::system_clock::time_point</code> which is a
time point with a resolution of <code>std::chrono::system_clock::period</code> (typically
on the order of a microsecond or nanosecond).  Time points are divided into two basic
types:
</p>

<ol>
<li>serial-based</li>
<li>field-based</li>
</ol>

<p>
This terminology is gratefully borrowed from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3344.pdf">N3344</a>.  In
short, a <i>serial-based</i> time point stores a single count of time durations from some epoch.
<code>std::chrono::system_clock::time_point</code> is an example of a <i>serial-based</i>
time point.  A count of days from some epoch is also a <i>serial-based</i> time point.
A <i>field-based</i> time point represents the same concept, but with several fields that
are typically used for human consumption.  For example one might represent the time of day
with the number of seconds since midnight (<i>serial-based</i>), or with a structure such
as <code>{hours, minutes, seconds}</code> since midnight (<i>field-based</i>).  Similarly
one can represent a date with a count of days, or with a <code>{year, month, day}</code>
structure.  Both representations are useful, and each has its strengths and weaknesses.
</p>

<h3>Major Types</h3>

<p>
This library is composed of many types.  But here are the most important ones:
</p>

<ol>
<li><code>day_point</code>: A count of days since <code>system_clock</code>'s epoch.  This
is a serial-based time point with a resolution of one day.</li>
<li><code>year_month_day</code>: A type that holds a year (e.g. 2015), a month
(encoded as 1 thru 12), and a day (encoded as 1 thru 31).  This is a field-based time
point with a resolution of one day.</li>
<li><code>year_month_weekday</code>:  A type that holds a year (e.g. 2015), a month
(encoded as 1 thru 12), a day of the week (encoded as 0 thru 6), and an index in the range
[1, 5] indicating if this is the first, second, etc. weekday of the indicated month. This
is a field-based time point with a resolution of one day.</li>
<li>
<code>year_month</code>: A type that holds a year and a month.  This is a field-based
time point with a resolution of one month.  This time point implements month-based
arithmetic, which other field-based time points can reuse.
</li>
</ol>

<h3>Example: Today</h3>

<p>
To get today as a <code>day_point</code>, use <code>system_clock::now()</code> and
<code>time_point_cast</code> to convert the <code>time_point</code> to a
<code>day_point</code>:
</p>

<blockquote><pre>
auto today = time_point_cast&lt;days&gt;(system_clock::now());
cout &lt;&lt; today.time_since_epoch().count() &lt;&lt; '\n';
</pre></blockquote>

<p>
Currently this outputs for me:
</p>

<blockquote><pre>
16516
</pre></blockquote>

<p>
Which obtusely indicates that I wrote this 16,516 days after the epoch.
</p>

<p>
To get today as a <code>year_month_day</code>, get a <code>day_point</code> as above and
convert it to a <code>year_month_day</code>:
</p>

<blockquote><pre>
auto today = year_month_day{time_point_cast&lt;days&gt;(system_clock::now())};
cout &lt;&lt; today &lt;&lt; '\n';
</pre></blockquote>

<p>
Currently this outputs for me:
</p>

<blockquote><pre>
2015-03-22
</pre></blockquote>

<p>
Which coincidently is 16,516 days after Jan. 1, 1970.
</p>

<p>
To get today as a <code>year_month_weekday</code>, get a <code>day_point</code> as above and
convert it to a <code>year_month_weekday</code>:
</p>

<blockquote><pre>
auto today = year_month_weekday{time_point_cast&lt;days&gt;(system_clock::now())};
cout &lt;&lt; today &lt;&lt; '\n';
</pre></blockquote>

<p>
Currently this outputs for me:
</p>

<blockquote><pre>
2015/Mar/Sun[4]
</pre></blockquote>

<p>
This indicates that today (2015-03-22) is the fourth Sunday of Mar., 2015.
</p>

<h3>Example: Constructing dates</h3>

<p>
<code>constexpr</code> dates can be constructed from literals in one of 3 orders:
</p>

<blockquote><pre>
constexpr auto x1 = 2015_y/mar/22;
constexpr auto x2 = mar/22/2015;
constexpr auto x3 = 22_d/mar/2015;
</pre></blockquote>

<p>
<code>x1</code>, <code>x2</code> and <code>x3</code> all have the type
<code>year_month_day</code> and are all equal to one another.  Any other order, or any
ambiguity is caught at compile time.
</p>

<p>
Integral types can be converted to <code>year</code>, <code>month</code>, or
<code>day</code> to create run time values:
</p>

<blockquote><pre>
int y = 2015;
int m = 3;
int d = 22;
auto x1 = year(y)/m/d;
auto x2 = month(m)/d/y;
auto x3 = day(d)/m/y;
</pre></blockquote>

<p>
As long as the type of the first date component is known, the following components become
unambiguous and can be formed either with the proper type, or with an <code>int</code>
expression. And since there is only one order with <code>day</code> in the middle, that
order need only properly type the <code>day</code> to remain unambiguous:
</p>

<blockquote><pre>
auto x = m/day(d)/y;
</pre></blockquote>

<p>
Anywhere you can specify a <code>day</code> you can instead specify <code>last</code>
to indicate the last day of the month for that year:
</p>

<blockquote><pre>
constexpr auto x1 = 2015_y/feb/last;
constexpr auto x2 = feb/last/2015;
constexpr auto x3 = last/feb/2015;
</pre></blockquote>

<p>
Instead of constructing a <code>year_month_day</code>, these expressions construct a
<code>year_month_day_last</code>.  This type always represents the last day of a
<code>year</code> and <code>month</code>.  <code>year_month_day_last</code> will
implicitly convert to <code>year_month_day</code>.
</p>

<p>
Anywhere you can specify a <code>day</code> you can instead specify an <i>indexed</i>
<code>weekday</code> to indicate the nth weekday of the month for that year:
</p>

<blockquote><pre>
constexpr auto x1 = 2015_y/mar/sun[4];
constexpr auto x2 = mar/sun[4]/2015;
constexpr auto x3 = sun[4]/mar/2015;
</pre></blockquote>

<p>
The type constructed is <code>year_month_weekday</code> which will implicitly convert to
and from a <code>day_point</code>.  If you want to convert to a
<code>year_month_day</code> you can do so explicitly, which will implicitly convert to
<code>day_point</code> and back:
</p>

<blockquote><pre>
constexpr auto x4 = year_month_day(x3);
</pre></blockquote>

<p>
<code>weekday</code>'s can be indexed with <code>last</code> and used as above:
</p>

<blockquote><pre>
constexpr auto x1 = 2015_y/mar/sun[last];
constexpr auto x2 = mar/sun[last]/2015;
constexpr auto x3 = sun[last]/mar/2015;
constexpr auto x4 = year_month_day(x3);
cout &lt;&lt; x3 &lt;&lt; '\n';
cout &lt;&lt; x4 &lt;&lt; '\n';
</pre></blockquote>

<p>
This creates an object of type <code>year_month_weekday_last</code>.  The above code
outputs:
</p>

<blockquote><pre>
2015/Mar/Sun[last]
2015-03-29
</pre></blockquote>

<p>
If you hate the cute syntax, don't use it.  Every type has a descriptive name, and public
type-safe constructors to do the same job:
</p>

<blockquote><pre>
constexpr auto x1 = 2015_y/mar/sun[last];
constexpr auto x2 = year_month_weekday_last(year(2015), month(3), weekday_last(weekday(0)));
static_assert(x1 == x2, "");
static_assert(is_same&lt;decltype(x1), decltype(x2)&gt;::value, "");
cout &lt;&lt; x1 &lt;&lt; '\n';
cout &lt;&lt; x2 &lt;&lt; '\n';

2015/Mar/Sun[last]
2015/Mar/Sun[last]
</pre></blockquote>

<h3>Errors</h3>

<p>
No exceptions are thrown in the entire library, except those that might be thrown from
<code>std::ostream</code> when streaming values to a <code>std::ostream</code>.  Most of
the types have a <code>constexpr const</code> member function named <code>ok()</code>
which returns <code>true</code> if the object represents a valid date, or date component,
and otherwise returns <code>false</code>.  However it is perfectly fine (and sometimes
actually useful) for these objects to contain invalid dates or date components.  For
example, here is a very simple and remarkably efficient program to output the odd Fridays
of every month in 2015:
</p>

<blockquote><pre>
int
main()
{
    using namespace std;
    using namespace date;
    for (auto m = 1; m &lt;= 12; ++m)
    {
        auto meet = year_month_day(m/fri[1]/2015);
        cout &lt;&lt; meet &lt;&lt; '\n';
        meet = meet.year()/meet.month()/(meet.day()+weeks(2));
        cout &lt;&lt; meet &lt;&lt; '\n';
        meet = meet.year()/meet.month()/(meet.day()+weeks(2));
        if (meet.ok())
            cout &lt;&lt; meet &lt;&lt; '\n';
    }
}
</pre></blockquote>

<p>
There is a relatively expensive (expense is relative here) conversion from
<code>year_month_weekday</code> to <code>year_month_day</code> at the top of the loop to
find the first Friday of the month.  This computation can never fail. And after that it is
dirt cheap to find the 3rd Friday &mdash; you just have to add 2 weeks to the day field. 
This computation also can never fail.  And it is similarly cheap to find the 5th Friday of
each month &mdash; with one exception.  Not every month has a fifth Friday.  But
nevertheless it is ok to form such a <code>year_month_day</code>. The computation can
never fail, though it may render an invalid date.  Afterwards one can simply ask: Did I
create a valid date?  If so, print it out, otherwise just continue on.
</p>

<p>
Subsequently, this entire library is liberally sprinkled with <code>noexcept</code>.
</p>

<p>
A few of the operations have a precondition that <code>ok() == true</code>.  These are
generally conversions to <code>day_point</code>, and month-oriented and weekday-oriented
arithmetic.  Anywhere there is a precondition, and those places are few, the precondition
is checkable with <code>ok()</code>.
</p>

<p>
This library catches many errors (especially ambiguity errors) at compile time.  What's
left over is left up to <code>ok()</code>.  Sometimes this will represent an error, and
other times it will simply represent something innocuous that can be ignored.  That
decision is made by the client of this library.
</p>

<h3>Efficiency</h3>

<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3344.pdf">N3344</a>
Pacifico, Meredith and Lakos present a thorough survey of date types and their performance.
This library has been strongly influenced by this excellent paper.
<code>year_month_day</code> is equivalent to what <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3344.pdf">N3344</a> terms <code>YMD_4</code>.  And
<code>day_point</code> is equivalent to what <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3344.pdf">N3344</a> terms <code>HH_SERIAL_RAW_4</code>.
</p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3344.pdf">N3344</a>
aptly demonstrates that field-based date structures are good at some operations and poor
at others.  And serial-based implementations are generally good at what the field-based
data structures are poor at, and poor at what the field-based data structures are good at.
 Indeed, this is the genesis of the design of this library:  Provide both data structures
and let the conversions among the data structures be provided by algorithms as shown in
<a href="http://howardhinnant.github.io/date_algorithms.html"><code>chrono</code>-Compatible Low-Level Date Algorithms</a>.
And additionally, just provide the API for each data structure that it can do efficiently.
</p>

<ul>
<li><p>
Field types are good at returning the values of the fields.  Serial types aren't (except
for weekdays).  So <code>year_month_day</code> has accessors for <code>year</code>,
<code>month</code> and <code>day</code>.  And <code>day_point</code> does not.
</p></li>
<li><p>
Field types are good at month and year-oriented arithmetic.  Serial types aren't.
So <code>year_month_day</code> has month and year-oriented arithmetic.  And
<code>day_point</code> does not.
</p></li>
<li><p>
Serial types are good at day-oriented arithmetic.  Field types aren't.
So <code>day_point</code> has day-oriented arithmetic.  And <code>year_month_day</code>
does not.  Though one can perform day-oriented arithmetic on the day field of a
<code>year_month_day</code>, with no impact on the other fields.
</p></li>
<li><p>
To efficiently compute a day of the week, one first needs to compute a serial date.  So
<code>weekday</code> is constructible from <code>day_point</code>.
</p></li>
</ul>

<p>
To demonstrate the efficiency of constructing a <code>year_month_day</code>, a hypothetical
factory function has been created in the table below.  And this is compared with a
simplistic <code>struct YMD_4</code> and an obvious factory function for that.  Each is
compiled using clang at an optimization of -O2 or higher.
</p>

<blockquote>
<table border="1" cellpadding="10">
<caption><code>year_month_day</code> constructor assembly</caption>
<tr>

<td>
<pre>
date::year_month_day
make_year_month_day(int y, int m, int d)
{
    using namespace date;
    return year(y)/m/d;
}
</pre>
</td>

<td>
<pre>
struct YMD_4
{
    std::int16_t year;
    std::uint8_t month;
    std::uint8_t day;
};

YMD_4
make_YMD_4(int y, int m, int d)
{
    return {static_cast&lt;std::int16_t&gt;(y),
            static_cast&lt;std::uint8_t&gt;(m),
            static_cast&lt;std::uint8_t&gt;(d)};
}
</pre>
</td>

</tr>

<tr>

<td>
<pre>
	.globl	__Z19make_year_month_dayiii
	.align	4, 0x90
__Z19make_year_month_dayiii:
	.cfi_startproc
## BB#0:
	pushq	%rbp
Ltmp2:
	.cfi_def_cfa_offset 16
Ltmp3:
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
Ltmp4:
	.cfi_def_cfa_register %rbp
	shll	$24, %edx
	shll	$16, %esi
	andl	$16711680, %esi
	movzwl	%di, %eax
	orl	%edx, %eax
	orl	%esi, %eax
	popq	%rbp
	retq
	.cfi_endproc
</pre>
</td>

<td>
<pre>
	.globl	__Z10make_YMD_4iii
	.align	4, 0x90
__Z10make_YMD_4iii:
	.cfi_startproc
## BB#0:
	pushq	%rbp
Ltmp2:
	.cfi_def_cfa_offset 16
Ltmp3:
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
Ltmp4:
	.cfi_def_cfa_register %rbp
	shll	$24, %edx
	shll	$16, %esi
	andl	$16711680, %esi
	movzwl	%di, %eax
	orl	%esi, %eax
	orl	%edx, %eax
	popq	%rbp
	retq
	.cfi_endproc
</pre>
</td>

</tr>
</table>

</blockquote>

<p>
One can see that the generated assembler is virtually identical for these two factory
functions.  I.e. the code size and run time overhead of the "cute syntax" for constructing
a <code>year_month_day</code> is zero, at least in optimized builds.
</p>

<p>
A similar experiment is made for constructing a <code>day_point</code> from a count of
days held in an <code>int</code>.  To do this one must first create a <code>days</code>
duration, and then construct the <code>day_point</code> from the <code>days</code>
duration.  This is contrasted with the very simplistic <code>struct SERIAL_4</code>.
</p>

<blockquote>
<table border="1" cellpadding="10">
<caption><code>day_point</code> constructor assembly</caption>
<tr>

<td>
<pre>
date::day_point
make_day_point(int z)
{
    using namespace date;
    return day_point{days{z}};
}
</pre>
</td>

<td>
<pre>
struct SERIAL_4
{
    std::int32_t count;
};

SERIAL_4
make_SERIAL_4(int z)
{
    return {z};
}
</pre>
</td>

</tr>

<tr>

<td>
<pre>
	.globl	__Z14make_day_pointi
	.align	4, 0x90
__Z14make_day_pointi:
	.cfi_startproc
## BB#0:
	pushq	%rbp
Ltmp2:
	.cfi_def_cfa_offset 16
Ltmp3:
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
Ltmp4:
	.cfi_def_cfa_register %rbp
	movl	%edi, %eax
	popq	%rbp
	retq
	.cfi_endproc
</pre>
</td>

<td>
<pre>
	.globl	__Z13make_SERIAL_4i
	.align	4, 0x90
__Z13make_SERIAL_4i:
	.cfi_startproc
## BB#0:
	pushq	%rbp
Ltmp2:
	.cfi_def_cfa_offset 16
Ltmp3:
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
Ltmp4:
	.cfi_def_cfa_register %rbp
	movl	%edi, %eax
	popq	%rbp
	retq
	.cfi_endproc
</pre>
</td>

</tr>
</table>

</blockquote>

<p>
It is easy to see that the generated code is identical, and thus there is no overhead
associated with the <code>day_point</code> type.  It is also noteworthy that the code for
this construction does not actually come from this <code>date</code> library, but instead
comes from your std::lib header <code>&lt;chrono&gt;</code>.  <code>days</code> is nothing
but a <i>type-alias</i> for a <code>std::chrono::duration</code>, and
<code>day_point</code> is nothing but a <i>type-alias</i> for a
<code>std::chrono::time_point</code> (thus the inspiration for the name
<code>day_point</code>).  So this is also evidence that there is zero overhead for the
type-safe system of the <code>&lt;chrono&gt;</code> library.
</p>

<a name="shift_epoch"></a>
<p>
One final example taken from real-world code.  Below are two ways of implementing a system
which counts seconds since Jan. 1, 2000:  One that uses this library and another that
simply stores the count of seconds in a <code>long</code>.  A utility is needed to convert
that count to <a href="http://en.wikipedia.org/wiki/Unix_time">Unix Time</a>, which simply
involves shifting the epoch to Jan. 1, 1970.
</p>

<blockquote>
<table border="1" cellpadding="10">
<caption>Shift epoch from <code>jan/1/2000</code> to <code>jan/1/1970</code></caption>
<tr>

<td>
<pre>
using time_point = std::chrono::time_point&lt;std::chrono::system_clock,
                                           std::chrono::seconds&gt;;

time_point
ripple2system(time_point t)
{
    using namespace date;
    return t + (day_point(jan/1/2000) - day_point(jan/1/1970));
}
</pre>
</td>

<td>
<pre>
long
ripple2system_old(long t)
{
    return t + 946684800;
}
</pre>
</td>

</tr>

<tr>

<td>
<pre>
	.globl	__Z13ripple2systemNSt3__16chrono10time_pointINS0...
	.align	4, 0x90
__Z13ripple2systemNSt3__16chrono10time_pointINS0...
	.cfi_startproc
## BB#0:
	pushq	%rbp
Ltmp2:
	.cfi_def_cfa_offset 16
Ltmp3:
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
Ltmp4:
	.cfi_def_cfa_register %rbp
	leaq	946684800(%rdi), %rax
	popq	%rbp
	retq
	.cfi_endproc
</pre>
</td>

<td>
<pre>
	.globl	__Z17ripple2system_oldl
	.align	4, 0x90
__Z17ripple2system_oldl:
	.cfi_startproc
## BB#0:
	pushq	%rbp
Ltmp2:
	.cfi_def_cfa_offset 16
Ltmp3:
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
Ltmp4:
	.cfi_def_cfa_register %rbp
	leaq	946684800(%rdi), %rax
	popq	%rbp
	retq
	.cfi_endproc
</pre>
</td>

</tr>
</table>

</blockquote>

<p>
On the left we have a strongly typed solution which makes it explicit that the code is
adding a time duration equal to the difference between the two epochs.  Though verbose,
the code is easy to read.  On the right we have the maximally efficient, and yet relatively
cryptic implementation with <code>long</code>.  As it turns out, there are 946,684,800
seconds between these two epochs ... who knew?
</p>

<p>
clang generates <i>identical</i> assembly for these two functions at -O2 and higher.  That
is, the sub-expression <code>(day_point(jan/1/2000) - day_point(jan/1/1970))</code> is
reduced down to a number of days (10,957) <i>at compile time</i>, and then this
sub-expression, which has type <code>days</code> is added to a <code>time_point</code>
with a resolution of <code>seconds</code>, which causes the compiler to convert
<code>days{10957}</code> to <code>seconds{946684800}</code>, again <i>at compile time</i>.
</p>

<p>
And in the strongly typed case, if in the future one decides that one wants to count
milliseconds instead of seconds, that can be changed in <b>one</b> place:
</p>

<blockquote>
<pre>
using time_point = std::chrono::time_point&lt;std::chrono::system_clock,
                                           std::chrono::<ins>milli</ins>seconds&gt;;
</pre>
</blockquote>

<p>
Upon recompile the compiler automatically updates the compile-time constant in
<code>ripple2system</code> from 946684800 to 946684800000 (and everywhere else such as
where you perform the epoch shift in the reverse direction).
</p>

<h3>What about a date-time type?</h3>

<p>
You already have a good one. It is called
<code>std::chrono::system_clock::time_point</code>. And it is completely interoperable
with <code>day_point</code>.  
</p>

<p>
<code>day_point</code> is nothing but a <code>std::chrono::system_clock::time_point</code>
with much longer tick periods.  Thus one can view a <code>day_point</code> as referring
to an entire day, or blink your eyes and it is a precise pointer to the very beginning
of a day:  00:00:00 UTC.
</p>

<p>
For example here is a <code>std::chrono::time_point</code> referring to 2015-03-22
18:30:00 UTC:
</p>

<blockquote><pre>
auto tp = day_point(mar/22/2015) + 18h + 30min;
</pre></blockquote>

<p>
And here is how long ago <code>tp</code> was:
</p>

<blockquote><pre>
auto diff = system_clock::now() - tp;
</pre></blockquote>

<p>
To turn <code>tp</code> back into a year, month, day, hour, minute (say for human
readable output), do this:
</p>

<blockquote><pre>
auto dp = time_point_cast&lt;days&gt;(tp);  // truncate off days
auto ymd = year_month_day(dp);        // turn days-based time_point into year_month_day
auto time = make_time(tp-dp);         // subtract the two to get a duration which represents time of day
                                      // and break that down into hours:minutes
std::cout &lt;&lt; ymd &lt;&lt; ' ' &lt;&lt; time &lt;&lt; '\n';
</pre></blockquote>

<p>
Which outputs:
</p>

<blockquote><pre>
2015-03-22 18:30
</pre></blockquote>

<p>
Insert <code>time.make12();</code> to format as a 12-hour time and it will instead output:
</p>

<blockquote><pre>
2015-03-22 6:30pm
</pre></blockquote>

<p>
Need to traffic in your local time zone instead of UTC?  This library, at this time, does
not provide a packaged system for discovering your current UTC offset.  However this
would be a good foundational library for writing such a utility.  Daylight savings time
often triggers on events such as the second Sunday in March (e.g. <code>sun[2]/mar</code>),
or the last Sunday in March (e.g. <code>sun[last]/mar</code>).
</p>

<a name="Reference"></a><h2>Reference</h2>

<p>
Here is a detailed specification of the entire library.  This specification is detailed
enough that you could write your own implementation from it if desired.  But feel free
to use <a href="date.h">this one</a> instead.  Each type, and each operation is simple
and predictable.
</p>

<table>
<tr><td>durations</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#days"><code>days</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#weeks"><code>weeks</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#months"><code>months</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#years"><code>years</code></a></td></tr>

<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>time_point</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#day_point"><code>day_point</code></a></td></tr>

<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>types</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#last_spec"><code>last_spec</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#day"><code>day</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#month"><code>month</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#year"><code>year</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#weekday"><code>weekday</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#weekday_indexed"><code>weekday_indexed</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#weekday_last"><code>weekday_last</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#month_day"><code>month_day</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#month_day_last"><code>month_day_last</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#month_weekday"><code>month_weekday</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#month_weekday_last"><code>month_weekday_last</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#year_month"><code>year_month</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#year_month_day"><code>year_month_day</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#year_month_day_last"><code>year_month_day_last</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#year_month_weekday"><code>year_month_weekday</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#year_month_weekday_last"><code>year_month_weekday_last</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#time_of_day"><code>time_of_day</code></a></td></tr>

<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>date composition operators</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_1"><code>constexpr year_month operator/(const year&amp; y, const month&amp; m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_2"><code>constexpr year_month operator/(const year&amp; y, int   m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_3"><code>constexpr month_day operator/(const month&amp; m, const day&amp; d) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_4"><code>constexpr month_day operator/(const month&amp; m, int d) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_5"><code>constexpr month_day operator/(int   m, const day&amp; d) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_6"><code>constexpr month_day operator/(const day&amp; d, const month&amp; m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_7"><code>constexpr month_day operator/(const day&amp; d,   int m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_8"><code>constexpr month_day_last operator/(const month&amp; m, last_spec) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_9"><code>constexpr month_day_last operator/(int   m, last_spec) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_10"><code>constexpr month_day_last operator/(last_spec, const month&amp; m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_11"><code>constexpr month_day_last operator/(last_spec, int   m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_12"><code>constexpr month_weekday operator/(const month&amp; m, const weekday_indexed&amp; wdi) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_13"><code>constexpr month_weekday operator/(int   m, const weekday_indexed&amp; wdi) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_14"><code>constexpr month_weekday operator/(const weekday_indexed&amp; wdi, const month&amp; m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_15"><code>constexpr month_weekday operator/(const weekday_indexed&amp; wdi, int   m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_16"><code>constexpr month_weekday_last operator/(const month&amp; m, const weekday_last&amp; wdl) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_17"><code>constexpr month_weekday_last operator/(int   m, const weekday_last&amp; wdl) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_18"><code>constexpr month_weekday_last operator/(const weekday_last&amp; wdl, const month&amp; m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_19"><code>constexpr month_weekday_last operator/(const weekday_last&amp; wdl, int   m) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_20"><code>constexpr year_month_day operator/(const year_month&amp; ym, const day&amp; d) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_21"><code>constexpr year_month_day operator/(const year_month&amp; ym, int d) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_22"><code>constexpr year_month_day operator/(const year&amp; y, const month_day&amp; md) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_23"><code>constexpr year_month_day operator/(int  y, const month_day&amp; md) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_24"><code>constexpr year_month_day operator/(const month_day&amp; md, const year&amp; y) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_25"><code>constexpr year_month_day operator/(const month_day&amp; md, int  y) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_26"><code>constexpr year_month_day_last operator/(const year_month&amp; ym,   last_spec) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_27"><code>constexpr year_month_day_last operator/(const year&amp; y, const month_day_last&amp; mdl) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_28"><code>constexpr year_month_day_last operator/(int  y, const month_day_last&amp; mdl) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_29"><code>constexpr year_month_day_last operator/(const month_day_last&amp; mdl, const year&amp; y) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_30"><code>constexpr year_month_day_last operator/(const month_day_last&amp; mdl, int  y) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_31"><code>constexpr year_month_weekday operator/(const year_month&amp; ym, const weekday_indexed&amp; wdi) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_32"><code>constexpr year_month_weekday operator/(const year&amp;        y, const month_weekday&amp;   mwd) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_33"><code>constexpr year_month_weekday operator/(int         y, const month_weekday&amp;   mwd) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_34"><code>constexpr year_month_weekday operator/(const month_weekday&amp; mwd, const year&amp;          y) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_35"><code>constexpr year_month_weekday operator/(const month_weekday&amp; mwd, int           y) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_36"><code>constexpr year_month_weekday_last operator/(const year_month&amp; ym, const weekday_last&amp; wdl) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_37"><code>constexpr year_month_weekday_last operator/(const year&amp; y, const month_weekday_last&amp; mwdl) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_38"><code>constexpr year_month_weekday_last operator/(int  y, const month_weekday_last&amp; mwdl) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_39"><code>constexpr year_month_weekday_last operator/(const month_weekday_last&amp; mwdl, const year&amp; y) noexcept;</code></a></td></tr>
<tr><td>&nbsp;</td><td><a href="#_40"><code>constexpr year_month_weekday_last operator/(const month_weekday_last&amp; mwdl, int  y) noexcept;</code></a></td></tr>

<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><code>time_of_day</code> factory functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a href="#_41">
<pre>
template &lt;class Rep, class Period&gt;
constexpr
time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;
make_time(std::chrono::duration&lt;Rep, Period&gt; d) noexcept;
</pre></a></td></tr>

<tr><td>&nbsp;</td><td><a href="#_42">
<pre>
constexpr
time_of_day&lt;std::chrono::hours&gt;
make_time(std::chrono::hours h, unsigned md) noexcept;
</pre></a></td></tr>

<tr><td>&nbsp;</td><td><a href="#_43">
<pre>
constexpr
time_of_day&lt;std::chrono::minutes&gt;
make_time(std::chrono::hours h, std::chrono::minutes m, unsigned md) noexcept;
</pre></a></td></tr>

<tr><td>&nbsp;</td><td><a href="#_44">
<pre>
constexpr
time_of_day&lt;std::chrono::seconds&gt;
make_time(std::chrono::hours h, std::chrono::minutes m, std::chrono::seconds s,
          unsigned md) noexcept;
</pre></a></td></tr>

<tr><td>&nbsp;</td><td><a href="#_45">
<pre>
template &lt;class Rep, class Period,
          class = std::enable_if_t&lt;std::ratio_less&lt;Period, std::ratio&lt;1&gt;&gt;::value&gt;&gt;
constexpr
time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;
make_time(std::chrono::hours h, std::chrono::minutes m, std::chrono::seconds s,
          std::chrono::duration&lt;Rep, Period&gt; sub_s, unsigned md) noexcept
</pre></a></td></tr>

</table>

<p>
Everything here is contained in the namespace <code>date</code>.
</p>

<a name="days"></a><h3><code>days</code></h3>

<blockquote>
<p>
<code>days</code> is a <code>std::chrono::duration</code> with a tick period of 24 hours.
This definition is not an SI unit but <a
href="http://www.bipm.org/en/publications/si-brochure/table6.html">is accepted for use
with SI</a>.  <code>days</code> is the resultant type when subtracting two
<code>day_point</code>s.
</p>
<pre>
using days = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;24&gt;, std::chrono::hours::period&gt;&gt;;
</pre></blockquote>

<a name="weeks"></a><h3><code>weeks</code></h3>

<blockquote>
<p>
<code>weeks</code> is a <code>std::chrono::duration</code> with a tick period of 7 days.
This definition is widely recognized and predates the Gregorian calendar.  It is
consistent with <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>.
<code>weeks</code> will implicitly convert to <code>days</code> but not vice-versa.
</p>
<pre>
using weeks = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;7&gt;, days::period&gt;&gt;;
</pre></blockquote>

<a name="years"></a><h3><code>years</code></h3>

<blockquote>
<p>
<code>years</code> is a <code>std::chrono::duration</code> with a tick period of 365.2425
days.  This definition accurately describes the length of the average year in the
Gregorian calendar.  <code>years</code> is the resultant type when subtracting two
<code>year</code> field-based time points.  <code>years</code> is not implicitly
convertible to <code>days</code> or <code>weeks</code> nor vice-versa.  However
<code>years</code> will implicitly convert to <code>months</code>.
</p>
<pre>
using years = std::chrono::duration
    &lt;int, std::ratio_multiply&lt;std::ratio&lt;146097, 400&gt;, days::period&gt;&gt;;
</pre></blockquote>

<a name="months"></a><h3><code>months</code></h3>

<blockquote>
<p>
<code>months</code> is a <code>std::chrono::duration</code> with a tick period of
<sup>1</sup>/<sub>12</sub> of a year.  This definition accurately describes the length of
the average month in the Gregorian calendar.  <code>months</code> is the resultant type
when subtracting two <code>month</code> field-based time points. <code>months</code> is
not implicitly convertible to <code>days</code> or <code>weeks</code> nor vice-versa. 
<code>months</code> will not implicitly convert to <code>years</code>.
</p>
<pre>
using months = std::chrono::duration
    &lt;int, std::ratio_divide&lt;years::period, std::ratio&lt;12&gt;&gt;&gt;;
</pre></blockquote>

<a name="day_point"></a><h3><code>day_point</code></h3>

<blockquote>
<p>
<code>day_point</code> is a <code>std::chrono::time_point</code> using
<code>std::chrono::system_clock</code> and <code>days</code>.  This makes
<code>day_point</code> interoperable with
<code>std::chrono::system_clock::time_point</code>.  It is simply a count of days since
the epoch of <code>std::chrono::system_clock</code> which in every implementation is
Jan. 1, 1970.  <code>day_point</code> is a serial-based time point with a resolution of
<code>days</code>.
</p>
<pre>
using day_point = std::chrono::time_point&lt;std::chrono::system_clock, days&gt;;
</pre>
</blockquote>

<a name="last_spec"></a><h3><code>last_spec</code></h3>

<blockquote>
<p>
<code>last_spec</code> is a <code>struct</code> that is <code>CopyConstructible</code>.
There exists a <code>constexpr</code> instance of <code>last_spec</code> named
<code>last</code>.  This is simply a tag type.  It is used to indicate the last day of
a month, or the last weekday of a month.
</p>
<pre>
constexpr struct last_spec {} last{};
</pre>
</blockquote>

<a name="day"></a><h3><code>day</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class day
{
    unsigned char d_;  // exposition only
public:
    explicit constexpr day(unsigned d) noexcept;

    day&amp; operator++() noexcept;
    day operator++(int) noexcept;
    day&amp; operator--() noexcept;
    day operator--(int) noexcept;

    day&amp; operator+=(const days&amp; d) noexcept;
    day&amp; operator-=(const days&amp; d) noexcept;

    constexpr explicit operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator!=(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&lt; (const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&gt; (const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&lt;=(const day&amp; x, const day&amp; y) noexcept;
constexpr bool operator&gt;=(const day&amp; x, const day&amp; y) noexcept;

constexpr day  operator+(const day&amp;  x, const days&amp; y) noexcept;
constexpr day  operator+(const days&amp; x, const day&amp;  y) noexcept;
constexpr day  operator-(const day&amp;  x, const days&amp; y) noexcept;
constexpr days operator-(const day&amp;  x, const day&amp;  y) noexcept;

constexpr day operator "" _d(unsigned long long d) noexcept;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const day&amp; d);
</pre>

<p><b>Overview</b></p>

<p>
<code>day</code> represents a day of a month.  It should only be representing values in
the range 1 to 31.  However it may hold values outside this range.  It can be constructed
with any <code>unsigned</code> value, which will be subsequently truncated to fit into
<code>day</code>'s internal storage.  <code>day</code> is equality and less-than
comparable, and participates in basic arithmetic with <code>days</code> representing the
quantity between any two <code>day</code>'s.  One can form a <code>day</code> literal with
<code>_d</code>.  And one can stream out a <code>day</code> for debugging purposes.
<code>day</code> has explicit conversions to and from <code>unsigned</code>.
</p>

<p><b>Specification</b></p>

<p>
<code>day</code> is a trivially copyable class type.</br>
<code>day</code> is a standard-layout class type.</br>
<code>day</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr day::day(unsigned d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>day</code> by constructing
<code>d_</code> with <code>d</code>.
</p>
</blockquote>

<pre>
day&amp; day::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++d_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
day day::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
day&amp; day::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--d_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
day day::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
day&amp; day::operator+=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
day&amp; day::operator-=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit day::operator unsigned() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>d_</code>.
</p>
</blockquote>

<pre>
constexpr bool day::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>1 <= d_ && d_ <= 31</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>static_cast&lt;unsigned&gt;(x) == static_cast&lt;unsigned&gt;(y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>static_cast&lt;unsigned&gt;(x) &lt; static_cast&lt;unsigned&gt;(y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const day&amp; x, const day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr day  operator+(const day&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>day{static_cast&lt;unsigned&gt;(x) + y.count()}</code>.
</p>
</blockquote>

<pre>
constexpr day  operator+(const days&amp; x, const day&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr day  operator-(const day&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr days operator-(const day&amp;  x, const day&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>days{static_cast&lt;days::rep&gt;(static_cast&lt;unsigned&gt;(x)
                                 - static_cast&lt;unsigned&gt;(y))}</code>.
</p>
</blockquote>

<pre>
constexpr day operator "" _d(unsigned long long d) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>day{static_cast&lt;unsigned&gt;(d)}</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const day&amp; d);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>d</code> into
<code>os</code>. For two objects of type <code>day</code> <code>x</code> and
<code>y</code>, if <code>x == y</code> the <code>day</code> objects shall have the same
text representation and if <code>x != y</code> the <code>day</code> shall have distinct
text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="month"></a><h3><code>month</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class month
{
    unsigned char m_;  // exposition only
public:
    explicit constexpr month(unsigned m) noexcept;

    month&amp; operator++() noexcept;
    month operator++(int) noexcept;
    month&amp; operator--() noexcept;
    month operator--(int) noexcept;

    month&amp; operator+=(const months&amp; m) noexcept;
    month&amp; operator-=(const months&amp; m) noexcept;

    constexpr explicit operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator!=(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&lt; (const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&gt; (const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&lt;=(const month&amp; x, const month&amp; y) noexcept;
constexpr bool operator&gt;=(const month&amp; x, const month&amp; y) noexcept;

constexpr month  operator+(const month&amp;  x, const months&amp; y) noexcept;
constexpr month  operator+(const months&amp; x,  const month&amp; y) noexcept;
constexpr month  operator-(const month&amp;  x, const months&amp; y) noexcept;
constexpr months operator-(const month&amp;  x,  const month&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month&amp; m);

constexpr month jan{1};
constexpr month feb{2};
constexpr month mar{3};
constexpr month apr{4};
constexpr month may{5};
constexpr month jun{6};
constexpr month jul{7};
constexpr month aug{8};
constexpr month sep{9};
constexpr month oct{10};
constexpr month nov{11};
constexpr month dec{12};
</pre>

<p><b>Overview</b></p>

<p>
<code>month</code> represents a month of a year.  It should only be representing values in
the range 1 to 12.  However it may hold values outside this range.  It can be constructed
with any <code>unsigned</code> value, which will be subsequently truncated to fit into
<code>month</code>'s internal storage.  <code>month</code> is equality and less-than
comparable, and participates in basic arithmetic with <code>months</code> representing the
quantity between any two <code>month</code>'s.   One can stream out a <code>month</code>
for debugging purposes. <code>month</code> has explicit conversions to and from
<code>unsigned</code>.  There are 12 <code>month</code> constants, one for each month of
the year.
</p>

<p><b>Specification</b></p>

<p>
<code>month</code> is a trivially copyable class type.</br>
<code>month</code> is a standard-layout class type.</br>
<code>month</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr month::month(unsigned m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month</code> by constructing
<code>m_</code> with <code>m</code>.
</p>
</blockquote>

<pre>
month&amp; month::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>m_ != 12</code>, <code>++m_</code>.  Otherwise sets
<code>m_</code> to 1.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
month month::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
month&amp; month::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>m_ != 1</code>, <code>--m_</code>.  Otherwise sets
<code>m_</code> to 12.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
month month::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
month&amp; month::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
month&amp; month::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit month::operator unsigned() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr bool month::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>1 <= m_ && m_ <= 12</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>static_cast&lt;unsigned&gt;(x) == static_cast&lt;unsigned&gt;(y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>static_cast&lt;unsigned&gt;(x) &lt; static_cast&lt;unsigned&gt;(y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const month&amp; x, const month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr month  operator+(const month&amp;  x, const months&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>x.ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>month</code> for which <code>ok() == true</code> and is found as
if by incrementing (or decrementing if <code>y &lt; months{0}</code>) <code>x</code>,
<code>y</code> times.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>y</code>.  That is, repeated
increments or decrements is not a valid implementation.
</p>
<p>
<i>Example:</i> <code>feb + months{11} == jan</code>.
</p>
</blockquote>

<pre>
constexpr month  operator+(const months&amp; x, const month&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr month  operator-(const month&amp;  x, const months&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr months operator-(const month&amp;  x, const month&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>x.ok() == true</code> and <code>y.ok() == true</code>.
</p>
<p>
<i>Returns:</i> A value of <code>months</code> in the range of <code>months{0}</code> to
<code>months{11}</code> inclusive.
</p>
<p>
<i>Remarks:</i> The returned value <code>m</code> shall satisfy the equality:
<code>y + m == x</code>.
</p>
<p>
<i>Example:</i> <code>jan - feb == months{11} </code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month&amp; m);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>m</code> into
<code>os</code>. For two objects of type <code>month</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>month</code> objects
shall have the same text representation and if <code>x.ok() &amp;&amp; x != y</code> the
<code>month</code> objects shall have distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="year"></a><h3><code>year</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class year
{
    short y_;  // exposition only
public:
    explicit constexpr year(int y) noexcept;

    year&amp; operator++() noexcept;
    year operator++(int) noexcept;
    year&amp; operator--() noexcept;
    year operator--(int) noexcept;

    year&amp; operator+=(const years&amp; y) noexcept;
    year&amp; operator-=(const years&amp; y) noexcept;

    constexpr bool is_leap() const noexcept;

    constexpr explicit operator int() const noexcept;
    constexpr bool ok() const noexcept;

    static constexpr year min() noexcept;
    static constexpr year max() noexcept;
};

constexpr bool operator==(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator!=(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&lt; (const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&gt; (const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&lt;=(const year&amp; x, const year&amp; y) noexcept;
constexpr bool operator&gt;=(const year&amp; x, const year&amp; y) noexcept;

constexpr year  operator+(const year&amp;  x, const years&amp; y) noexcept;
constexpr year  operator+(const years&amp; x, const year&amp;  y) noexcept;
constexpr year  operator-(const year&amp;  x, const years&amp; y) noexcept;
constexpr years operator-(const year&amp;  x, const year&amp;  y) noexcept;

constexpr year operator "" _y(unsigned long long y) noexcept;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year&amp; y);
</pre>

<p><b>Overview</b></p>

<p>
<code>year</code> represents a year in the Gregorian calendar.  It shall represent values
in the range -32768 to 32767 or a superset of this range.  It can be constructed with any
<code>int</code> value, which will be subsequently truncated to fit into
<code>year</code>'s internal storage.  <code>year</code> is equality and less-than
comparable, and participates in basic arithmetic with <code>years</code> representing the
quantity between any two <code>year</code>'s.  One can form a <code>year</code> literal
with <code>_y</code>.  And one can stream out a <code>year</code> for debugging purposes.
<code>year</code> has explicit conversions to and from <code>int</code>.
</p>

<p><b>Specification</b></p>

<p>
<code>year</code> is a trivially copyable class type.</br>
<code>year</code> is a standard-layout class type.</br>
<code>year</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr year::year(int y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year</code> by constructing
<code>y_</code> with <code>y</code>.
</p>
</blockquote>

<pre>
year&amp; year::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++y_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year year::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
year&amp; year::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--y_</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year year::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
year&amp; year::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year&amp; year::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr bool year::is_leap() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>true</code> if <code>*this</code> represents a leap year, else
returns <code>false</code>.
</p>
</blockquote>

<pre>
constexpr explicit year::operator int() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr bool year::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>true</code>.
</p>
</blockquote>

<pre>
static constexpr year year::min() noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>year</code> constructed with the minimum representable year
number. This year shall be less than or equal to <code>year{-32768}</code>.
</p>
</blockquote>

<pre>
static constexpr year year::max() noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>year</code> constructed with the maximum representable year
number. This year shall be greater than or equal to <code>year{32767}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>static_cast&lt;int&gt;(x) == static_cast&lt;int&gt;(y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>static_cast&lt;int&gt;(x) &lt; static_cast&lt;int&gt;(y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year&amp; x, const year&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year  operator+(const year&amp;  x, const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{static_cast&lt;int&gt;(x) + y.count()}</code>.
</p>
</blockquote>

<pre>
constexpr year  operator+(const years&amp; x, const year&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr year  operator-(const year&amp;  x, const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr years operator-(const year&amp;  x, const year&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>years{static_cast&lt;int&gt;(x) - static_cast&lt;int&gt;(y)}</code>.
</p>
</blockquote>

<pre>
constexpr year operator "" _y(unsigned long long y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>year{static_cast&lt;int&gt;(y)}</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year&amp; y);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>y</code> into
<code>os</code>. For two objects of type <code>year</code> <code>x</code> and
<code>y</code>, if <code>x == y</code> the <code>year</code> objects shall have the same
text representation and if <code>x != y</code> the <code>year</code> shall have distinct
text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="weekday"></a><h3><code>weekday</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class weekday
{
    unsigned char wd_;  // exposition only
public:
    explicit constexpr weekday(unsigned wd) noexcept;
    constexpr weekday(const day_point&amp; dp) noexcept;

    weekday&amp; operator++() noexcept;
    weekday operator++(int) noexcept;
    weekday&amp; operator--() noexcept;
    weekday operator--(int) noexcept;

    weekday&amp; operator+=(const days&amp; d) noexcept;
    weekday&amp; operator-=(const days&amp; d) noexcept;

    constexpr explicit operator unsigned() const noexcept;
    constexpr bool ok() const noexcept;
    constexpr weekday_indexed operator[](unsigned index) const noexcept;
    constexpr weekday_last operator[](last_spec) const noexcept;
};

constexpr bool operator==(const weekday&amp; x, const weekday&amp; y) noexcept;
constexpr bool operator!=(const weekday&amp; x, const weekday&amp; y) noexcept;

constexpr weekday operator+(const weekday&amp; x, const days&amp;    y) noexcept;
constexpr weekday operator+(const days&amp;    x, const weekday&amp; y) noexcept;
constexpr weekday operator-(const weekday&amp; x, const days&amp;    y) noexcept;
constexpr days    operator-(const weekday&amp; x, const weekday&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weekday&amp; wd);

constexpr weekday sun{0};
constexpr weekday mon{1};
constexpr weekday tue{2};
constexpr weekday wed{3};
constexpr weekday thu{4};
constexpr weekday fri{5};
constexpr weekday sat{6};
</pre>

<p><b>Overview</b></p>

<p>
<code>weekday</code> represents a day of the week in the Gregorian calendar.  It should
only be representing values in the range 0 to 6, corresponding to Sunday thru Saturday. 
However it may hold values outside this range.  It can be constructed with any
<code>unsigned</code> value, which will be subsequently truncated to fit into
<code>weekday</code>'s internal storage.  <code>weekday</code> is equality comparable.
<code>weekday</code> is not less-than comparable because there is no universal consensus
on which day is the first day of the week.  This design chooses the encoding of 0 to 6 to
represent Sunday thru Saturday only because this is consistent with existing C and C++
practice.  However  <code>weekday</code>'s comparison and arithmetic operations treat the
days of the week as a circular range, with no beginning and no end.   One can stream out a
<code>weekday</code> for debugging purposes. <code>weekday</code> has explicit conversions
to and from <code>unsigned</code>.  There are 7 <code>weekday</code> constants, one for each
day of the week.
</p>

<p>
A <code>weekday</code> can be implicitly constructed from a <code>day_point</code>. This
is the computation that discovers the day of the week of an arbitrary date.
</p>

<p>
A <code>weekday</code> can be indexed with either <code>unsigned</code> or
<code>last</code>. This produces new types which represent the first, second, third,
fourth, fifth or last weekdays of a month.
</p>

<p><b>Specification</b></p>

<p>
<code>weekday</code> is a trivially copyable class type.</br>
<code>weekday</code> is a standard-layout class type.</br>
<code>weekday</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr weekday::weekday(unsigned wd) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday</code> by constructing
<code>wd_</code> with <code>wd</code>.
</p>
</blockquote>

<pre>
constexpr weekday(const day_point&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday</code> by computing what day
of the week corresponds to the <code>day_point dp</code>, and representing that day of
the week in <code>wd_</code>.
</p>
<p>
<i>Example:</i> If <code>dp</code> represents 1970-01-01, the constructed
<code>weekday</code> shall represent Thursday by storing 4 in <code>wd_</code>.
</p>
</blockquote>

<pre>
weekday&amp; weekday::operator++() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>wd_ != 6</code>, <code>++wd_</code>.  Otherwise sets
<code>wd_</code> to 0.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weekday weekday::operator++(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>++(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
weekday&amp; weekday::operator--() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>wd_ != 0</code>, <code>--wd_</code>.  Otherwise sets
<code>wd_</code> to 6.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weekday weekday::operator--(int) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>--(*this)</code>.
</p>
<p>
<i>Returns:</i> A copy of <code>*this</code> as it existed on entry to this member
function.
</p>
</blockquote>

<pre>
weekday&amp; weekday::operator+=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
weekday&amp; weekday::operator-=(const days&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - d</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr explicit weekday::operator unsigned() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr bool weekday::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_ <= 6</code>.
</p>
</blockquote>

<pre>
constexpr weekday_indexed weekday::operator[](unsigned index) const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>{*this, index}</code>.
</p>
</blockquote>

<pre>
constexpr weekday_last weekday::operator[](last_spec) const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>weekday_last{*this}</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const weekday&amp; x, const weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>static_cast&lt;unsigned&gt;(x) == static_cast&lt;unsigned&gt;(y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const weekday&amp; x, const weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator+(const weekday&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>x.ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>weekday</code> for which <code>ok() == true</code> and is found as
if by incrementing (or decrementing if <code>y &lt; days{0}</code>) <code>x</code>,
<code>y</code> times.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>y</code>.  That is, repeated
increments or decrements is not a valid implementation.
</p>
<p>
<i>Example:</i> <code>mon + days{6} == sun</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator+(const days&amp; x, const weekday&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y + x</code>.
</p>
</blockquote>

<pre>
constexpr weekday  operator-(const weekday&amp;  x, const days&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x + -y</code>.
</p>
</blockquote>

<pre>
constexpr days operator-(const weekday&amp;  x, const weekday&amp;  y) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>x.ok() == true</code> and <code>y.ok() == true</code>.
</p>
<p>
<i>Returns:</i> A value of <code>days</code> in the range of <code>days{0}</code> to
<code>days{6}</code> inclusive.
</p>
<p>
<i>Remarks:</i> The returned value <code>d</code> shall satisfy the equality:
<code>y + d == x</code>.
</p>
<p>
<i>Example:</i> <code>sun - mon == days{6}</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weekday&amp; wd);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>wd</code> into
<code>os</code>. For two objects of type <code>weekday</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>weekday</code> objects
shall have the same text representation and if <code>x.ok() &amp;&amp; x != y</code> the
<code>weekday</code> objects shall have distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="weekday_indexed"></a><h3><code>weekday_indexed</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class weekday_indexed
{
    date::weekday    wd_;     // exposition only
    unsigned char    index_;  // exposition only

public:
    constexpr weekday_indexed(const date::weekday&amp; wd, unsigned index) noexcept;

    constexpr date::weekday weekday() const noexcept;
    constexpr unsigned index() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;
constexpr bool operator!=(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weekday_indexed&amp; wdi);
</pre>

<p><b>Overview</b></p>

<p>
<code>weekday_indexed</code> represents a <code>weekday</code> and a small index in the
range 1 to 5. This class is used to represent the first, second, third, fourth or fifth
weekday of a month.  It is most easily constructed by indexing a <code>weekday</code>.
</p>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
constexpr auto wdi = sun[2];  // wdi is the second Sunday of an as yet unspecified month
static_assert(wdi.weekday() == sun);
static_assert(wdi.index() == 2);
</pre></blockquote>

<p>
&mdash; <i>end example:</i>]
</p>

<p><b>Specification</b></p>

<p>
<code>weekday_indexed</code> is a trivially copyable class type.</br>
<code>weekday_indexed</code> is a standard-layout class type.</br>
<code>weekday_indexed</code> is a literal class type.</br>
</p>

<pre>
constexpr weekday_indexed::weekday_indexed(const date::weekday&amp; wd, unsigned index) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday_indexed</code> by constructing
<code>wd_</code> with <code>wd</code> and <code>index_</code> with <code>index</code>.
</p>
</blockquote>

<pre>
constexpr weekday weekday_indexed::weekday() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr unsigned weekday_indexed::index() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>index_</code>.
</p>
</blockquote>

<pre>
constexpr bool weekday_indexed::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_.ok() &amp;&amp; 1 &lt;= index_ && index_ &lt;= 5</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.weekday() == y.weekday() && x.index() == y.index()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const weekday_indexed&amp; x, const weekday_indexed&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weekday_indexed&amp; wdi);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>wdi</code> into
<code>os</code>. For two objects of type <code>weekday_indexed</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>weekday_indexed</code>
objects shall have the same text representation and if <code>x.ok() &amp;&amp; x != y</code>
the <code>weekday_indexed</code> objects shall have distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="weekday_last"></a><h3><code>weekday_last</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class weekday_last
{
    date::weekday wd_;  // exposition only

public:
    explicit constexpr weekday_last(const date::weekday&amp; wd) noexcept;

    constexpr date::weekday weekday() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;
constexpr bool operator!=(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weekday_last&amp; wdl);
</pre>

<p><b>Overview</b></p>

<p>
<code>weekday_last</code> represents the last <code>weekday</code> of a month. 
It is most easily constructed by indexing a <code>weekday</code> with <code>last</code>.
</p>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
constexpr auto wdl = sun[last];  // wdl is the last Sunday of an as yet unspecified month
static_assert(wdl.weekday() == sun);
</pre></blockquote>

<p>
&mdash; <i>end example:</i>]
</p>

<p><b>Specification</b></p>

<p>
<code>weekday_last</code> is a trivially copyable class type.</br>
<code>weekday_last</code> is a standard-layout class type.</br>
<code>weekday_last</code> is a literal class type.</br>
</p>

<pre>
explicit constexpr weekday_last::weekday_last(const date::weekday&amp; wd) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>weekday_last</code> by constructing
<code>wd_</code> with <code>wd</code>.
</p>
</blockquote>

<pre>
constexpr weekday weekday_last::weekday() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr bool weekday_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.weekday() == y.weekday()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const weekday_last&amp; x, const weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const weekday_last&amp; wdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>wdl</code> into
<code>os</code>. For two objects of type <code>weekday_last</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>weekday_last</code>
objects shall have the same text representation and if <code>x.ok() &amp;&amp; x != y</code>
the <code>weekday_last</code> objects shall have distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="month_day"></a><h3><code>month_day</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class month_day
{
    date::month m_;  // exposition only
    date::day   d_;  // exposition only

public:
    constexpr month_day(const date::month&amp; m, const date::day&amp; d) noexcept;

    constexpr date::month month() const noexcept;
    constexpr date::day day() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator!=(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&lt; (const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&gt; (const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&lt;=(const month_day&amp; x, const month_day&amp; y) noexcept;
constexpr bool operator&gt;=(const month_day&amp; x, const month_day&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month_day&amp; md);
</pre>

<p><b>Overview</b></p>

<p>
<code>month_day</code> represents a specific <code>day</code> of a specific
<code>month</code>, but with an unspecified <code>year</code>.  One can observe the
different components.  One can assign a new value.  <code>month_day</code> is equality
comparable and less-than comparable.  One can stream out a <code>month_day</code> for
debugging purposes.
</p>

<p><b>Specification</b></p>

<p>
<code>month_day</code> is a trivially copyable class type.</br>
<code>month_day</code> is a standard-layout class type.</br>
<code>month_day</code> is a literal class type.</br>
</p>

<pre>
constexpr month_day::month_day(const date::month&amp; m, const date::day&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month_day</code> by constructing
<code>m_</code> with <code>m</code>, and <code>d_</code> with <code>d</code>.
</p>
</blockquote>

<pre>
constexpr month month_day::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr day month_day::day() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>d_</code>.
</p>
</blockquote>

<pre>
constexpr bool month_day::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>true</code> if <code>m_.ok()</code> is true, and if
<code>1_d &lt;= d_</code>, and if <code>d_ &lt;=</code> the number of days in month
<code>m_</code>.  For <code>m_ == feb</code> the number of days is considered to be 29.
Otherwise returns <code>false</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() == y.month() &amp;&amp; x.day() == y.day()</code>
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>x.month() &lt; y.month()</code> returns <code>true</code>.  Else
if <code>x.month() &gt; y.month()</code> returns <code>false</code>. Else returns
<code>x.day() &lt; y.day()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const month_day&amp; x, const month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month_day&amp; md);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>md</code> into
<code>os</code>. For two objects of type <code>month_day</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>month_day</code>
objects shall have the same text representation and if
<code>x.ok() &amp;&amp; x != y</code> the <code>month_day</code> objects shall have
distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="month_day_last"></a><h3><code>month_day_last</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class month_day_last
{
    date::month m_;  // exposition only

public:
    constexpr explicit month_day_last(const date::month&amp; m) noexcept;

    constexpr date::month month() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator!=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&lt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&gt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&lt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
constexpr bool operator&gt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month_day_last&amp; mdl);
</pre>

<p><b>Overview</b></p>

<p>
<code>month_day_last</code> represents the last <code>day</code> of a <code>month</code>.
It is most easily constructed using the expression <code>m/last</code> or
<code>last/m</code>, where <code>m</code> is an expression with type <code>month</code>.
</p>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
constexpr auto mdl = feb/last;  // mdl is the last day of February of an as yet unspecified year
static_assert(mdl.month() == feb);
</pre></blockquote>

<p>
&mdash; <i>end example:</i>]
</p>

<p><b>Specification</b></p>

<p>
<code>month_day_last</code> is a trivially copyable class type.</br>
<code>month_day_last</code> is a standard-layout class type.</br>
<code>month_day_last</code> is a literal class type.</br>
</p>

<pre>
constexpr explicit month_day_last::month_day_last(const date::month&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month_day_last</code> by constructing
<code>m_</code> with <code>m</code>.
</p>
</blockquote>

<pre>
constexpr month month_day_last::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr bool month_day_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() == y.month()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() &lt; y.month()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const month_day_last&amp; x, const month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month_day_last&amp; mdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>mdl</code> into
<code>os</code>. For two objects of type <code>month_day_last</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>month_day_last</code>
objects shall have the same text representation and if
<code>x.ok() &amp;&amp; x != y</code> the <code>month_day_last</code> objects shall have
distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="month_weekday"></a><h3><code>month_weekday</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class month_weekday
{
    date::month           m_;    // exposition only
    date::weekday_indexed wdi_;  // exposition only
public:
    constexpr month_weekday(const date::month&amp; m, const date::weekday_indexed&amp; wdi) noexcept;

    constexpr date::month month() const noexcept;
    constexpr date::weekday_indexed weekday_indexed() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;
constexpr bool operator!=(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month_weekday&amp; mwd);
</pre>

<p><b>Overview</b></p>

<p>
<code>month_weekday</code> represents the nth <code>weekday</code> of a
<code>month</code>, of an as yet unspecified <code>year</code>.  To do this the
<code>month_weekday</code> stores a <code>month</code> and a <code>weekday_indexed</code>.
</p>

<p><b>Specification</b></p>

<p>
<code>month_weekday</code> is a trivially copyable class type.</br>
<code>month_weekday</code> is a standard-layout class type.</br>
<code>month_weekday</code> is a literal class type.</br>
</p>

<pre>
constexpr month_weekday::month_weekday(const date::month&amp; m, const date::weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month_weekday</code> by constructing
<code>m_</code> with <code>m</code>, and <code>wdi_</code> with <code>wdi</code>.
</p>
</blockquote>

<pre>
constexpr month month_weekday::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr weekday_indexed month_weekday::weekday_indexed() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdi_</code>.
</p>
</blockquote>

<pre>
constexpr bool month_weekday::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_.ok() &amp;&amp; wdi_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() == y.month() &amp;&amp; x.weekday_indexed() == y.weekday_indexed()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month_weekday&amp; x, const month_weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month_weekday&amp; mwd);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>mwd</code> into
<code>os</code>. For two objects of type <code>month_weekday</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>month_weekday</code>
objects shall have the same text representation and if
<code>x.ok() &amp;&amp; x != y</code> the <code>month_weekday</code> objects shall have
distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="month_weekday_last"></a><h3><code>month_weekday_last</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class month_weekday_last
{
    date::month   m_;    // exposition only
    date::weekday wd_;   // exposition only
public:
    constexpr month_weekday_last(const date::month&amp; m, const date::weekday&amp; wd) noexcept;

    constexpr date::month month() const noexcept;
    constexpr date::weekday weekday() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;
constexpr bool operator!=(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month_weekday_last&amp; mwdl);
</pre>

<p><b>Overview</b></p>

<p>
<code>month_weekday_last</code> represents the last <code>weekday</code> of a
<code>month</code>, of an as yet unspecified <code>year</code>.  To do this the
<code>month_weekday_last</code> stores a <code>month</code> and a <code>weekday</code>.
</p>

<p><b>Specification</b></p>

<p>
<code>month_weekday_last</code> is a trivially copyable class type.</br>
<code>month_weekday_last</code> is a standard-layout class type.</br>
<code>month_weekday_last</code> is a literal class type.</br>
</p>

<pre>
constexpr month_weekday_last::month_weekday_last(const date::month&amp; m, const date::weekday&amp; wd) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>month_weekday_last</code> by constructing
<code>m_</code> with <code>m</code>, and <code>wd_</code> with <code>wd</code>.
</p>
</blockquote>

<pre>
constexpr month month_weekday_last::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr weekday month_weekday_last::weekday() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wd_</code>.
</p>
</blockquote>

<pre>
constexpr bool month_weekday_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_.ok() &amp;&amp; wd_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.month() == y.month() &amp;&amp; x.weekday() == y.weekday()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const month_weekday_last&amp; x, const month_weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const month_weekday_last&amp; mwdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>mwdl</code> into
<code>os</code>. For two objects of type <code>month_weekday_last</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>month_weekday_last</code>
objects shall have the same text representation and if
<code>x.ok() &amp;&amp; x != y</code> the <code>month_weekday_last</code> objects shall have
distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="year_month"></a><h3><code>year_month</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class year_month
{
    date::year  y_;  // exposition only
    date::month m_;  // exposition only

public:
    constexpr year_month(const date::year&amp; y, const date::month&amp; m) noexcept;

    constexpr date::year year() const noexcept;
    constexpr date::month month() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator!=(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&lt; (const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&gt; (const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr bool operator&gt;=(const year_month&amp; x, const year_month&amp; y) noexcept;

constexpr year_month operator+(const year_month&amp; ym, const months&amp; dm) noexcept;
constexpr year_month operator+(const months&amp; dm, const year_month&amp; ym) noexcept;
constexpr year_month operator-(const year_month&amp; ym, const months&amp; dm) noexcept;
constexpr months operator-(const year_month&amp; x, const year_month&amp; y) noexcept;
constexpr year_month operator+(const year_month&amp; ym, const years&amp; dy) noexcept;
constexpr year_month operator+(const years&amp; dy, const year_month&amp; ym) noexcept;
constexpr year_month operator-(const year_month&amp; ym, const years&amp; dy) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month&amp; ym);
</pre>

<p><b>Overview</b></p>

<p>
<code>year_month</code> represents a specific <code>month</code> of a specific
<code>year</code>, but with an unspecified <code>day</code>. <code>year_month</code> is a
field-based time point with a resolution of <code>months</code>. One can observe the
different components.  One can assign a new value.  <code>year_month</code> is equality
comparable and less-than comparable.  One can stream out a <code>year_month</code> for
debugging purposes.
</p>

<p><b>Specification</b></p>

<p>
<code>year_month</code> is a trivially copyable class type.</br>
<code>year_month</code> is a standard-layout class type.</br>
<code>year_month</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month::year_month(const date::year&amp; y, const date::month&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month</code> by constructing
<code>y_</code> with <code>y</code>, and <code>m_</code> with <code>m</code>.
</p>
</blockquote>

<pre>
constexpr year year_month::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_.ok() &amp;&amp; m_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month()</code>
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>x.year() &lt; y.year()</code> returns <code>true</code>.  Else
if <code>x.year() &gt; y.year()</code> returns <code>false</code>. Else returns
<code>x.month() &lt; y.month()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator+(const year_month& ym, const months& dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ym.month().ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> A <code>year_month</code> value <code>z</code> such that
<code>z - ym == dm</code>.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator+(const months& dm, const year_month& ym) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator-(const year_month& ym, const months& dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + -dm</code>.
</p>
</blockquote>

<pre>
constexpr months operator-(const year_month&amp; x, const year_month&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of <code>months</code> one must add to <code>y</code> to get
<code>x</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator+(const year_month& ym, const years& dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>(ym.year() + dy) / ym.month()</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator+(const years& dy, const year_month& ym) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_month operator-(const year_month& ym, const years& dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ym + -dy</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month&amp; ym);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>ym</code> into
<code>os</code>. For two objects of type <code>year_month</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>year_month</code>
objects shall have the same text representation and if
<code>x.ok() &amp;&amp; x != y</code> the <code>year_month</code> objects shall have
distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="year_month_day"></a><h3><code>year_month_day</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class year_month_day
{
    date::year  y_;  // exposition only
    date::month m_;  // exposition only
    date::day   d_;  // exposition only

public:
    constexpr year_month_day(const date::year&amp; y, const date::month&amp; m, const date::day&amp; d) noexcept;
    constexpr year_month_day(const year_month_day_last&amp; ymdl) noexcept;
    constexpr year_month_day(const day_point&amp; dp) noexcept;

    year_month_day&amp; operator+=(const months&amp; m) noexcept;
    year_month_day&amp; operator-=(const months&amp; m) noexcept;
    year_month_day&amp; operator+=(const years&amp; y) noexcept;
    year_month_day&amp; operator-=(const years&amp; y) noexcept;

    constexpr date::year year() const noexcept;
    constexpr date::month month() const noexcept;
    constexpr date::day day() const noexcept;
    constexpr operator day_point() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator!=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&lt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&lt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;

constexpr year_month_day operator+(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
constexpr year_month_day operator+(const months&amp; dm, const year_month_day&amp; ymd) noexcept;
constexpr year_month_day operator+(const year_month_day&amp; ymd, const years&amp; dy) noexcept;
constexpr year_month_day operator+(const years&amp; dy, const year_month_day&amp; ymd) noexcept;
constexpr year_month_day operator-(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
constexpr year_month_day operator-(const year_month_day&amp; ymd, const years&amp; dy) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month_day&amp; ymd);
</pre>

<p><b>Overview</b></p>

<p>
<code>year_month_day</code> represents a specific <code>year</code>, <code>month</code>,
and <code>day</code>.  <code>year_month_day</code> is a field-based time point with a
resolution of <code>days</code>.  One can observe each field.  <code>year_month_day</code>
supports <code>years</code> and <code>months</code> oriented arithmetic, but not
<code>days</code> oriented arithmetic.  For the latter, there is a conversion to
<code>day_point</code> which efficiently supports <code>days</code> oriented arithmetic. 
There is a also a conversion <i>from</i> <code>day_point</code>.
<code>year_month_day</code> is equality and less-than comparable.
</p>

<p><b>Specification</b></p>

<p>
<code>year_month_day</code> is a trivially copyable class type.</br>
<code>year_month_day</code> is a standard-layout class type.</br>
<code>year_month_day</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month_day::year_month_day(const date::year&amp; y, const date::month&amp; m, const date::day&amp; d) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day</code> by constructing
<code>y_</code> with <code>y</code>, <code>m_</code> with <code>m</code>, and,
<code>d_</code> with <code>d</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day::year_month_day(const year_month_day_last&amp; ymdl) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day</code> by constructing
<code>y_</code> with <code>ymdl.year()</code>, <code>m_</code> with
<code>ymdl.month()</code>, and, <code>d_</code> with <code>ymdl.day()</code>.
</p>
<p>
<i>Note:</i> This conversion from <code>year_month_day_last</code> to
<code>year_month_day</code> is more efficient than converting a
<code>year_month_day_last</code> to a <code>day_point</code>, and then converting that
<code>day_point</code> to a <code>year_month_day</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day::year_month_day(const day_point&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day</code> which corresponds
to the date represented by <code>dp</code>.
</p>
<p>
<i>Remarks:</i> For any value of <code>year_month_day</code>, <code>ymd</code>, for which
<code>ymd.ok()</code> is <code>true</code>, this equality will also be <code>true</code>:
<code>ymd == year_month_day(static_cast&lt;day_point&gt;(ymd))</code>.
</p>
</blockquote>

<pre>
year_month_day&amp; year_month_day::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_day&amp; year_month_day::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_day&amp; year_month_day::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_day&amp; year_month_day::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year_month_day::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month_day::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr day year_month_day::day() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>d_</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day::operator day_point() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>day_point</code> which represents the date represented by
<code>*this</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month_day::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>y_.ok()</code> is <code>true</code>, and <code>m_.ok()</code> is
<code>true</code>, and <code>d_</code> is in the range
<code>[1_d, (y_/m_/last).day()]</code>, then returns <code>true</code>, else returns
<code>false</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month() &amp;&amp; x.day() == y.day()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>x.year() &lt; y.year()</code>, returns <code>true</code>.  Else
if <code>x.year() &gt; y.year()</code> returns <code>false</code>.
Else if <code>x.month() &lt; y.month()</code>, returns <code>true</code>.
Else if <code>x.month() &gt; y.month()</code>, returns <code>false</code>.
Else returns <code>x.day() &lt; y.day()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year_month_day&amp; x, const year_month_day&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator+(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ymd.month().ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> <code>(ymd.year() / ymd.month() + dm) / ymd.day()</code>.
</p>
<p>
<i>Remarks:</i> If <code>ymd.day()</code> is in the range <code>[1_d, 28_d]</code>,
the resultant <code>year_month_day</code> is guaranteed to return <code>true</code> from
<code>ok()</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator+(const months&amp; dm, const year_month_day&amp; ymd) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymd + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator-(const year_month_day&amp; ymd, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymd + (-dm)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator+(const year_month_day&amp; ymd, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>(ymd.year() + dy) / ymd.month() / ymd.day()</code>.
</p>
<p>
<i>Remarks:</i> If <code>ymd.month()</code> is <code>feb</code> and <code>ymd.day()</code>
is not in the range <code>[1_d, 28_d]</code>, the resultant <code>year_month_day</code> is
not guaranteed to return <code>true</code> from <code>ok()</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator+(const years&amp; dy, const year_month_day&amp; ymd) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymd + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day operator-(const year_month_day&amp; ymd, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymd + (-dy)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month_day&amp; ymd);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>ymd</code> into
<code>os</code>. For two objects of type <code>year_month_day</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>year_month_day</code> objects
shall have the same text representation and if <code>x.ok() &amp;&amp; x != y</code> the
<code>year_month_day</code> objects shall have distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="year_month_day_last"></a><h3><code>year_month_day_last</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class year_month_day_last
{
    date::year  y_;  // exposition only
    date::month m_;  // exposition only

public:
    constexpr year_month_day_last(const date::year&amp; y, const date::month&amp; m) noexcept;

    year_month_day_last&amp; operator+=(const months&amp; m) noexcept;
    year_month_day_last&amp; operator-=(const months&amp; m) noexcept;
    year_month_day_last&amp; operator+=(const years&amp; y) noexcept;
    year_month_day_last&amp; operator-=(const years&amp; y) noexcept;

    constexpr date::year year() const noexcept;
    constexpr date::month month() const noexcept;
    constexpr date::day day() const noexcept;
    constexpr operator day_point() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator!=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&lt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&gt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&lt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
constexpr bool operator&gt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;

constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
constexpr year_month_day_last operator+(const months&amp; dm, const year_month_day_last&amp; ymdl) noexcept;
constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;
constexpr year_month_day_last operator+(const years&amp; dy, const year_month_day_last&amp; ymdl) noexcept;
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month_day_last&amp; ymdl);
</pre>

<p><b>Overview</b></p>

<p>
<code>year_month_day_last</code> represents a specific <code>year</code>,
<code>month</code>, and the last <code>day</code> of the <code>month</code>.
<code>year_month_day_last</code> is a field-based time point with a resolution of
<code>days</code>, except that it is restricted to pointing to the last day of a year and
month.  One can observe each field.  The <code>day</code> field is computed on demand.
<code>year_month_day_last</code> supports <code>years</code> and <code>months</code>
oriented arithmetic, but not <code>days</code> oriented arithmetic. For the latter, there
is a conversion to <code>day_point</code> which efficiently supports <code>days</code>
oriented arithmetic.  <code>year_month_day_last</code> is equality and less-than
comparable.
</p>

<p><b>Specification</b></p>

<p>
<code>year_month_day_last</code> is a trivially copyable class type.</br>
<code>year_month_day_last</code> is a standard-layout class type.</br>
<code>year_month_day_last</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month_day_last::year_month_day_last(const date::year&amp; y, const date::month&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_day_last</code> by
constructing <code>y_</code> with <code>y</code> and <code>m_</code> with <code>m</code>.
</p>
</blockquote>

<pre>
year_month_day_last&amp; year_month_day_last::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_day_last&amp; year_month_day_last::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_day_last&amp; year_month_day_last::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_day_last&amp; year_month_day_last::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year_month_day_last::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month_day_last::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr day year_month_day_last::day() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> A <code>day</code> representing the last day of the <code>year</code>,
<code>month</code> pair represented by <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last::operator day_point() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>day_point</code> which represents the date represented by
<code>*this</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month_day_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_.ok() &amp;&amp; m_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>x.year() &lt; y.year()</code>, returns <code>true</code>.  Else
if <code>x.year() &gt; y.year()</code> returns <code>false</code>.
Else returns <code>x.month() &lt; y.month()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt; (const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y &lt; x</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&lt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(y &lt; x)</code>.
</p>
</blockquote>

<pre>
constexpr bool operator&gt;=(const year_month_day_last&amp; x, const year_month_day_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x &lt; y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ymdl.ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> <code>(ymdl.year() / ymdl.month() + dm) / last</code>.
</p>
<p>
<i>Postconditions:</i> The resultant <code>year_month_day_last</code> will return
<code>true</code> from <code>ok()</code>.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator+(const months&amp; dm, const year_month_day_last&amp; ymdl) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymdl + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymdl + (-dm)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator+(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>{ymdl.year()+dy, ymdl.month()}</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator+(const years&amp; dy, const year_month_day_last&amp; ymdl) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymdl + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_month_day_last operator-(const year_month_day_last&amp; ymdl, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymdl + (-dy)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month_day_last&amp; ymdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>ymdl</code> into
<code>os</code>. For two objects of type <code>year_month_day_last</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>year_month_day_last</code> objects
shall have the same text representation and if <code>x.ok() &amp;&amp; x != y</code> the
<code>year_month_day_last</code> objects shall have distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="year_month_weekday"></a><h3><code>year_month_weekday</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class year_month_weekday
{
    date::year            y_;    // exposition only
    date::month           m_;    // exposition only
    date::weekday_indexed wdi_;  // exposition only

public:
    constexpr year_month_weekday(const date::year&amp; y, const date::month&amp; m,
                                 const date::weekday_indexed&amp; wdi) noexcept;
    constexpr year_month_weekday(const day_point&amp; dp) noexcept;

    year_month_weekday&amp; operator+=(const months&amp; m) noexcept;
    year_month_weekday&amp; operator-=(const months&amp; m) noexcept;
    year_month_weekday&amp; operator+=(const years&amp; y) noexcept;
    year_month_weekday&amp; operator-=(const years&amp; y) noexcept;

    constexpr date::year year() const noexcept;
    constexpr date::month month() const noexcept;
    constexpr date::weekday_indexed weekday_indexed() const noexcept;
    constexpr operator day_point() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr bool operator==(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;
constexpr bool operator!=(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;

constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
constexpr year_month_weekday operator+(const months&amp; dm, const year_month_weekday&amp; ymwd) noexcept;
constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;
constexpr year_month_weekday operator+(const years&amp; dy, const year_month_weekday&amp; ymwd) noexcept;
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month_weekday&amp; ymwdi);
</pre>

<p><b>Overview</b></p>

<p>
<code>year_month_weekday</code> represents a specific <code>year</code>,
<code>month</code>, and nth <code>weekday</code> of the <code>month</code>. 
<code>year_month_weekday</code> is a field-based time point with a resolution of
<code>days</code>.  One can observe each field. <code>year_month_weekday</code> supports
<code>years</code> and <code>months</code> oriented arithmetic, but not <code>days</code>
oriented arithmetic. For the latter, there is a conversion to <code>day_point</code> which
efficiently supports <code>days</code> oriented arithmetic. 
<code>year_month_weekday</code> is equality comparable.
</p>

<p><b>Specification</b></p>

<p>
<code>year_month_weekday</code> is a trivially copyable class type.</br>
<code>year_month_weekday</code> is a standard-layout class type.</br>
<code>year_month_weekday</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month_weekday::year_month_weekday(const date::year&amp; y, const date::month&amp; m,
                                                 const date::weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_weekday</code> by
constructing <code>y_</code> with <code>y</code>, <code>m_</code> with <code>m</code>,
and <code>wdi_</code> with <code>wdi</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday(const day_point&amp; dp) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_weekday</code> which
corresponds to the date represented by <code>dp</code>.
</p>
<p>
<i>Remarks:</i> For any value of <code>year_month_weekday</code>, <code>ymdl</code>, for
which <code>ymdl.ok()</code> is <code>true</code>, this equality will also be
<code>true</code>: <code>ymdl == year_month_weekday(static_cast&lt;day_point&gt;(ymdl))</code>.
</p>
</blockquote>

<pre>
year_month_weekday&amp; year_month_weekday::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_weekday&amp; year_month_weekday::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_weekday&amp; year_month_weekday::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_weekday&amp; year_month_weekday::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year_month_weekday::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month_weekday::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr weekday_indexed year_month_weekday::weekday_indexed() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdi_</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday::operator day_point() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>day_point</code> which represents the date represented by
<code>*this</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month_weekday::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>y_.ok()</code> or <code>m_.ok()</code> or <code>wdi_.ok()</code>
returns <code>false</code>, returns <code>false</code>.  Else if <code>*this</code>
represents a valid date, returns <code>true</code>, else returns <code>false</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month() &amp;&amp; x.weekday_indexed() == y.weekday_indexed()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month_weekday&amp; x, const year_month_weekday&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ymwd.ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> <code>(ymwd.year() / ymwd.month() + dm) / ymwd.weekday_indexed()</code>.
</p>
<p>
<i>Postconditions:</i> The resultant <code>year_month_weekday</code> will return
<code>true</code> from <code>ok()</code>.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator+(const months&amp; dm, const year_month_weekday&amp; ymwd) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwd + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwd + (-dm)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator+(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>{ymwd.year()+dy, ymwd.month(), ymwd.weekday_indexed()}</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator+(const years&amp; dy, const year_month_weekday&amp; ymwd) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwd + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday operator-(const year_month_weekday&amp; ymwd, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwd + (-dm)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month_weekday&amp; ymwd);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>ymwd</code> into
<code>os</code>. For two objects of type <code>year_month_weekday</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>year_month_weekday</code> objects
shall have the same text representation and if <code>x.ok() &amp;&amp; x != y</code> the
<code>year_month_weekday</code> objects shall have distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<a name="year_month_weekday_last"></a><h3><code>year_month_weekday_last</code></h3>

<blockquote>
<p><b>Synopsis</b></p>

<pre>
class year_month_weekday_last
{
    date::year         y_;    // exposition only
    date::month        m_;    // exposition only
    date::weekday_last wdl_;  // exposition only

public:
    constexpr year_month_weekday_last(const date::year&amp; y, const date::month&amp; m,
                                      const date::weekday_last&amp; wdl) noexcept;

    year_month_weekday_last&amp; operator+=(const months&amp; m) noexcept;
    year_month_weekday_last&amp; operator-=(const months&amp; m) noexcept;
    year_month_weekday_last&amp; operator+=(const years&amp; y) noexcept;
    year_month_weekday_last&amp; operator-=(const years&amp; y) noexcept;

    constexpr date::year year() const noexcept;
    constexpr date::month month() const noexcept;
    constexpr date::weekday_last weekday_last() const noexcept;
    constexpr operator day_point() const noexcept;
    constexpr bool ok() const noexcept;
};

constexpr
bool
operator==(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;

constexpr
bool
operator!=(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;

constexpr
year_month_weekday_last
operator+(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;

constexpr
year_month_weekday_last
operator+(const months&amp; dm, const year_month_weekday_last&amp; ymwdl) noexcept;

constexpr
year_month_weekday_last
operator+(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;

constexpr
year_month_weekday_last
operator+(const years&amp; dy, const year_month_weekday_last&amp; ymwdl) noexcept;

constexpr
year_month_weekday_last
operator-(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;

constexpr
year_month_weekday_last
operator-(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month_weekday_last&amp; ymwdl);
</pre>

<p><b>Overview</b></p>

<p>
<code>year_month_weekday_last</code> represents a specific <code>year</code>,
<code>month</code>, and last <code>weekday</code> of the <code>month</code>.
<code>year_month_weekday_last</code> is a field-based time point with a resolution of
<code>days</code>, except that it is restricted to pointing to the last weekday of a year
and month.  One can observe each field. <code>year_month_weekday_last</code> supports
<code>years</code> and <code>months</code> oriented arithmetic, but not <code>days</code>
oriented arithmetic. For the latter, there is a conversion to <code>day_point</code> which
efficiently supports <code>days</code> oriented arithmetic.
<code>year_month_weekday_last</code> is equality comparable.
</p>

<p><b>Specification</b></p>

<p>
<code>year_month_weekday_last</code> is a trivially copyable class type.</br>
<code>year_month_weekday_last</code> is a standard-layout class type.</br>
<code>year_month_weekday_last</code> is a literal class type.</br>
</p>

<pre>
constexpr year_month_weekday_last::year_month_weekday_last(const date::year&amp; y, const date::month&amp; m,
                                                           const date::weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>year_month_weekday_last</code> by
constructing <code>y_</code> with <code>y</code>, <code>m_</code> with <code>m</code>,
and <code>wdl_</code> with <code>wdl</code>.
</p>
</blockquote>

<pre>
year_month_weekday_last&amp; year_month_weekday_last::operator+=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_weekday_last&amp; year_month_weekday_last::operator-=(const months&amp; m) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - m;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_weekday_last&amp; year_month_weekday_last::operator+=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this + y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
year_month_weekday_last&amp; year_month_weekday_last::operator-=(const years&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> <code>*this = *this - y;</code>.
</p>
<p>
<i>Returns:</i> <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr year year_month_weekday_last::year() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>y_</code>.
</p>
</blockquote>

<pre>
constexpr month year_month_weekday_last::month() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>m_</code>.
</p>
</blockquote>

<pre>
constexpr weekday_last year_month_weekday_last::weekday_last() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>wdl_</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last::operator day_point() const noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ok() == true</code>.
</p>
<p>
<i>Returns:</i> A <code>day_point</code> which represents the date represented by
<code>*this</code>.
</p>
</blockquote>

<pre>
constexpr bool year_month_weekday_last::ok() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> If <code>m_.ok() &amp;&amp; wdl_.ok()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator==(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>x.year() == y.year() &amp;&amp; x.month() == y.month() &amp;&amp; x.weekday_last() == y.weekday_last()</code>.
</p>
</blockquote>

<pre>
constexpr bool operator!=(const year_month_weekday_last&amp; x, const year_month_weekday_last&amp; y) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>!(x == y)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator+(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Requires:</i> <code>ymwdl.ok()</code> is <code>true</code>.
</p>
<p>
<i>Returns:</i> <code>(ymwdl.year() / ymwdl.month() + dm) / ymwdl.weekday_last()</code>.
</p>
<p>
<i>Postconditions:</i> The resultant <code>year_month_weekday_last</code> will return
<code>true</code> from <code>ok()</code>.
</p>
<p>
<i>Complexity:</i> O(1) with respect to the value of <code>dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator+(const months&amp; dm, const year_month_weekday_last&amp; ymwdl) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwdl + dm</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator-(const year_month_weekday_last&amp; ymwdl, const months&amp; dm) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwdl + (-dm)</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator+(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>{ymwdl.year()+dy, ymwdl.month(), ymwdl.weekday_last()}</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator+(const years&amp; dy, const year_month_weekday_last&amp; ymwdl) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwdl + dy</code>.
</p>
</blockquote>

<pre>
constexpr year_month_weekday_last operator-(const year_month_weekday_last&amp; ymwdl, const years&amp; dy) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>ymwdl + (-dy)</code>.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const year_month_weekday_last&amp; ymwdl);
</pre>

<blockquote>
<p>
<i>Effects:</i> Inserts an unspecified text representation of <code>ymwdl</code> into
<code>os</code>. For two objects of type <code>year_month_weekday_last</code> <code>x</code> and
<code>y</code>, if <code>x.ok() &amp;&amp; x == y</code> the <code>year_month_weekday_last</code> objects
shall have the same text representation and if <code>x.ok() &amp;&amp; x != y</code> the
<code>year_month_weekday_last</code> objects shall have distinct text representations.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
</blockquote>

</blockquote>

<h3>date composition operators</h3>

<blockquote>

<p>
To understand this API it is not necessary for you to memorize each of these operators.
Indeed, that would be detrimental to understanding this API.  Instead it is sufficient
to known that this collection of operators implement constructions in 3 orders:
</p>

<ol>
<li><code>y/m/d</code></li>
<li><code>m/d/y</code></li>
<li><code>d/m/y</code></li>
</ol>

<p>
The first component in each order must be properly typed, the following components may
be specified with the proper type or an <code>int</code>.
</p>

<p>
Anywhere a "day" is required one can also specify one of:
</p>

<ul>
<li><code>last</code></li>
<li><code>weekday[i]</code></li>
<li><code>weekday[last]</code></li>
</ul>

<p>
Sub-field-types such as <code>year_month</code> and <code>month_day</code> can be created
by simply not applying the second division operator for any of the three orders.  For
example:
</p>

<blockquote><pre>
year_month ym = 2015_y/apr;
month_day md1 = apr/4;
month_day md2 = 4_d/apr;
</pre></blockquote>

<p>
Everything not intended as above is caught as a compile-time error, with the notable
exception of an expression that consists of nothing but <code>int</code>, which of course
has type <code>int</code>.
</p>

<blockquote><pre>
auto a = 2015/4/4;       // a == int(125)
auto b = 2015_y/4/4;     // b == year_month_day{year(2015), month(4), day(4)}
auto c = 2015_y/4_d/apr; // error: invalid operands to binary expression ('date::year' and 'date::day')
auto d = 2015/apr/4;     // error: invalid operands to binary expression ('int' and 'const date::month')
</pre></blockquote>

<p>
The last example may be clear to a human reader.  But the compiler doesn't know if
<code>2015</code> refers to a <code>year</code> or a <code>day</code>.  Instead of
guessing, the compiler flags it as an error.
</p>

<p>
In short, you will either write unambiguous and readable code, or you will get a
compile-time error.
</p>

<hr>

<p><b><code>year_month</code>:</b></p>

<a name="_1"></a><pre>
constexpr year_month operator/(const year&amp; y, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{y, m}</code>.
</blockquote>

<a name="_2"></a><pre>
constexpr year_month operator/(const year&amp; y, int   m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / month(m)</code>.
</blockquote>

<p>&nbsp;</p>

<p><b><code>month_day</code>:</b></p>

<a name="_3"></a><pre>
constexpr month_day operator/(const month&amp; m, const day&amp; d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{m, d}</code>.
</blockquote>

<a name="_4"></a><pre>
constexpr month_day operator/(const month&amp; m, int d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / day(d)</code>.
</blockquote>

<a name="_5"></a><pre>
constexpr month_day operator/(int m, const day&amp; d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / d</code>.
</blockquote>

<a name="_6"></a><pre>
constexpr month_day operator/(const day&amp; d, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / d</code>.
</blockquote>

<a name="_7"></a><pre>
constexpr month_day operator/(const day&amp; d, int m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / d</code>.
</blockquote>

<p>&nbsp;</p>

<p><b><code>month_day_last</code>:</b></p>

<a name="_8"></a><pre>
constexpr month_day_last operator/(const month&amp; m, last_spec) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month_day_last{m}</code>.
</blockquote>

<a name="_9"></a><pre>
constexpr month_day_last operator/(int m, last_spec) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / last</code>.
</blockquote>

<a name="_10"></a><pre>
constexpr month_day_last operator/(last_spec, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / last</code>.
</blockquote>

<a name="_11"></a><pre>
constexpr month_day_last operator/(last_spec, int m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / last</code>.
</blockquote>

<p>&nbsp;</p>

<p><b><code>month_weekday</code>:</b></p>

<a name="_12"></a><pre>
constexpr month_weekday operator/(const month&amp; m, const weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{m, wdi}</code>.
</blockquote>

<a name="_13"></a><pre>
constexpr month_weekday operator/(int m, const weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / wdi</code>.
</blockquote>

<a name="_14"></a><pre>
constexpr month_weekday operator/(const weekday_indexed&amp; wdi, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / wdi</code>.
</blockquote>

<a name="_15"></a><pre>
constexpr month_weekday operator/(const weekday_indexed&amp; wdi, int m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / wdi</code>.
</blockquote>

<p>&nbsp;</p>

<p><b><code>month_weekday_last</code>:</b></p>

<a name="_16"></a><pre>
constexpr month_weekday_last operator/(const month&amp; m, const weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{m, wdl.weekday()}</code>.
</blockquote>

<a name="_17"></a><pre>
constexpr month_weekday_last operator/(int m, const weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / wdl</code>.
</blockquote>

<a name="_18"></a><pre>
constexpr month_weekday_last operator/(const weekday_last&amp; wdl, const month&amp; m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>m / wdl</code>.
</blockquote>

<a name="_19"></a><pre>
constexpr month_weekday_last operator/(const weekday_last&amp; wdl, int m) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>month(m) / wdl</code>.
</blockquote>

<p>&nbsp;</p>

<p><b><code>year_month_day</code>:</b></p>

<a name="_20"></a><pre>
constexpr year_month_day operator/(const year_month&amp; ym, const day&amp; d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{ym.year(), ym.month(), d}</code>.
</blockquote>

<a name="_21"></a><pre>
constexpr year_month_day operator/(const year_month&amp; ym, int d) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>ym / day(d)</code>.
</blockquote>

<a name="_22"></a><pre>
constexpr year_month_day operator/(const year&amp; y, const month_day&amp; md) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / md.month() / md.day()</code>.
</blockquote>

<a name="_23"></a><pre>
constexpr year_month_day operator/(int y, const month_day&amp; md) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / md</code>.
</blockquote>

<a name="_24"></a><pre>
constexpr year_month_day operator/(const month_day&amp; md, const year&amp; y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / md</code>.
</blockquote>

<a name="_25"></a><pre>
constexpr year_month_day operator/(const month_day&amp; md, int y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / md</code>.
</blockquote>

<p>&nbsp;</p>

<p><b><code>year_month_day_last</code>:</b></p>

<a name="_26"></a><pre>
constexpr year_month_day_last operator/(const year_month&amp; ym, last_spec) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{ym.year(), ym.month()}</code>.
</blockquote>

<a name="_27"></a><pre>
constexpr year_month_day_last operator/(const year&amp; y, const month_day_last&amp; mdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{y, mdl.month()}</code>.
</blockquote>

<a name="_28"></a><pre>
constexpr year_month_day_last operator/(int y, const month_day_last&amp; mdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mdl</code>.
</blockquote>

<a name="_29"></a><pre>
constexpr year_month_day_last operator/(const month_day_last&amp; mdl, const year&amp; y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / mdl</code>.
</blockquote>

<a name="_30"></a><pre>
constexpr year_month_day_last operator/(const month_day_last&amp; mdl, int y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mdl</code>.
</blockquote>

<p>&nbsp;</p>

<p><b><code>year_month_weekday</code>:</b></p>

<a name="_31"></a><pre>
constexpr year_month_weekday operator/(const year_month&amp; ym, const weekday_indexed&amp; wdi) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{ym.year(), ym.month(), wdi}</code>.
</blockquote>

<a name="_32"></a><pre>
constexpr year_month_weekday operator/(const year&amp; y, const month_weekday&amp; mwd) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{y, mwd.month(), mwd.weekday_indexed()}</code>.
</blockquote>

<a name="_33"></a><pre>
constexpr year_month_weekday operator/(int y, const month_weekday&amp; mwd) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mwd</code>.
</blockquote>

<a name="_34"></a><pre>
constexpr year_month_weekday operator/(const month_weekday&amp; mwd, const year&amp; y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / mwd</code>.
</blockquote>

<a name="_35"></a><pre>
constexpr year_month_weekday operator/(const month_weekday&amp; mwd, int y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mwd</code>.
</blockquote>

<p>&nbsp;</p>

<p><b><code>year_month_weekday_last</code>:</b></p>

<a name="_36"></a><pre>
constexpr year_month_weekday_last operator/(const year_month&amp; ym, const weekday_last&amp; wdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{ym.year(), ym.month(), wdl}</code>.
</blockquote>

<a name="_37"></a><pre>
constexpr year_month_weekday_last operator/(const year&amp; y, const month_weekday_last&amp; mwdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>{y, mwdl.month(), mwdl.weekday()[last]}</code>.
</blockquote>

<a name="_38"></a><pre>
constexpr year_month_weekday_last operator/(int y, const month_weekday_last&amp; mwdl) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mwdl</code>.
</blockquote>

<a name="_39"></a><pre>
constexpr year_month_weekday_last operator/(const month_weekday_last&amp; mwdl, const year&amp; y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>y / mwdl</code>.
</blockquote>

<a name="_40"></a><pre>
constexpr year_month_weekday_last operator/(const month_weekday_last&amp; mwdl, int y) noexcept;
</pre>

<blockquote>
<i>Returns:</i> <code>year(y) / mwdl</code>.
</blockquote>

</blockquote>

<a name="time_of_day"></a><h3><code>time_of_day</code></h3>

<blockquote>
<p><b>Overview</b></p>

<pre>
template &lt;class Duration&gt; class time_of_day;
</pre>

<p>
The <code>time_of_day</code> class breaks a <code>std::chrono::duration</code> which
represents the time elapsed since midnight, into a "broken" down time such as
hours:minutes:seconds.  The <code>Duration</code> template parameter dictates the
precision to which the time is broken down.  This can vary from a course precision of
hours to a very fine precision of nanoseconds.
</p>

<p>
There are 4 specializations of <code>time_of_day</code> to handle four precisions:
</p>

<ol>

<li>
<pre>
time_of_day&lt;std::chrono::hours&gt;
</pre>
<blockquote><p>
This specialization handles hours since midnight.
</p></blockquote>
</li>

<li>
<pre>
time_of_day&lt;std::chrono::minutes&gt;
</pre>
<blockquote><p>
This specialization handles hours:minutes since midnight.
</p></blockquote>
</li>

<li>
<pre>
time_of_day&lt;std::chrono::seconds&gt;
</pre>
<blockquote><p>
This specialization handles hours:minutes:seconds since midnight.
</p></blockquote>
</li>

<li>
<pre>
time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;
</pre>
<blockquote><p>
This specialization is restricted to <code>Period</code>s that are shorter than 1
second.  Typical uses are with milliseconds, microseconds and nanoseconds.  This
specialization handles hours:minute:seconds.fractional_seconds since midnight.
</p></blockquote>
</li>

</ol>

<p><b>Specification</b></p>

<pre>
enum {am = 1, pm};
</pre>

<p>
Each specialization of <code>time_of_day</code> is a trivially copyable class type.</br>
Each specialization of <code>time_of_day</code> is a standard-layout class type.</br>
Each specialization of <code>time_of_day</code> is a literal class type.</br>
</p>

<pre>
time_of_day&lt;std::chrono::hours&gt;
{
public:
    using precision = std::chrono::hours;

    constexpr explicit time_of_day(std::chrono::hours since_midnight) noexcept;
    constexpr time_of_day(std::chrono::hours h, unsigned md) noexcept;

    constexpr std::chrono::hours hours() const noexcept;
    constexpr unsigned mode() const noexcept;

    constexpr explicit operator precision() const noexcept;

    void make24() noexcept;
    void make12() noexcept;
};
</pre>

<pre>
constexpr explicit time_of_day&lt;std::chrono::hours&gt;::time_of_day(std::chrono::hours since_midnight) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 24-hour format
corresponding to <code>since_midnight</code> hours after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns the integral number of hours
<code>since_midnight</code> is after 00:00:00.  <code>mode()</code> returns <code>0</code>.
</p>
</blockquote>

<pre>
constexpr time_of_day&lt;std::chrono::hours&gt;::time_of_day(std::chrono::hours h, unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>md == am</code> or <code>md == pm</code>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 12-hour format
corresponding to <code>h</code> hours after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns <code>h</code>, and <code>mode()</code>
returns <code>md</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::hours time_of_day&lt;std::chrono::hours&gt;::hours() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored hour of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr unsigned time_of_day&lt;std::chrono::hours&gt;::mode() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> 0 if <code>*this</code> is in 24-hour format.  Otherwise returns
<code>am</code> or <code>pm</code> corresponding to whether this represents a before-noon
time or afternoon time.
</p>
</blockquote>

<pre>
constexpr explicit time_of_day&lt;std::chrono::hours&gt;::operator precision() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of hours since midnight.
</p>
</blockquote>

<pre>
void time_of_day&lt;std::chrono::hours&gt;::make24() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 12-hour time, converts to a 24-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
void time_of_day&lt;std::chrono::hours&gt;::make12() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 24-hour time, converts to a 12-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const time_of_day&lt;std::chrono::hours&gt;&amp; t);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>t</code> is a 24-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%H00".  "%H" will emit a leading 0 for
hours less than 10.
Else <code>t</code> is a 12-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%I%p" according to the C locale, except
that no leading zero is output for hours less than 10.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i>
</p>
<blockquote><pre>
0100  // 1 in the morning in 24-hour format
1800  // 6 in the evening in 24-hour format
1am   // 1 in the morning in 12-hour format
6pm   // 6 in the evening in 12-hour format
</pre></blockquote>
</blockquote>

<pre>
time_of_day&lt;std::chrono::minutes&gt;
{
public:
    using precision = std::chrono::minutes;

    constexpr explicit time_of_day(std::chrono::minutes since_midnight) noexcept;
    constexpr time_of_day(std::chrono::hours h, std::chrono::minutes m,
                          unsigned md) noexcept;

    constexpr std::chrono::hours   hours() const noexcept;
    constexpr std::chrono::minutes minutes() const noexcept;
    constexpr unsigned mode() const noexcept;

    constexpr explicit operator precision() const noexcept;

    void make24() noexcept;
    void make12() noexcept;
};
</pre>

<pre>
constexpr explicit time_of_day&lt;std::chrono::minutes&gt;::time_of_day(std::chrono::minutes since_midnight) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 24-hour format
corresponding to <code>since_midnight</code> minutes after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns the integral number of hours
<code>since_midnight</code> is after 00:00:00.  <code>minutes()</code> returns the
integral number of minutes <code>since_midnight</code> is after (00:00:00 +
<code>hours()</code>). <code>mode()</code> returns <code>0</code>.
</p>
</blockquote>

<pre>
constexpr time_of_day&lt;std::chrono::minutes&gt;::time_of_day(std::chrono::hours h, std::chrono::minutes m,
                                                               unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>md == am</code> or <code>md == pm</code>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 12-hour format
corresponding to <code>h</code> hours and <code>m</code> minutes after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns <code>h</code>, <code>minutes()</code>
returns <code>m</code>, and <code>mode()</code> returns <code>md</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::hours time_of_day&lt;std::chrono::minutes&gt;::hours() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored hour of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::minutes time_of_day&lt;std::chrono::minutes&gt;::minutes() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored minute of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr unsigned time_of_day&lt;std::chrono::minutes&gt;::mode() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> 0 if <code>*this</code> is in 24-hour format.  Otherwise returns
<code>am</code> or <code>pm</code> corresponding to whether this represents a before-noon
time or afternoon time.
</p>
</blockquote>

<pre>
constexpr explicit time_of_day&lt;std::chrono::minutes&gt;::operator precision() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of minutes since midnight.
</p>
</blockquote>

<pre>
void time_of_day&lt;std::chrono::minutes&gt;::make24() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 12-hour time, converts to a 24-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
void time_of_day&lt;std::chrono::minutes&gt;::make12() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 24-hour time, converts to a 12-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const time_of_day&lt;std::chrono::minutes&gt;&amp; t);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>t</code> is a 24-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%H:%M".  "%H" will emit a leading 0 for
hours less than 10.
Else <code>t</code> is a 12-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%I:%M%p" according to the C locale, except
that no leading zero is output for hours less than 10.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i>
</p>
<blockquote><pre>
01:08   // 1:08 in the morning in 24-hour format
18:15   // 6:15 in the evening in 24-hour format
1:08am  // 1:08 in the morning in 12-hour format
6:15pm  // 6:15 in the evening in 12-hour format
</pre></blockquote>
</blockquote>

<pre>
time_of_day&lt;std::chrono::seconds&gt;
{
public:
    using precision = std::chrono::seconds;

    constexpr explicit time_of_day(std::chrono::seconds since_midnight) noexcept;
    constexpr time_of_day(std::chrono::hours h, std::chrono::minutes m,
                          std::chrono::seconds s, unsigned md) noexcept;

    constexpr std::chrono::hours   hours() const noexcept;
    constexpr std::chrono::minutes minutes() const noexcept;
    constexpr std::chrono::seconds seconds() const noexcept;
    constexpr unsigned mode() const noexcept;

    constexpr explicit operator precision() const noexcept;

    void make24() noexcept;
    void make12() noexcept;
};
</pre>

<pre>
constexpr explicit time_of_day&lt;std::chrono::seconds&gt;::time_of_day(std::chrono::seconds since_midnight) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 24-hour format
corresponding to <code>since_midnight</code> seconds after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns the integral number of hours
<code>since_midnight</code> is after 00:00:00.  <code>minutes()</code> returns the
integral number of minutes <code>since_midnight</code> is after (00:00:00 +
<code>hours()</code>). <code>seconds()</code> returns the integral number of seconds
<code>since_midnight</code> is after (00:00:00 + <code>hours()</code> +
<code>minutes()</code>). <code>mode()</code> returns <code>0</code>.
</p>
</blockquote>

<pre>
constexpr time_of_day&lt;std::chrono::seconds&gt;::time_of_day(std::chrono::hours h, std::chrono::minutes m,
                                                               std::chrono::seconds s, unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>md == am</code> or <code>md == pm</code>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 12-hour format
corresponding to <code>h</code> hours, <code>m</code> minutes, and <code>s</code> seconds
after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns <code>h</code>. <code>minutes()</code>
returns <code>m</code>.  <code>seconds()</code> returns <code>s</code>. 
<code>mode()</code> returns <code>md</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::hours time_of_day&lt;std::chrono::seconds&gt;::hours() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored hour of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::minutes time_of_day&lt;std::chrono::seconds&gt;::minutes() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored minute of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::seconds time_of_day&lt;std::chrono::seconds&gt;::seconds() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored second of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr unsigned time_of_day&lt;std::chrono::seconds&gt;::mode() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> 0 if <code>*this</code> is in 24-hour format.  Otherwise returns
<code>am</code> or <code>pm</code> corresponding to whether this represents a before-noon
time or afternoon time.
</p>
</blockquote>

<pre>
constexpr explicit time_of_day&lt;std::chrono::seconds&gt;::operator precision() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of seconds since midnight.
</p>
</blockquote>

<pre>
void time_of_day&lt;std::chrono::seconds&gt;::make24() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 12-hour time, converts to a 24-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
void time_of_day&lt;std::chrono::seconds&gt;::make12() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 24-hour time, converts to a 12-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const time_of_day&lt;std::chrono::seconds&gt;&amp; t);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>t</code> is a 24-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%H:%M%S".  "%H" will emit a leading 0 for
hours less than 10.
Else <code>t</code> is a 12-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%I:%M%S%p" according to the C locale, except
that no leading zero is output for hours less than 10.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i>
</p>
<blockquote><pre>
01:08:03   // 1:08:03 in the morning in 24-hour format
18:15:45   // 6:15:45 in the evening in 24-hour format
1:08:03am  // 1:08:03 in the morning in 12-hour format
6:15:45pm  // 6:15:45 in the evening in 12-hour format
</pre></blockquote>
</blockquote>

<pre>
time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;
{
public:
    using precision = std::chrono::duration&lt;Rep, Period&gt;;

    constexpr explicit time_of_day(precision since_midnight) noexcept;
    constexpr time_of_day(std::chrono::hours h, std::chrono::minutes m,
                          std::chrono::seconds s, precision sub_s, unsigned md) noexcept;

    constexpr std::chrono::hours   hours() const noexcept;
    constexpr std::chrono::minutes minutes() const noexcept;
    constexpr std::chrono::seconds seconds() const noexcept;
    constexpr std::chrono::precision subseconds() const noexcept;
    constexpr unsigned mode() const noexcept;

    constexpr explicit operator precision() const noexcept;

    void make24() noexcept;
    void make12() noexcept;
};
</pre>

<p>
This specialization shall not exist unless <code>Period &lt; 1s</code>.
</p>

<pre>
constexpr explicit time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::time_of_day(precision since_midnight) noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 24-hour format
corresponding to <code>since_midnight precision</code> fractional seconds after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns the integral number of hours
<code>since_midnight</code> is after 00:00:00.  <code>minutes()</code> returns the
integral number of minutes <code>since_midnight</code> is after (00:00:00 +
<code>hours()</code>). <code>seconds()</code> returns the integral number of seconds
<code>since_midnight</code> is after (00:00:00 + <code>hours()</code> +
<code>minutes()</code>). <code>subseconds()</code> returns the integral number of
fractional precision seconds <code>since_midnight</code> is after (00:00:00 +
<code>hours()</code> + <code>minutes()</code> + <code>seconds</code>). <code>mode()</code>
returns <code>0</code>.
</p>
</blockquote>

<pre>
constexpr time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::time_of_day(std::chrono::hours h, std::chrono::minutes m,
                                                                       std::chrono::seconds s, precision sub_s,
                                                                       unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Preconditions:</i> <code>md == am</code> or <code>md == pm</code>.
</p>
<p>
<i>Effects:</i> Constructs an object of type <code>time_of_day</code> in 12-hour format
corresponding to <code>h</code> hours, <code>m</code> minutes, and <code>s + sub_s</code>
seconds after 00:00:00.
</p>
<p>
<i>Postconditions:</i> <code>hours()</code> returns <code>h</code>. <code>minutes()</code>
returns <code>m</code>.  <code>seconds()</code> returns <code>s</code>.
<code>subseconds()</code> returns <code>sub_s</code>. <code>mode()</code> returns
<code>md</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::hours time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::hours() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored hour of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::minutes time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::minutes() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored minute of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::seconds time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::seconds() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored second of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr std::chrono::seconds time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::subseconds() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The stored subsecond of <code>*this</code>.
</p>
</blockquote>

<pre>
constexpr unsigned time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::mode() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> 0 if <code>*this</code> is in 24-hour format.  Otherwise returns
<code>am</code> or <code>pm</code> corresponding to whether this represents a before-noon
time or afternoon time.
</p>
</blockquote>

<pre>
constexpr explicit time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::operator precision() const noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> The number of subseconds since midnight.
</p>
</blockquote>

<pre>
void time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::make24() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 12-hour time, converts to a 24-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
void time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;::make12() noexcept;
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>*this</code> is a 24-hour time, converts to a 12-hour time.
Otherwise, no effects.
</p>
</blockquote>

<pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;&amp; t);
</pre>

<blockquote>
<p>
<i>Effects:</i> If <code>t</code> is a 24-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%H:%M%S.%s".  "%H" will emit a leading 0 for
hours less than 10.  "%s" is not a <code>strftime</code> code and represents the fractional
seconds.
Else <code>t</code> is a 12-hour time, outputs to <code>os</code>
according to the <code>strftime</code> format: "%I:%M%S.%s%p" according to the C locale, except
that no leading zero is output for hours less than 10.
</p>
<p>
<i>Returns:</i> <code>os</code>.
</p>
<p>
<i>Example:</i>
</p>
<blockquote><pre>
01:08:03.007   // 1:08:03.007 in the morning in 24-hour format (assuming millisecond precision)
18:15:45.123   // 6:15:45.123 in the evening in 24-hour format (assuming millisecond precision)
1:08:03.007am  // 1:08:03.007 in the morning in 12-hour format (assuming millisecond precision)
6:15:45.123pm  // 6:15:45.123 in the evening in 12-hour format (assuming millisecond precision)
</pre></blockquote>
</blockquote>

</blockquote>

<h3><code>make_time</code></h3>

<blockquote>

<a name="_41"></a><pre>
template &lt;class Rep, class Period&gt;
constexpr
time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;
make_time(std::chrono::duration&lt;Rep, Period&gt; d) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;(d)</code>.
</p>
</blockquote>

<a name="_42"></a><pre>
constexpr
time_of_day&lt;std::chrono::hours&gt;
make_time(std::chrono::hours h, unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;std::chrono::hours&gt;(h, md)</code>.
</p>
</blockquote>

<a name="_43"></a><pre>
constexpr
time_of_day&lt;std::chrono::minutes&gt;
make_time(std::chrono::hours h, std::chrono::minutes m, unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;std::chrono::minutes&gt;(h, m, md)</code>.
</p>
</blockquote>

<a name="_44"></a><pre>
constexpr
time_of_day&lt;std::chrono::seconds&gt;
make_time(std::chrono::hours h, std::chrono::minutes m, std::chrono::seconds s,
          unsigned md) noexcept;
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;std::chrono::seconds&gt;(h, m, s, md)</code>.
</p>
</blockquote>

<a name="_45"></a><pre>
template &lt;class Rep, class Period,
          class = std::enable_if_t&lt;std::ratio_less&lt;Period, std::ratio&lt;1&gt;&gt;::value&gt;&gt;
constexpr
time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;
make_time(std::chrono::hours h, std::chrono::minutes m, std::chrono::seconds s,
          std::chrono::duration&lt;Rep, Period&gt; sub_s, unsigned md) noexcept
</pre>

<blockquote>
<p>
<i>Returns:</i> <code>time_of_day&lt;std::chrono::duration&lt;Rep, Period&gt;&gt;(h, m, s, sub_s, md)</code>.
</p>
</blockquote>

</blockquote>

</body>
</html>
