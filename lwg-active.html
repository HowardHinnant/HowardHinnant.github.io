<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>C++ Standard Library Active Issues List</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
  table {border-collapse: collapse;}
</style>
</head>
<body>
<table>
<tr>
  <td align="left">Doc. no.</td>
  <td align="left">D????</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">2016-10-14</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">Programming Language C++</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Marshall Clow &lt;<a href="mailto:lwgchair@gmail.com">lwgchair@gmail.com</a>&gt;</td>
</tr>
</table>
<h1>C++ Standard Library Active Issues List (Revision D100)</h1>
<p><p>Revised 2016-10-14 at 19:10:05 UTC</p>
</p>
  <p>Reference ISO/IEC IS 14882:2014(E)</p>
  <p>Also see:</p>
  <ul>
      <li><a href="lwg-toc.html">Table of Contents</a> for all library issues.</li>
      <li><a href="lwg-index.html">Index by Section</a> for all library issues.</li>
      <li><a href="lwg-status.html">Index by Status</a> for all library issues.</li>
      <li><a href="lwg-defects.html">Library Defect Reports List</a></li>
      <li><a href="lwg-closed.html">Library Closed Issues List</a></li>
  </ul>
  <p>The purpose of this document is to record the status of issues
  which have come before the Library Working Group (LWG) of the INCITS PL22.16
  and ISO WG21 C++ Standards Committee. Issues represent
  potential defects in the ISO/IEC IS 14882:2014(E) document.  
  </p>

  <p>This document contains only library issues which are actively being
  considered by the Library Working Group, i.e., issues which have a
  status of <a href="lwg-active.html#New">New</a>, <a href="lwg-active.html#Open">Open</a>, 
  <a href="lwg-active.html#Ready">Ready</a>, or <a href="lwg-active.html#Review">Review</a>.
  See <a href="lwg-defects.html">Library Defect Reports List</a> for issues considered defects
  and <a href="lwg-closed.html">Library Closed Issues List</a> for issues considered closed.</p>

  <p>The issues in these lists are not necessarily formal ISO Defect
  Reports (DR's). While some issues will eventually be elevated to
  official Defect Report status, other issues will be disposed of in
  other ways. See <a href="#Status">Issue Status</a>.</p>

  <p>Prior to Revision 14, library issues lists existed in two slightly
  different versions; a Committee Version and a Public
  Version. Beginning with Revision 14 the two versions were combined
  into a single version.</p>

  <p>This document includes <i>[bracketed italicized notes]</i> as a
  reminder to the LWG of current progress on issues. Such notes are
  strictly unofficial and should be read with caution as they may be
  incomplete or incorrect. Be aware that LWG support for a particular
  resolution can quickly change if new viewpoints or killer examples are
  presented in subsequent discussions.</p>

  <p>For the most current official version of this document see 
  <a href="http://www.open-std.org/jtc1/sc22/wg21/">http://www.open-std.org/jtc1/sc22/wg21/</a>.
  Requests for further information about this document should include
  the document number above, reference ISO/IEC 14882:2014(E), and be
  submitted to Information Technology Industry Council (ITI), 1250 Eye
  Street NW, Washington, DC 20005.</p>

  <p>Public information as to how to obtain a copy of the C++ Standard,
  join the standards committee, submit an issue, or comment on an issue
  can be found in the comp.std.c++ FAQ.
  </p>

<p><a name="submit_issue"></a><b>How to submit an issue</b></p>

<ol style="list-style-type:upper-alpha">
<li><a name="submit_issue_A"></a>
Mail your issue to the author of this list.
</li>
<li><a name="submit_issue_B"></a>
Specify a short descriptive title.  If you fail to do so, the subject line of your
mail will be used as the issue title.
</li>
<li><a name="submit_issue_C"></a>
If the "From" on your email is not the name you wish to appear as issue submitter,
then specify issue submitter.
</li>
<li><a name="submit_issue_D"></a>
Provide a brief discussion of the problem you wish to correct.  Refer to the latest
working draft or standard using [section.tag] and paragraph numbers where appropriate.
</li>
<li><a name="submit_issue_E"></a>
Provide proposed wording.  This should indicate exactly how you want the standard
to be changed.  General solution statements belong in the discussion area.  This
area contains very clear and specific directions on how to modify the current
draft.  If you are not sure how to word a solution, you may omit this part.
But your chances of a successful issue greatly increase if you attempt wording.
</li>
<li><a name="submit_issue_F"></a>
It is not necessary for you to use html markup.  However, if you want to, you can
&lt;ins&gt;<ins>insert text like this</ins>&lt;/ins&gt; and &lt;del&gt;<del>delete text like
this</del>&lt;/del&gt;.  The only strict requirement is to communicate clearly to
the list maintainer exactly how you want your issue to look.
</li>
<li><a name="submit_issue_G"></a>
It is not necessary for you to specify other html font/formatting
mark-up, but if you do the list maintainer will attempt to respect your
formatting wishes (as described by html markup, or other common idioms).
</li>
<li><a name="submit_issue_H"></a>
It is not necessary for you to specify open date or last modified date (the date
of your mail will be used).
</li>
<li><a name="submit_issue_I"></a>
It is not necessary for you to cross reference other issues, but you can if you
like.  You do not need to form the hyperlinks when you do, the list maintainer will
take care of that.
</li>
<li><a name="submit_issue_J"></a>
One issue per email is best.
</li>
<li><a name="submit_issue_K"></a>
Between the time you submit the issue, and the next mailing deadline
(date at the top of the Revision History), you <em>own</em> this issue. 
You control the content, the stuff that is right, the stuff that is
wrong, the format, the misspellings, etc.  You can even make the issue
disappear if you want.  Just let the list maintainer know how you want
it to look, and he will try his best to accommodate you.  After the
issue appears in an official mailing, you no longer enjoy exclusive
ownership of it.
</li>
</ol>


<h2>Revision History</h2>
<ul>
<li>D100: 2016-10-17 2016 pre-Issaquah mailing<ul>
<li><b>Summary:</b><ul>
<li>256 open issues, up by 27.</li>
<li>1978 closed issues, up by 5.</li>
<li>68 reassigned issues, up by 5.</li>
<li>2302 issues total, up by 37.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 21 Tentatively Ready issues: <a href="lwg-active.html#2744">2744</a>, <a href="lwg-active.html#2745">2745</a>, <a href="lwg-active.html#2747">2747</a>, <a href="lwg-active.html#2748">2748</a>, <a href="lwg-active.html#2749">2749</a>, <a href="lwg-active.html#2750">2750</a>, <a href="lwg-active.html#2752">2752</a>, <a href="lwg-active.html#2753">2753</a>, <a href="lwg-active.html#2754">2754</a>, <a href="lwg-active.html#2755">2755</a>, <a href="lwg-active.html#2756">2756</a>, <a href="lwg-active.html#2758">2758</a>, <a href="lwg-active.html#2759">2759</a>, <a href="lwg-active.html#2760">2760</a>, <a href="lwg-active.html#2765">2765</a>, <a href="lwg-active.html#2767">2767</a>, <a href="lwg-active.html#2768">2768</a>, <a href="lwg-active.html#2771">2771</a>, <a href="lwg-active.html#2773">2773</a>, <a href="lwg-active.html#2777">2777</a>, <a href="lwg-active.html#2778">2778</a>.</li>
<li>Added the following 9 New issues: <a href="lwg-active.html#2746">2746</a>, <a href="lwg-active.html#2751">2751</a>, <a href="lwg-active.html#2763">2763</a>, <a href="lwg-active.html#2764">2764</a>, <a href="lwg-active.html#2766">2766</a>, <a href="lwg-active.html#2772">2772</a>, <a href="lwg-active.html#2774">2774</a>, <a href="lwg-active.html#2776">2776</a>, <a href="lwg-active.html#2780">2780</a>.</li>
<li>Added the following 2 Open issues: <a href="lwg-active.html#2769">2769</a>, <a href="lwg-active.html#2770">2770</a>.</li>
<li>Added the following 2 LEWG issues: <a href="lwg-active.html#2762">2762</a>, <a href="lwg-active.html#2779">2779</a>.</li>
<li>Added the following Tentatively Resolved issue: <a href="lwg-active.html#2757">2757</a>.</li>
<li>Added the following NAD issue: <a href="lwg-closed.html#2761">2761</a>.</li>
<li>Added the following Dup issue: <a href="lwg-closed.html#2775">2775</a>.</li>
<li>Changed the following 47 issues to Tentatively Ready (from New): <a href="lwg-active.html#2166">2166</a>, <a href="lwg-active.html#2221">2221</a>, <a href="lwg-active.html#2261">2261</a>, <a href="lwg-active.html#2394">2394</a>, <a href="lwg-active.html#2460">2460</a>, <a href="lwg-active.html#2475">2475</a>, <a href="lwg-active.html#2503">2503</a>, <a href="lwg-active.html#2514">2514</a>, <a href="lwg-active.html#2519">2519</a>, <a href="lwg-active.html#2531">2531</a>, <a href="lwg-active.html#2534">2534</a>, <a href="lwg-active.html#2536">2536</a>, <a href="lwg-active.html#2540">2540</a>, <a href="lwg-active.html#2544">2544</a>, <a href="lwg-active.html#2556">2556</a>, <a href="lwg-active.html#2562">2562</a>, <a href="lwg-active.html#2567">2567</a>, <a href="lwg-active.html#2569">2569</a>, <a href="lwg-active.html#2570">2570</a>, <a href="lwg-active.html#2578">2578</a>, <a href="lwg-active.html#2584">2584</a>, <a href="lwg-active.html#2589">2589</a>, <a href="lwg-active.html#2591">2591</a>, <a href="lwg-active.html#2598">2598</a>, <a href="lwg-active.html#2664">2664</a>, <a href="lwg-active.html#2665">2665</a>, <a href="lwg-active.html#2672">2672</a>, <a href="lwg-active.html#2678">2678</a>, <a href="lwg-active.html#2679">2679</a>, <a href="lwg-active.html#2680">2680</a>, <a href="lwg-active.html#2681">2681</a>, <a href="lwg-active.html#2682">2682</a>, <a href="lwg-active.html#2686">2686</a>, <a href="lwg-active.html#2694">2694</a>, <a href="lwg-active.html#2696">2696</a>, <a href="lwg-active.html#2699">2699</a>, <a href="lwg-active.html#2712">2712</a>, <a href="lwg-active.html#2722">2722</a>, <a href="lwg-active.html#2729">2729</a>, <a href="lwg-active.html#2732">2732</a>, <a href="lwg-active.html#2733">2733</a>, <a href="lwg-active.html#2735">2735</a>, <a href="lwg-active.html#2736">2736</a>, <a href="lwg-active.html#2738">2738</a>, <a href="lwg-active.html#2739">2739</a>, <a href="lwg-active.html#2740">2740</a>, <a href="lwg-active.html#2742">2742</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from Open): <a href="lwg-active.html#2062">2062</a>, <a href="lwg-active.html#2223">2223</a>, <a href="lwg-active.html#2468">2468</a>, <a href="lwg-active.html#2510">2510</a>, <a href="lwg-active.html#2543">2543</a>.</li>
<li>Changed the following issue to Review (from New): <a href="lwg-active.html#2676">2676</a>.</li>
<li>Changed the following issue to Review (from Open): <a href="lwg-active.html#2245">2245</a>.</li>
<li>Changed the following 11 issues to Open (from New): <a href="lwg-active.html#2158">2158</a>, <a href="lwg-active.html#2358">2358</a>, <a href="lwg-active.html#2381">2381</a>, <a href="lwg-active.html#2465">2465</a>, <a href="lwg-active.html#2512">2512</a>, <a href="lwg-active.html#2530">2530</a>, <a href="lwg-active.html#2532">2532</a>, <a href="lwg-active.html#2568">2568</a>, <a href="lwg-active.html#2587">2587</a>, <a href="lwg-active.html#2588">2588</a>, <a href="lwg-active.html#2708">2708</a>.</li>
<li>Changed the following 3 issues to LEWG (from New): <a href="lwg-active.html#2242">2242</a>, <a href="lwg-active.html#2471">2471</a>, <a href="lwg-active.html#2593">2593</a>.</li>
<li>Changed the following 3 issues to LEWG (from Open): <a href="lwg-active.html#2095">2095</a>, <a href="lwg-active.html#2152">2152</a>, <a href="lwg-active.html#2153">2153</a>.</li>
<li>Changed the following 6 issues to Tentatively Resolved (from New): <a href="lwg-active.html#2343">2343</a>, <a href="lwg-active.html#2501">2501</a>, <a href="lwg-active.html#2502">2502</a>, <a href="lwg-active.html#2548">2548</a>, <a href="lwg-active.html#2663">2663</a>, <a href="lwg-active.html#2677">2677</a>.</li>
<li>Changed the following 4 issues to Tentatively Resolved (from Open): <a href="lwg-active.html#2294">2294</a>, <a href="lwg-active.html#2370">2370</a>, <a href="lwg-active.html#2424">2424</a>, <a href="lwg-active.html#2505">2505</a>.</li>
<li>Changed the following 3 issues to Tentatively Resolved (from LEWG): <a href="lwg-active.html#839">839</a>, <a href="lwg-active.html#1041">1041</a>, <a href="lwg-active.html#2443">2443</a>.</li>
<li>Changed the following issue to NAD Editorial (from New): <a href="lwg-closed.html#2701">2701</a>.</li>
<li>Changed the following 2 issues to NAD (from New): <a href="lwg-closed.html#2161">2161</a>, <a href="lwg-closed.html#2535">2535</a>.</li>
</ul></li>
</ul>
</li>
<li>R99: 
2016-07-11 2016 post-Oulu mailing
<ul>
<li><b>Summary:</b><ul>
<li>292 open issues, down by 26.</li>
<li>1973 closed issues, up by 51.</li>
<li>2265 issues total, up by 25.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 16 New issues: <a href="lwg-active.html#2722">2722</a>, <a href="lwg-active.html#2729">2729</a>, <a href="lwg-active.html#2730">2730</a>, <a href="lwg-active.html#2731">2731</a>, <a href="lwg-active.html#2732">2732</a>, <a href="lwg-active.html#2733">2733</a>, <a href="lwg-active.html#2734">2734</a>, <a href="lwg-active.html#2735">2735</a>, <a href="lwg-active.html#2736">2736</a>, <a href="lwg-active.html#2737">2737</a>, <a href="lwg-active.html#2738">2738</a>, <a href="lwg-active.html#2739">2739</a>, <a href="lwg-active.html#2740">2740</a>, <a href="lwg-active.html#2741">2741</a>, <a href="lwg-active.html#2742">2742</a>, <a href="lwg-active.html#2743">2743</a>.</li>
<li>Added the following 9 WP issues: <a href="lwg-defects.html#2719">2719</a>, <a href="lwg-defects.html#2720">2720</a>, <a href="lwg-defects.html#2721">2721</a>, <a href="lwg-defects.html#2723">2723</a>, <a href="lwg-defects.html#2724">2724</a>, <a href="lwg-defects.html#2725">2725</a>, <a href="lwg-defects.html#2726">2726</a>, <a href="lwg-defects.html#2727">2727</a>, <a href="lwg-defects.html#2728">2728</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="lwg-active.html#2717">2717</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Open): <a href="lwg-active.html#2241">2241</a>.</li>
<li>Changed the following 21 issues to WP (from Ready): <a href="lwg-defects.html#2181">2181</a>, <a href="lwg-defects.html#2309">2309</a>, <a href="lwg-defects.html#2310">2310</a>, <a href="lwg-defects.html#2328">2328</a>, <a href="lwg-defects.html#2393">2393</a>, <a href="lwg-defects.html#2426">2426</a>, <a href="lwg-defects.html#2436">2436</a>, <a href="lwg-defects.html#2441">2441</a>, <a href="lwg-defects.html#2451">2451</a>, <a href="lwg-defects.html#2516">2516</a>, <a href="lwg-defects.html#2542">2542</a>, <a href="lwg-defects.html#2549">2549</a>, <a href="lwg-defects.html#2550">2550</a>, <a href="lwg-defects.html#2551">2551</a>, <a href="lwg-defects.html#2555">2555</a>, <a href="lwg-defects.html#2573">2573</a>, <a href="lwg-defects.html#2667">2667</a>, <a href="lwg-defects.html#2669">2669</a>, <a href="lwg-defects.html#2670">2670</a>, <a href="lwg-defects.html#2671">2671</a>, <a href="lwg-defects.html#2673">2673</a>.</li>
<li>Changed the following 12 issues to WP (from Tentatively Ready): <a href="lwg-defects.html#2509">2509</a>, <a href="lwg-defects.html#2596">2596</a>, <a href="lwg-defects.html#2674">2674</a>, <a href="lwg-defects.html#2683">2683</a>, <a href="lwg-defects.html#2684">2684</a>, <a href="lwg-defects.html#2685">2685</a>, <a href="lwg-defects.html#2688">2688</a>, <a href="lwg-defects.html#2689">2689</a>, <a href="lwg-defects.html#2698">2698</a>, <a href="lwg-defects.html#2706">2706</a>, <a href="lwg-defects.html#2707">2707</a>, <a href="lwg-defects.html#2710">2710</a>.</li>
<li>Changed the following 6 issues to WP (from New): <a href="lwg-defects.html#2687">2687</a>, <a href="lwg-defects.html#2704">2704</a>, <a href="lwg-defects.html#2709">2709</a>, <a href="lwg-defects.html#2711">2711</a>, <a href="lwg-defects.html#2716">2716</a>, <a href="lwg-defects.html#2718">2718</a>.</li>
<li>Changed the following 2 issues to WP (from Open): <a href="lwg-defects.html#2312">2312</a>, <a href="lwg-defects.html#2422">2422</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="lwg-closed.html#2700">2700</a>.</li>
</ul></li>
</ul>
</li>
<li>R98: 
2016-05-29 2016 pre-Oulu mailing
<ul>
<li><b>Summary:</b><ul>
<li>318 open issues, up by 50.</li>
<li>1922 closed issues, up by 0.</li>
<li>2240 issues total, up by 50.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 10 Tentatively Ready issues: <a href="lwg-defects.html#2596">2596</a>, <a href="lwg-defects.html#2683">2683</a>, <a href="lwg-defects.html#2684">2684</a>, <a href="lwg-defects.html#2685">2685</a>, <a href="lwg-defects.html#2688">2688</a>, <a href="lwg-defects.html#2689">2689</a>, <a href="lwg-defects.html#2698">2698</a>, <a href="lwg-defects.html#2706">2706</a>, <a href="lwg-defects.html#2707">2707</a>, <a href="lwg-defects.html#2710">2710</a>.</li>
<li>Added the following Tentatively NAD issue: <a href="lwg-active.html#2692">2692</a>.</li>
<li>Added the following 37 New issues: <a href="lwg-active.html#2595">2595</a>, <a href="lwg-active.html#2597">2597</a>, <a href="lwg-active.html#2598">2598</a>, <a href="lwg-active.html#2599">2599</a>, <a href="lwg-active.html#2675">2675</a>, <a href="lwg-active.html#2676">2676</a>, <a href="lwg-active.html#2677">2677</a>, <a href="lwg-active.html#2678">2678</a>, <a href="lwg-active.html#2679">2679</a>, <a href="lwg-active.html#2680">2680</a>, <a href="lwg-active.html#2681">2681</a>, <a href="lwg-active.html#2682">2682</a>, <a href="lwg-active.html#2686">2686</a>, <a href="lwg-defects.html#2687">2687</a>, <a href="lwg-active.html#2691">2691</a>, <a href="lwg-active.html#2693">2693</a>, <a href="lwg-active.html#2694">2694</a>, <a href="lwg-active.html#2695">2695</a>, <a href="lwg-active.html#2696">2696</a>, <a href="lwg-active.html#2697">2697</a>, <a href="lwg-active.html#2699">2699</a>, <a href="lwg-closed.html#2700">2700</a>, <a href="lwg-closed.html#2701">2701</a>, <a href="lwg-active.html#2702">2702</a>, <a href="lwg-active.html#2703">2703</a>, <a href="lwg-defects.html#2704">2704</a>, <a href="lwg-active.html#2705">2705</a>, <a href="lwg-active.html#2708">2708</a>, <a href="lwg-defects.html#2709">2709</a>, <a href="lwg-defects.html#2711">2711</a>, <a href="lwg-active.html#2712">2712</a>, <a href="lwg-active.html#2713">2713</a>, <a href="lwg-active.html#2714">2714</a>, <a href="lwg-active.html#2715">2715</a>, <a href="lwg-defects.html#2716">2716</a>, <a href="lwg-active.html#2717">2717</a>, <a href="lwg-defects.html#2718">2718</a>.</li>
<li>Added the following 2 LEWG issues: <a href="lwg-active.html#2600">2600</a>, <a href="lwg-active.html#2690">2690</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="lwg-defects.html#2674">2674</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="lwg-defects.html#2509">2509</a>.</li>
<li>Changed the following 2 issues to Tentatively Resolved (from New): <a href="lwg-active.html#2208">2208</a>, <a href="lwg-active.html#2529">2529</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from Open): <a href="lwg-active.html#2179">2179</a>.</li>
<li>Changed the following issue to Tentatively Resolved (from LEWG): <a href="lwg-active.html#2391">2391</a>.</li>
</ul></li>
</ul>
</li>
<li>R97: 
2016-03-22 2016 post-Jacksonville mailing
<ul>
<li><b>Summary:</b><ul>
<li>268 open issues, down by 37.</li>
<li>1922 closed issues, up by 40.</li>
<li>2190 issues total, up by 3.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 New issues: <a href="lwg-active.html#2592">2592</a>, <a href="lwg-active.html#2593">2593</a>, <a href="lwg-active.html#2594">2594</a>.</li>
<li>Changed the following 7 issues to Ready (from Review): <a href="lwg-defects.html#2181">2181</a>, <a href="lwg-defects.html#2309">2309</a>, <a href="lwg-defects.html#2310">2310</a>, <a href="lwg-defects.html#2328">2328</a>, <a href="lwg-defects.html#2393">2393</a>, <a href="lwg-defects.html#2441">2441</a>, <a href="lwg-defects.html#2516">2516</a>.</li>
<li>Changed the following 11 issues to Ready (from New): <a href="lwg-defects.html#2542">2542</a>, <a href="lwg-defects.html#2549">2549</a>, <a href="lwg-defects.html#2550">2550</a>, <a href="lwg-defects.html#2551">2551</a>, <a href="lwg-defects.html#2555">2555</a>, <a href="lwg-defects.html#2573">2573</a>, <a href="lwg-defects.html#2667">2667</a>, <a href="lwg-defects.html#2669">2669</a>, <a href="lwg-defects.html#2670">2670</a>, <a href="lwg-defects.html#2671">2671</a>, <a href="lwg-defects.html#2673">2673</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="lwg-defects.html#2426">2426</a>.</li>
<li>Changed the following 2 issues to Ready (from LEWG): <a href="lwg-defects.html#2436">2436</a>, <a href="lwg-defects.html#2451">2451</a>.</li>
<li>Changed the following issue to Open (from Review): <a href="lwg-active.html#2424">2424</a>.</li>
<li>Changed the following issue to Open (from New): <a href="lwg-active.html#2368">2368</a>.</li>
<li>Changed the following 3 issues to WP (from Ready): <a href="lwg-defects.html#2276">2276</a>, <a href="lwg-defects.html#2523">2523</a>, <a href="lwg-defects.html#2537">2537</a>.</li>
<li>Changed the following 25 issues to WP (from Tentatively Ready): <a href="lwg-defects.html#2192">2192</a>, <a href="lwg-defects.html#2450">2450</a>, <a href="lwg-defects.html#2520">2520</a>, <a href="lwg-defects.html#2522">2522</a>, <a href="lwg-defects.html#2539">2539</a>, <a href="lwg-defects.html#2545">2545</a>, <a href="lwg-defects.html#2557">2557</a>, <a href="lwg-defects.html#2558">2558</a>, <a href="lwg-defects.html#2559">2559</a>, <a href="lwg-defects.html#2560">2560</a>, <a href="lwg-defects.html#2565">2565</a>, <a href="lwg-defects.html#2566">2566</a>, <a href="lwg-defects.html#2571">2571</a>, <a href="lwg-defects.html#2572">2572</a>, <a href="lwg-defects.html#2574">2574</a>, <a href="lwg-defects.html#2575">2575</a>, <a href="lwg-defects.html#2576">2576</a>, <a href="lwg-defects.html#2577">2577</a>, <a href="lwg-defects.html#2579">2579</a>, <a href="lwg-defects.html#2581">2581</a>, <a href="lwg-defects.html#2582">2582</a>, <a href="lwg-defects.html#2583">2583</a>, <a href="lwg-defects.html#2585">2585</a>, <a href="lwg-defects.html#2586">2586</a>, <a href="lwg-defects.html#2590">2590</a>.</li>
<li>Changed the following issue to WP (from Review): <a href="lwg-defects.html#2296">2296</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="lwg-defects.html#2554">2554</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="lwg-defects.html#2456">2456</a>.</li>
<li>Changed the following issue to NAD Editorial (from New): <a href="lwg-closed.html#2666">2666</a>.</li>
<li>Changed the following issue to NAD (from Review): <a href="lwg-closed.html#2402">2402</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="lwg-closed.html#2553">2553</a>.</li>
<li>Changed the following issue to NAD (from LEWG): <a href="lwg-closed.html#2372">2372</a>.</li>
<li>Changed the following 2 issues to NAD Arrays (from Ready): <a href="lwg-closed.html#2253">2253</a>, <a href="lwg-closed.html#2255">2255</a>.</li>
<li>Changed the following 3 issues to NAD Arrays (from Open): <a href="lwg-closed.html#2254">2254</a>, <a href="lwg-closed.html#2264">2264</a>, <a href="lwg-closed.html#2277">2277</a>.</li>
</ul></li>
</ul>
</li>
<li>R96: 
2016-02-12 2016 pre-Jacksonville mailing (includes the FS TS bugs for the first time)
<ul>
<li><b>Summary:</b><ul>
<li>305 open issues, up by 48.</li>
<li>1882 closed issues, up by 63.</li>
<li>2187 issues total, up by 111.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 19 Tentatively Ready issues: <a href="lwg-defects.html#2557">2557</a>, <a href="lwg-defects.html#2558">2558</a>, <a href="lwg-defects.html#2559">2559</a>, <a href="lwg-defects.html#2560">2560</a>, <a href="lwg-defects.html#2565">2565</a>, <a href="lwg-defects.html#2566">2566</a>, <a href="lwg-defects.html#2571">2571</a>, <a href="lwg-defects.html#2572">2572</a>, <a href="lwg-defects.html#2574">2574</a>, <a href="lwg-defects.html#2575">2575</a>, <a href="lwg-defects.html#2576">2576</a>, <a href="lwg-defects.html#2577">2577</a>, <a href="lwg-defects.html#2579">2579</a>, <a href="lwg-defects.html#2581">2581</a>, <a href="lwg-defects.html#2582">2582</a>, <a href="lwg-defects.html#2583">2583</a>, <a href="lwg-defects.html#2585">2585</a>, <a href="lwg-defects.html#2586">2586</a>, <a href="lwg-defects.html#2590">2590</a>.</li>
<li>Added the following 30 New issues: <a href="lwg-defects.html#2554">2554</a>, <a href="lwg-defects.html#2555">2555</a>, <a href="lwg-active.html#2556">2556</a>, <a href="lwg-active.html#2561">2561</a>, <a href="lwg-active.html#2562">2562</a>, <a href="lwg-active.html#2563">2563</a>, <a href="lwg-active.html#2564">2564</a>, <a href="lwg-active.html#2567">2567</a>, <a href="lwg-active.html#2568">2568</a>, <a href="lwg-active.html#2569">2569</a>, <a href="lwg-active.html#2570">2570</a>, <a href="lwg-defects.html#2573">2573</a>, <a href="lwg-active.html#2578">2578</a>, <a href="lwg-active.html#2584">2584</a>, <a href="lwg-active.html#2587">2587</a>, <a href="lwg-active.html#2588">2588</a>, <a href="lwg-active.html#2589">2589</a>, <a href="lwg-active.html#2591">2591</a>, <a href="lwg-active.html#2663">2663</a>, <a href="lwg-active.html#2664">2664</a>, <a href="lwg-active.html#2665">2665</a>, <a href="lwg-closed.html#2666">2666</a>, <a href="lwg-defects.html#2667">2667</a>, <a href="lwg-active.html#2668">2668</a>, <a href="lwg-defects.html#2669">2669</a>, <a href="lwg-defects.html#2670">2670</a>, <a href="lwg-defects.html#2671">2671</a>, <a href="lwg-active.html#2672">2672</a>, <a href="lwg-defects.html#2673">2673</a>, <a href="lwg-defects.html#2674">2674</a>.</li>
<li>Added the following 3 NAD Future issues: <a href="lwg-closed.html#2611">2611</a>, <a href="lwg-closed.html#2612">2612</a>, <a href="lwg-closed.html#2654">2654</a>.</li>
<li>Added the following 41 WP issues: <a href="lwg-defects.html#2601">2601</a>, <a href="lwg-defects.html#2602">2602</a>, <a href="lwg-defects.html#2603">2603</a>, <a href="lwg-defects.html#2605">2605</a>, <a href="lwg-defects.html#2606">2606</a>, <a href="lwg-defects.html#2607">2607</a>, <a href="lwg-defects.html#2608">2608</a>, <a href="lwg-defects.html#2609">2609</a>, <a href="lwg-defects.html#2614">2614</a>, <a href="lwg-defects.html#2615">2615</a>, <a href="lwg-defects.html#2616">2616</a>, <a href="lwg-defects.html#2618">2618</a>, <a href="lwg-defects.html#2619">2619</a>, <a href="lwg-defects.html#2621">2621</a>, <a href="lwg-defects.html#2622">2622</a>, <a href="lwg-defects.html#2624">2624</a>, <a href="lwg-defects.html#2625">2625</a>, <a href="lwg-defects.html#2627">2627</a>, <a href="lwg-defects.html#2629">2629</a>, <a href="lwg-defects.html#2632">2632</a>, <a href="lwg-defects.html#2633">2633</a>, <a href="lwg-defects.html#2634">2634</a>, <a href="lwg-defects.html#2635">2635</a>, <a href="lwg-defects.html#2636">2636</a>, <a href="lwg-defects.html#2637">2637</a>, <a href="lwg-defects.html#2640">2640</a>, <a href="lwg-defects.html#2641">2641</a>, <a href="lwg-defects.html#2644">2644</a>, <a href="lwg-defects.html#2645">2645</a>, <a href="lwg-defects.html#2647">2647</a>, <a href="lwg-defects.html#2648">2648</a>, <a href="lwg-defects.html#2649">2649</a>, <a href="lwg-defects.html#2650">2650</a>, <a href="lwg-defects.html#2652">2652</a>, <a href="lwg-defects.html#2653">2653</a>, <a href="lwg-defects.html#2655">2655</a>, <a href="lwg-defects.html#2656">2656</a>, <a href="lwg-defects.html#2657">2657</a>, <a href="lwg-defects.html#2658">2658</a>, <a href="lwg-defects.html#2660">2660</a>, <a href="lwg-defects.html#2662">2662</a>.</li>
<li>Added the following 2 NAD Editorial issues: <a href="lwg-closed.html#2639">2639</a>, <a href="lwg-closed.html#2659">2659</a>.</li>
<li>Added the following 14 NAD issues: <a href="lwg-closed.html#2580">2580</a>, <a href="lwg-closed.html#2604">2604</a>, <a href="lwg-closed.html#2610">2610</a>, <a href="lwg-closed.html#2613">2613</a>, <a href="lwg-closed.html#2617">2617</a>, <a href="lwg-closed.html#2623">2623</a>, <a href="lwg-closed.html#2626">2626</a>, <a href="lwg-closed.html#2628">2628</a>, <a href="lwg-closed.html#2630">2630</a>, <a href="lwg-closed.html#2631">2631</a>, <a href="lwg-closed.html#2638">2638</a>, <a href="lwg-closed.html#2642">2642</a>, <a href="lwg-closed.html#2646">2646</a>, <a href="lwg-closed.html#2661">2661</a>.</li>
<li>Added the following 2 Dup issues: <a href="lwg-closed.html#2643">2643</a>, <a href="lwg-closed.html#2651">2651</a>.</li>
<li>Changed the following issue to Tentatively Ready (from New): <a href="lwg-defects.html#2545">2545</a>.</li>
<li>Changed the following 2 issues to Review (from Open): <a href="lwg-defects.html#2310">2310</a>, <a href="lwg-defects.html#2516">2516</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="lwg-closed.html#2552">2552</a>.</li>
</ul></li>
</ul>
</li>
<li>R95: 
2015-11-15 2015 post-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>257 open issues, down by 37.</li>
<li>1819 closed issues, up by 47.</li>
<li>2076 issues total, up by 10.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 10 New issues: <a href="lwg-active.html#2544">2544</a>, <a href="lwg-defects.html#2545">2545</a>, <a href="lwg-active.html#2546">2546</a>, <a href="lwg-active.html#2547">2547</a>, <a href="lwg-active.html#2548">2548</a>, <a href="lwg-defects.html#2549">2549</a>, <a href="lwg-defects.html#2550">2550</a>, <a href="lwg-defects.html#2551">2551</a>, <a href="lwg-closed.html#2552">2552</a>, <a href="lwg-closed.html#2553">2553</a>.</li>
<li>Changed the following 2 issues to Ready (from New): <a href="lwg-defects.html#2523">2523</a>, <a href="lwg-defects.html#2537">2537</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="lwg-defects.html#2276">2276</a>.</li>
<li>Changed the following 3 issues to Tentatively Ready (from New): <a href="lwg-defects.html#2520">2520</a>, <a href="lwg-defects.html#2522">2522</a>, <a href="lwg-defects.html#2539">2539</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="lwg-defects.html#2192">2192</a>, <a href="lwg-defects.html#2450">2450</a>.</li>
<li>Changed the following issue to Review (from Ready): <a href="lwg-defects.html#2181">2181</a>.</li>
<li>Changed the following 4 issues to Review (from Open): <a href="lwg-defects.html#2309">2309</a>, <a href="lwg-defects.html#2393">2393</a>, <a href="lwg-closed.html#2402">2402</a>, <a href="lwg-defects.html#2441">2441</a>.</li>
<li>Changed the following issue to Open (from Tentatively Ready): <a href="lwg-active.html#2510">2510</a>.</li>
<li>Changed the following 10 issues to Open (from New): <a href="lwg-active.html#2117">2117</a>, <a href="lwg-active.html#2164">2164</a>, <a href="lwg-active.html#2290">2290</a>, <a href="lwg-active.html#2468">2468</a>, <a href="lwg-active.html#2499">2499</a>, <a href="lwg-active.html#2505">2505</a>, <a href="lwg-defects.html#2509">2509</a>, <a href="lwg-defects.html#2516">2516</a>, <a href="lwg-active.html#2524">2524</a>, <a href="lwg-active.html#2543">2543</a>.</li>
<li>Changed the following issue to SG1 (from New): <a href="lwg-active.html#2533">2533</a>.</li>
<li>Changed the following 35 issues to WP (from Ready): <a href="lwg-defects.html#1169">1169</a>, <a href="lwg-defects.html#2072">2072</a>, <a href="lwg-defects.html#2101">2101</a>, <a href="lwg-defects.html#2111">2111</a>, <a href="lwg-defects.html#2119">2119</a>, <a href="lwg-defects.html#2127">2127</a>, <a href="lwg-defects.html#2133">2133</a>, <a href="lwg-defects.html#2156">2156</a>, <a href="lwg-defects.html#2218">2218</a>, <a href="lwg-defects.html#2219">2219</a>, <a href="lwg-defects.html#2244">2244</a>, <a href="lwg-defects.html#2250">2250</a>, <a href="lwg-defects.html#2259">2259</a>, <a href="lwg-defects.html#2336">2336</a>, <a href="lwg-defects.html#2353">2353</a>, <a href="lwg-defects.html#2367">2367</a>, <a href="lwg-defects.html#2380">2380</a>, <a href="lwg-defects.html#2384">2384</a>, <a href="lwg-defects.html#2385">2385</a>, <a href="lwg-defects.html#2435">2435</a>, <a href="lwg-defects.html#2447">2447</a>, <a href="lwg-defects.html#2462">2462</a>, <a href="lwg-defects.html#2466">2466</a>, <a href="lwg-defects.html#2469">2469</a>, <a href="lwg-defects.html#2473">2473</a>, <a href="lwg-defects.html#2476">2476</a>, <a href="lwg-defects.html#2477">2477</a>, <a href="lwg-defects.html#2483">2483</a>, <a href="lwg-defects.html#2484">2484</a>, <a href="lwg-defects.html#2485">2485</a>, <a href="lwg-defects.html#2486">2486</a>, <a href="lwg-defects.html#2487">2487</a>, <a href="lwg-defects.html#2489">2489</a>, <a href="lwg-defects.html#2492">2492</a>, <a href="lwg-defects.html#2494">2494</a>.</li>
<li>Changed the following 8 issues to WP (from Tentatively Ready): <a href="lwg-defects.html#2224">2224</a>, <a href="lwg-defects.html#2234">2234</a>, <a href="lwg-defects.html#2273">2273</a>, <a href="lwg-defects.html#2495">2495</a>, <a href="lwg-defects.html#2500">2500</a>, <a href="lwg-defects.html#2515">2515</a>, <a href="lwg-defects.html#2517">2517</a>, <a href="lwg-defects.html#2526">2526</a>.</li>
<li>Changed the following issue to Resolved (from Core): <a href="lwg-defects.html#2165">2165</a>.</li>
<li>Changed the following 2 issues to NAD (from New): <a href="lwg-closed.html#2474">2474</a>, <a href="lwg-closed.html#2538">2538</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="lwg-closed.html#2379">2379</a>.</li>
<li>Changed the following issue to NAD (from Resolved): <a href="lwg-closed.html#2319">2319</a>.</li>
</ul></li>
</ul>
</li>
<li>R94: 
2015-09-25 2015 pre-Kona mailing
<ul>
<li><b>Summary:</b><ul>
<li>294 open issues, up by 38.</li>
<li>1772 closed issues, up by 2.</li>
<li>2066 issues total, up by 40.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 4 Tentatively Ready issues: <a href="lwg-active.html#2510">2510</a>, <a href="lwg-defects.html#2515">2515</a>, <a href="lwg-defects.html#2517">2517</a>, <a href="lwg-defects.html#2526">2526</a>.</li>
<li>Added the following 36 New issues: <a href="lwg-active.html#2504">2504</a>, <a href="lwg-active.html#2505">2505</a>, <a href="lwg-active.html#2506">2506</a>, <a href="lwg-active.html#2507">2507</a>, <a href="lwg-active.html#2508">2508</a>, <a href="lwg-defects.html#2509">2509</a>, <a href="lwg-active.html#2511">2511</a>, <a href="lwg-active.html#2512">2512</a>, <a href="lwg-active.html#2513">2513</a>, <a href="lwg-active.html#2514">2514</a>, <a href="lwg-defects.html#2516">2516</a>, <a href="lwg-active.html#2518">2518</a>, <a href="lwg-active.html#2519">2519</a>, <a href="lwg-defects.html#2520">2520</a>, <a href="lwg-active.html#2521">2521</a>, <a href="lwg-defects.html#2522">2522</a>, <a href="lwg-defects.html#2523">2523</a>, <a href="lwg-active.html#2524">2524</a>, <a href="lwg-active.html#2525">2525</a>, <a href="lwg-active.html#2527">2527</a>, <a href="lwg-active.html#2528">2528</a>, <a href="lwg-active.html#2529">2529</a>, <a href="lwg-active.html#2530">2530</a>, <a href="lwg-active.html#2531">2531</a>, <a href="lwg-active.html#2532">2532</a>, <a href="lwg-active.html#2533">2533</a>, <a href="lwg-active.html#2534">2534</a>, <a href="lwg-closed.html#2535">2535</a>, <a href="lwg-active.html#2536">2536</a>, <a href="lwg-defects.html#2537">2537</a>, <a href="lwg-closed.html#2538">2538</a>, <a href="lwg-defects.html#2539">2539</a>, <a href="lwg-active.html#2540">2540</a>, <a href="lwg-active.html#2541">2541</a>, <a href="lwg-defects.html#2542">2542</a>, <a href="lwg-active.html#2543">2543</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="lwg-defects.html#2495">2495</a>, <a href="lwg-defects.html#2500">2500</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from Open): <a href="lwg-defects.html#2234">2234</a>, <a href="lwg-defects.html#2273">2273</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="lwg-defects.html#2051">2051</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="lwg-closed.html#2326">2326</a>.</li>
</ul></li>
</ul>
</li>
<li>R93: 
2014-05-22 2015 post-Lenexa mailing
<ul>
<li><b>Summary:</b><ul>
<li>256 open issues, down by 36.</li>
<li>1770 closed issues, up by 48.</li>
<li>2026 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 2 Ready issues: <a href="lwg-defects.html#2492">2492</a>, <a href="lwg-defects.html#2494">2494</a>.</li>
<li>Added the following 10 New issues: <a href="lwg-active.html#2493">2493</a>, <a href="lwg-defects.html#2495">2495</a>, <a href="lwg-active.html#2496">2496</a>, <a href="lwg-active.html#2497">2497</a>, <a href="lwg-active.html#2498">2498</a>, <a href="lwg-active.html#2499">2499</a>, <a href="lwg-defects.html#2500">2500</a>, <a href="lwg-active.html#2501">2501</a>, <a href="lwg-active.html#2502">2502</a>, <a href="lwg-active.html#2503">2503</a>.</li>
<li>Changed the following 2 issues to Ready (from Review): <a href="lwg-defects.html#2111">2111</a>, <a href="lwg-defects.html#2380">2380</a>.</li>
<li>Changed the following 20 issues to Ready (from New): <a href="lwg-defects.html#2244">2244</a>, <a href="lwg-defects.html#2250">2250</a>, <a href="lwg-defects.html#2259">2259</a>, <a href="lwg-defects.html#2336">2336</a>, <a href="lwg-defects.html#2353">2353</a>, <a href="lwg-defects.html#2367">2367</a>, <a href="lwg-defects.html#2384">2384</a>, <a href="lwg-defects.html#2385">2385</a>, <a href="lwg-defects.html#2435">2435</a>, <a href="lwg-defects.html#2462">2462</a>, <a href="lwg-defects.html#2466">2466</a>, <a href="lwg-defects.html#2473">2473</a>, <a href="lwg-defects.html#2476">2476</a>, <a href="lwg-defects.html#2477">2477</a>, <a href="lwg-defects.html#2483">2483</a>, <a href="lwg-defects.html#2484">2484</a>, <a href="lwg-defects.html#2485">2485</a>, <a href="lwg-defects.html#2486">2486</a>, <a href="lwg-defects.html#2487">2487</a>, <a href="lwg-defects.html#2489">2489</a>.</li>
<li>Changed the following 12 issues to Ready (from Open): <a href="lwg-defects.html#1169">1169</a>, <a href="lwg-defects.html#2072">2072</a>, <a href="lwg-defects.html#2101">2101</a>, <a href="lwg-defects.html#2119">2119</a>, <a href="lwg-defects.html#2127">2127</a>, <a href="lwg-defects.html#2133">2133</a>, <a href="lwg-defects.html#2156">2156</a>, <a href="lwg-defects.html#2181">2181</a>, <a href="lwg-defects.html#2218">2218</a>, <a href="lwg-defects.html#2219">2219</a>, <a href="lwg-defects.html#2447">2447</a>, <a href="lwg-defects.html#2469">2469</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="lwg-defects.html#2224">2224</a>.</li>
<li>Changed the following issue to Review (from New): <a href="lwg-defects.html#2296">2296</a>.</li>
<li>Changed the following issue to Review (from Open): <a href="lwg-defects.html#2328">2328</a>.</li>
<li>Changed the following 11 issues to Open (from New): <a href="lwg-active.html#2262">2262</a>, <a href="lwg-active.html#2289">2289</a>, <a href="lwg-active.html#2338">2338</a>, <a href="lwg-active.html#2348">2348</a>, <a href="lwg-active.html#2349">2349</a>, <a href="lwg-active.html#2370">2370</a>, <a href="lwg-active.html#2398">2398</a>, <a href="lwg-closed.html#2402">2402</a>, <a href="lwg-defects.html#2422">2422</a>, <a href="lwg-defects.html#2450">2450</a>, <a href="lwg-defects.html#2456">2456</a>.</li>
<li>Changed the following 8 issues to Open (from SG1): <a href="lwg-active.html#2245">2245</a>, <a href="lwg-active.html#2265">2265</a>, <a href="lwg-defects.html#2276">2276</a>, <a href="lwg-defects.html#2309">2309</a>, <a href="lwg-active.html#2363">2363</a>, <a href="lwg-closed.html#2379">2379</a>, <a href="lwg-defects.html#2426">2426</a>, <a href="lwg-defects.html#2441">2441</a>.</li>
<li>Changed the following issue to LEWG (from New): <a href="lwg-closed.html#2372">2372</a>.</li>
<li>Changed the following issue to EWG (from New): <a href="lwg-active.html#2432">2432</a>.</li>
<li>Changed the following issue to Deferred (from Open): <a href="lwg-active.html#2202">2202</a>.</li>
<li>Changed the following 14 issues to WP (from Ready): <a href="lwg-defects.html#2160">2160</a>, <a href="lwg-defects.html#2168">2168</a>, <a href="lwg-defects.html#2364">2364</a>, <a href="lwg-defects.html#2403">2403</a>, <a href="lwg-defects.html#2406">2406</a>, <a href="lwg-defects.html#2411">2411</a>, <a href="lwg-defects.html#2425">2425</a>, <a href="lwg-defects.html#2427">2427</a>, <a href="lwg-defects.html#2428">2428</a>, <a href="lwg-defects.html#2433">2433</a>, <a href="lwg-defects.html#2434">2434</a>, <a href="lwg-defects.html#2438">2438</a>, <a href="lwg-defects.html#2439">2439</a>, <a href="lwg-defects.html#2440">2440</a>.</li>
<li>Changed the following 18 issues to WP (from Tentatively Ready): <a href="lwg-defects.html#2059">2059</a>, <a href="lwg-defects.html#2076">2076</a>, <a href="lwg-defects.html#2239">2239</a>, <a href="lwg-defects.html#2369">2369</a>, <a href="lwg-defects.html#2378">2378</a>, <a href="lwg-defects.html#2410">2410</a>, <a href="lwg-defects.html#2415">2415</a>, <a href="lwg-defects.html#2418">2418</a>, <a href="lwg-defects.html#2437">2437</a>, <a href="lwg-defects.html#2448">2448</a>, <a href="lwg-defects.html#2454">2454</a>, <a href="lwg-defects.html#2455">2455</a>, <a href="lwg-defects.html#2458">2458</a>, <a href="lwg-defects.html#2459">2459</a>, <a href="lwg-defects.html#2463">2463</a>, <a href="lwg-defects.html#2467">2467</a>, <a href="lwg-defects.html#2470">2470</a>, <a href="lwg-defects.html#2482">2482</a>.</li>
<li>Changed the following 3 issues to WP (from New): <a href="lwg-defects.html#2420">2420</a>, <a href="lwg-defects.html#2464">2464</a>, <a href="lwg-defects.html#2488">2488</a>.</li>
<li>Changed the following issue to WP (from Open): <a href="lwg-defects.html#2063">2063</a>.</li>
<li>Changed the following 2 issues to WP (from SG1): <a href="lwg-defects.html#2407">2407</a>, <a href="lwg-defects.html#2442">2442</a>.</li>
<li>Changed the following issue to Resolved (from Review): <a href="lwg-defects.html#2228">2228</a>.</li>
<li>Changed the following 3 issues to Resolved (from Open): <a href="lwg-defects.html#1526">1526</a>, <a href="lwg-defects.html#2274">2274</a>, <a href="lwg-defects.html#2397">2397</a>.</li>
<li>Changed the following 5 issues to NAD (from New): <a href="lwg-closed.html#2079">2079</a>, <a href="lwg-closed.html#2251">2251</a>, <a href="lwg-closed.html#2351">2351</a>, <a href="lwg-closed.html#2373">2373</a>, <a href="lwg-closed.html#2386">2386</a>.</li>
<li>Changed the following issue to NAD (from Open): <a href="lwg-closed.html#2388">2388</a>.</li>
</ul></li>
</ul>
</li>
<li>R92: 
2015-04-09 pre-Lenexa mailing
<ul>
<li><b>Summary:</b><ul>
<li>292 open issues, up by 33.</li>
<li>1722 closed issues, up by 0.</li>
<li>2014 issues total, up by 33.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 5 Tentatively Ready issues: <a href="lwg-defects.html#2459">2459</a>, <a href="lwg-defects.html#2463">2463</a>, <a href="lwg-defects.html#2467">2467</a>, <a href="lwg-defects.html#2470">2470</a>, <a href="lwg-defects.html#2482">2482</a>.</li>
<li>Added the following 27 New issues: <a href="lwg-active.html#2460">2460</a>, <a href="lwg-active.html#2461">2461</a>, <a href="lwg-defects.html#2462">2462</a>, <a href="lwg-defects.html#2464">2464</a>, <a href="lwg-active.html#2465">2465</a>, <a href="lwg-defects.html#2466">2466</a>, <a href="lwg-active.html#2468">2468</a>, <a href="lwg-active.html#2471">2471</a>, <a href="lwg-active.html#2472">2472</a>, <a href="lwg-defects.html#2473">2473</a>, <a href="lwg-closed.html#2474">2474</a>, <a href="lwg-active.html#2475">2475</a>, <a href="lwg-defects.html#2476">2476</a>, <a href="lwg-defects.html#2477">2477</a>, <a href="lwg-active.html#2478">2478</a>, <a href="lwg-active.html#2479">2479</a>, <a href="lwg-active.html#2480">2480</a>, <a href="lwg-active.html#2481">2481</a>, <a href="lwg-defects.html#2483">2483</a>, <a href="lwg-defects.html#2484">2484</a>, <a href="lwg-defects.html#2485">2485</a>, <a href="lwg-defects.html#2486">2486</a>, <a href="lwg-defects.html#2487">2487</a>, <a href="lwg-defects.html#2488">2488</a>, <a href="lwg-defects.html#2489">2489</a>, <a href="lwg-active.html#2490">2490</a>, <a href="lwg-active.html#2491">2491</a>.</li>
<li>Added the following Open issue: <a href="lwg-defects.html#2469">2469</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Review): <a href="lwg-defects.html#2378">2378</a>.</li>
<li>Changed the following 11 issues to Tentatively Ready (from New): <a href="lwg-defects.html#2076">2076</a>, <a href="lwg-defects.html#2239">2239</a>, <a href="lwg-defects.html#2369">2369</a>, <a href="lwg-defects.html#2410">2410</a>, <a href="lwg-defects.html#2415">2415</a>, <a href="lwg-defects.html#2418">2418</a>, <a href="lwg-defects.html#2437">2437</a>, <a href="lwg-defects.html#2448">2448</a>, <a href="lwg-defects.html#2454">2454</a>, <a href="lwg-defects.html#2455">2455</a>, <a href="lwg-defects.html#2458">2458</a>.</li>
<li>Changed the following issue to Tentatively Ready (from Open): <a href="lwg-defects.html#2059">2059</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="lwg-active.html#2337">2337</a>.</li>
<li>Changed the following issue to Tentatively NAD (from Open): <a href="lwg-active.html#760">760</a>.</li>
<li>Changed the following 5 issues to Open (from New): <a href="lwg-defects.html#2312">2312</a>, <a href="lwg-closed.html#2388">2388</a>, <a href="lwg-defects.html#2393">2393</a>, <a href="lwg-active.html#2444">2444</a>, <a href="lwg-defects.html#2447">2447</a>.</li>
<li>Changed the following 4 issues to LEWG (from New): <a href="lwg-active.html#2391">2391</a>, <a href="lwg-active.html#2417">2417</a>, <a href="lwg-defects.html#2436">2436</a>, <a href="lwg-defects.html#2451">2451</a>.</li>
<li>Changed the following issue to EWG (from Open): <a href="lwg-active.html#2089">2089</a>.</li>
<li>Changed the following issue to Core (from New): <a href="lwg-active.html#2452">2452</a>.</li>
<li>Changed the following 13 issues to SG1 (from New): <a href="lwg-active.html#2236">2236</a>, <a href="lwg-active.html#2245">2245</a>, <a href="lwg-active.html#2265">2265</a>, <a href="lwg-defects.html#2276">2276</a>, <a href="lwg-defects.html#2309">2309</a>, <a href="lwg-active.html#2334">2334</a>, <a href="lwg-active.html#2363">2363</a>, <a href="lwg-closed.html#2379">2379</a>, <a href="lwg-defects.html#2407">2407</a>, <a href="lwg-active.html#2412">2412</a>, <a href="lwg-defects.html#2426">2426</a>, <a href="lwg-defects.html#2442">2442</a>, <a href="lwg-active.html#2445">2445</a>.</li>
<li>Changed the following issue to SG1 (from Open): <a href="lwg-defects.html#2441">2441</a>.</li>
</ul></li>
</ul>
</li>
<li>R91: 
2014-11-23 post-Urbana mailing
<ul>
<li><b>Summary:</b><ul>
<li>259 open issues, up by 32.</li>
<li>1722 closed issues, down by 20.</li>
<li>1981 issues total, up by 12.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 12 New issues: <a href="lwg-defects.html#2447">2447</a>, <a href="lwg-defects.html#2448">2448</a>, <a href="lwg-active.html#2449">2449</a>, <a href="lwg-defects.html#2450">2450</a>, <a href="lwg-defects.html#2451">2451</a>, <a href="lwg-active.html#2452">2452</a>, <a href="lwg-active.html#2453">2453</a>, <a href="lwg-defects.html#2454">2454</a>, <a href="lwg-defects.html#2455">2455</a>, <a href="lwg-defects.html#2456">2456</a>, <a href="lwg-active.html#2457">2457</a>, <a href="lwg-defects.html#2458">2458</a>.</li>
<li>Changed the following 2 issues to Ready (from Review): <a href="lwg-defects.html#2160">2160</a>, <a href="lwg-defects.html#2364">2364</a>.</li>
<li>Changed the following 11 issues to Ready (from New): <a href="lwg-defects.html#2403">2403</a>, <a href="lwg-defects.html#2406">2406</a>, <a href="lwg-defects.html#2411">2411</a>, <a href="lwg-defects.html#2425">2425</a>, <a href="lwg-defects.html#2427">2427</a>, <a href="lwg-defects.html#2428">2428</a>, <a href="lwg-defects.html#2433">2433</a>, <a href="lwg-defects.html#2434">2434</a>, <a href="lwg-defects.html#2438">2438</a>, <a href="lwg-defects.html#2439">2439</a>, <a href="lwg-defects.html#2440">2440</a>.</li>
<li>Changed the following issue to Ready (from Open): <a href="lwg-defects.html#2168">2168</a>.</li>
<li>Changed the following issue to Review (from New): <a href="lwg-active.html#2424">2424</a>.</li>
<li>Changed the following 5 issues to Open (from New): <a href="lwg-active.html#2307">2307</a>, <a href="lwg-defects.html#2310">2310</a>, <a href="lwg-active.html#2383">2383</a>, <a href="lwg-active.html#2414">2414</a>, <a href="lwg-defects.html#2441">2441</a>.</li>
<li>Changed the following 2 issues to Open (from NAD Future): <a href="lwg-active.html#760">760</a>, <a href="lwg-active.html#1173">1173</a>.</li>
<li>Changed the following 4 issues to LEWG (from New): <a href="lwg-active.html#2419">2419</a>, <a href="lwg-active.html#2430">2430</a>, <a href="lwg-active.html#2443">2443</a>, <a href="lwg-active.html#2446">2446</a>.</li>
<li>Changed the following 48 issues to LEWG (from NAD Future): <a href="lwg-active.html#255">255</a>, <a href="lwg-active.html#423">423</a>, <a href="lwg-active.html#484">484</a>, <a href="lwg-active.html#523">523</a>, <a href="lwg-active.html#532">532</a>, <a href="lwg-active.html#708">708</a>, <a href="lwg-active.html#839">839</a>, <a href="lwg-active.html#851">851</a>, <a href="lwg-active.html#877">877</a>, <a href="lwg-active.html#933">933</a>, <a href="lwg-active.html#935">935</a>, <a href="lwg-active.html#936">936</a>, <a href="lwg-active.html#961">961</a>, <a href="lwg-active.html#1025">1025</a>, <a href="lwg-active.html#1031">1031</a>, <a href="lwg-active.html#1041">1041</a>, <a href="lwg-active.html#1052">1052</a>, <a href="lwg-active.html#1053">1053</a>, <a href="lwg-active.html#1112">1112</a>, <a href="lwg-active.html#1120">1120</a>, <a href="lwg-active.html#1121">1121</a>, <a href="lwg-active.html#1150">1150</a>, <a href="lwg-active.html#1154">1154</a>, <a href="lwg-active.html#1184">1184</a>, <a href="lwg-active.html#1188">1188</a>, <a href="lwg-active.html#1201">1201</a>, <a href="lwg-active.html#1203">1203</a>, <a href="lwg-active.html#1217">1217</a>, <a href="lwg-active.html#1235">1235</a>, <a href="lwg-active.html#1238">1238</a>, <a href="lwg-active.html#1242">1242</a>, <a href="lwg-active.html#1282">1282</a>, <a href="lwg-active.html#1289">1289</a>, <a href="lwg-active.html#1317">1317</a>, <a href="lwg-active.html#1320">1320</a>, <a href="lwg-active.html#1396">1396</a>, <a href="lwg-active.html#1406">1406</a>, <a href="lwg-active.html#1422">1422</a>, <a href="lwg-active.html#1459">1459</a>, <a href="lwg-active.html#1484">1484</a>, <a href="lwg-active.html#1488">1488</a>, <a href="lwg-active.html#1493">1493</a>, <a href="lwg-active.html#1499">1499</a>, <a href="lwg-active.html#1521">1521</a>, <a href="lwg-active.html#2040">2040</a>, <a href="lwg-active.html#2055">2055</a>, <a href="lwg-active.html#2226">2226</a>, <a href="lwg-active.html#2232">2232</a>.</li>
<li>Changed the following 2 issues to Pending NAD (from Tentatively NAD): <a href="lwg-closed.html#2302">2302</a>, <a href="lwg-closed.html#2382">2382</a>.</li>
<li>Changed the following 11 issues to WP (from Ready): <a href="lwg-defects.html#2016">2016</a>, <a href="lwg-defects.html#2170">2170</a>, <a href="lwg-defects.html#2340">2340</a>, <a href="lwg-defects.html#2354">2354</a>, <a href="lwg-defects.html#2377">2377</a>, <a href="lwg-defects.html#2396">2396</a>, <a href="lwg-defects.html#2399">2399</a>, <a href="lwg-defects.html#2400">2400</a>, <a href="lwg-defects.html#2401">2401</a>, <a href="lwg-defects.html#2404">2404</a>, <a href="lwg-defects.html#2408">2408</a>.</li>
<li>Changed the following 12 issues to WP (from Tentatively Ready): <a href="lwg-defects.html#2106">2106</a>, <a href="lwg-defects.html#2129">2129</a>, <a href="lwg-defects.html#2212">2212</a>, <a href="lwg-defects.html#2217">2217</a>, <a href="lwg-defects.html#2230">2230</a>, <a href="lwg-defects.html#2233">2233</a>, <a href="lwg-defects.html#2266">2266</a>, <a href="lwg-defects.html#2325">2325</a>, <a href="lwg-defects.html#2361">2361</a>, <a href="lwg-defects.html#2365">2365</a>, <a href="lwg-defects.html#2376">2376</a>, <a href="lwg-defects.html#2387">2387</a>.</li>
<li>Changed the following issue to Resolved (from Ready): <a href="lwg-closed.html#2319">2319</a>.</li>
<li>Changed the following issue to Resolved (from Review): <a href="lwg-defects.html#2118">2118</a>.</li>
<li>Changed the following issue to Resolved (from New): <a href="lwg-defects.html#2416">2416</a>.</li>
<li>Changed the following issue to Resolved (from Open): <a href="lwg-defects.html#2108">2108</a>.</li>
<li>Changed the following issue to NAD (from New): <a href="lwg-closed.html#2429">2429</a>.</li>
</ul></li>
</ul>
</li>
<li>R90: 
2014-10-13 pre-Urbana mailing
<ul>
<li><b>Summary:</b><ul>
<li>227 open issues, up by 31.</li>
<li>1742 closed issues, up by 0.</li>
<li>1969 issues total, up by 31.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 31 New issues: <a href="lwg-defects.html#2416">2416</a>, <a href="lwg-active.html#2417">2417</a>, <a href="lwg-defects.html#2418">2418</a>, <a href="lwg-active.html#2419">2419</a>, <a href="lwg-defects.html#2420">2420</a>, <a href="lwg-active.html#2421">2421</a>, <a href="lwg-defects.html#2422">2422</a>, <a href="lwg-active.html#2423">2423</a>, <a href="lwg-active.html#2424">2424</a>, <a href="lwg-defects.html#2425">2425</a>, <a href="lwg-defects.html#2426">2426</a>, <a href="lwg-defects.html#2427">2427</a>, <a href="lwg-defects.html#2428">2428</a>, <a href="lwg-closed.html#2429">2429</a>, <a href="lwg-active.html#2430">2430</a>, <a href="lwg-active.html#2431">2431</a>, <a href="lwg-active.html#2432">2432</a>, <a href="lwg-defects.html#2433">2433</a>, <a href="lwg-defects.html#2434">2434</a>, <a href="lwg-defects.html#2435">2435</a>, <a href="lwg-defects.html#2436">2436</a>, <a href="lwg-defects.html#2437">2437</a>, <a href="lwg-defects.html#2438">2438</a>, <a href="lwg-defects.html#2439">2439</a>, <a href="lwg-defects.html#2440">2440</a>, <a href="lwg-defects.html#2441">2441</a>, <a href="lwg-defects.html#2442">2442</a>, <a href="lwg-active.html#2443">2443</a>, <a href="lwg-active.html#2444">2444</a>, <a href="lwg-active.html#2445">2445</a>, <a href="lwg-active.html#2446">2446</a>.</li>
<li>No issues changed.</li>
</ul></li>
</ul>
</li>
<li>R89: 
2014-07-08 post-Rapperswil mailing
<ul>
<li><b>Summary:</b><ul>
<li>196 open issues, up by 14.</li>
<li>1742 closed issues, up by 12.</li>
<li>1938 issues total, up by 26.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 6 Ready issues: <a href="lwg-defects.html#2396">2396</a>, <a href="lwg-defects.html#2399">2399</a>, <a href="lwg-defects.html#2400">2400</a>, <a href="lwg-defects.html#2401">2401</a>, <a href="lwg-defects.html#2404">2404</a>, <a href="lwg-defects.html#2408">2408</a>.</li>
<li>Added the following 15 New issues: <a href="lwg-active.html#2391">2391</a>, <a href="lwg-active.html#2392">2392</a>, <a href="lwg-defects.html#2393">2393</a>, <a href="lwg-active.html#2394">2394</a>, <a href="lwg-active.html#2398">2398</a>, <a href="lwg-closed.html#2402">2402</a>, <a href="lwg-defects.html#2403">2403</a>, <a href="lwg-defects.html#2406">2406</a>, <a href="lwg-defects.html#2407">2407</a>, <a href="lwg-defects.html#2410">2410</a>, <a href="lwg-defects.html#2411">2411</a>, <a href="lwg-active.html#2412">2412</a>, <a href="lwg-active.html#2413">2413</a>, <a href="lwg-active.html#2414">2414</a>, <a href="lwg-defects.html#2415">2415</a>.</li>
<li>Added the following Open issue: <a href="lwg-defects.html#2397">2397</a>.</li>
<li>Added the following 3 WP issues: <a href="lwg-defects.html#2390">2390</a>, <a href="lwg-defects.html#2395">2395</a>, <a href="lwg-defects.html#2409">2409</a>.</li>
<li>Added the following NAD issue: <a href="lwg-closed.html#2405">2405</a>.</li>
<li>Changed the following issue to Ready (from New): <a href="lwg-defects.html#2377">2377</a>.</li>
<li>Changed the following 2 issues to Ready (from Deferred): <a href="lwg-closed.html#2253">2253</a>, <a href="lwg-closed.html#2255">2255</a>.</li>
<li>Changed the following 2 issues to Tentatively Ready (from New): <a href="lwg-defects.html#2325">2325</a>, <a href="lwg-defects.html#2387">2387</a>.</li>
<li>Changed the following issue to Tentatively NAD (from New): <a href="lwg-closed.html#2382">2382</a>.</li>
<li>Changed the following 3 issues to Review (from New): <a href="lwg-defects.html#2364">2364</a>, <a href="lwg-defects.html#2378">2378</a>, <a href="lwg-defects.html#2380">2380</a>.</li>
<li>Changed the following 2 issues to Review (from Open): <a href="lwg-defects.html#2118">2118</a>, <a href="lwg-defects.html#2160">2160</a>.</li>
<li>Changed the following 3 issues to Open (from New): <a href="lwg-defects.html#2168">2168</a>, <a href="lwg-active.html#2238">2238</a>, <a href="lwg-defects.html#2273">2273</a>.</li>
<li>Changed the following 3 issues to Open (from Deferred): <a href="lwg-closed.html#2254">2254</a>, <a href="lwg-closed.html#2264">2264</a>, <a href="lwg-closed.html#2277">2277</a>.</li>
<li>Changed the following 3 issues to WP (from New): <a href="lwg-defects.html#2371">2371</a>, <a href="lwg-defects.html#2374">2374</a>, <a href="lwg-defects.html#2389">2389</a>.</li>
<li>Changed the following 4 issues to Resolved (from Deferred): <a href="lwg-defects.html#2282">2282</a>, <a href="lwg-defects.html#2283">2283</a>, <a href="lwg-defects.html#2287">2287</a>, <a href="lwg-defects.html#2333">2333</a>.</li>
<li>Changed the following issue to NAD (from Deferred): <a href="lwg-closed.html#2305">2305</a>.</li>
</ul></li>
</ul>
</li>
<li>R88: 
2014-05-24 pre-Rapperswil mailing
<ul>
<li><b>Summary:</b><ul>
<li>182 open issues, up by 29.</li>
<li>1730 closed issues, up by 0.</li>
<li>1912 issues total, up by 29.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following 3 Tentatively Ready issues: <a href="lwg-defects.html#2361">2361</a>, <a href="lwg-defects.html#2365">2365</a>, <a href="lwg-defects.html#2376">2376</a>.</li>
<li>Added the following 26 New issues: <a href="lwg-active.html#2362">2362</a>, <a href="lwg-active.html#2363">2363</a>, <a href="lwg-defects.html#2364">2364</a>, <a href="lwg-active.html#2366">2366</a>, <a href="lwg-defects.html#2367">2367</a>, <a href="lwg-active.html#2368">2368</a>, <a href="lwg-defects.html#2369">2369</a>, <a href="lwg-active.html#2370">2370</a>, <a href="lwg-defects.html#2371">2371</a>, <a href="lwg-closed.html#2372">2372</a>, <a href="lwg-closed.html#2373">2373</a>, <a href="lwg-defects.html#2374">2374</a>, <a href="lwg-active.html#2375">2375</a>, <a href="lwg-defects.html#2377">2377</a>, <a href="lwg-defects.html#2378">2378</a>, <a href="lwg-closed.html#2379">2379</a>, <a href="lwg-defects.html#2380">2380</a>, <a href="lwg-active.html#2381">2381</a>, <a href="lwg-closed.html#2382">2382</a>, <a href="lwg-active.html#2383">2383</a>, <a href="lwg-defects.html#2384">2384</a>, <a href="lwg-defects.html#2385">2385</a>, <a href="lwg-closed.html#2386">2386</a>, <a href="lwg-defects.html#2387">2387</a>, <a href="lwg-closed.html#2388">2388</a>, <a href="lwg-defects.html#2389">2389</a>.</li>
<li>Changed the following 5 issues to Tentatively Ready (from Open): <a href="lwg-defects.html#2106">2106</a>, <a href="lwg-defects.html#2129">2129</a>, <a href="lwg-defects.html#2212">2212</a>, <a href="lwg-defects.html#2230">2230</a>, <a href="lwg-defects.html#2233">2233</a>.</li>
</ul></li>
</ul>
</li>
</ul>

<h2><a name="Status"></a>Issue Status</h2>

  <p>Issues reported to the LWG transition through a variety of statuses,
  indicating their progress towards a resolution.  Typically, most issues
  will flow through the following stages.
  </p>

  <p><b><a name="New">New</a></b> - The issue has not yet been
  reviewed by the LWG. Any <b>Proposed Resolution</b> is purely a
  suggestion from the issue submitter, and should not be construed as
  the view of LWG.</p>

  <p><b><a name="Open">Open</a></b> - The LWG has discussed the issue
  but is not yet ready to move the issue forward. There are several
  possible reasons for open status:</p>
     <ul>
        <li>Consensus may have not yet have been reached as to how to deal
            with the issue.</li>
        <li>Informal consensus may have been reached, but the LWG awaits
            exact <b>Proposed Resolution</b> wording for review.</li>
        <li>The LWG wishes to consult additional technical experts before
            proceeding.</li>
        <li>The issue may require further study.</li>
     </ul>

  <p>A <b>Proposed Resolution</b> for an open issue is still not be
  construed as the view of LWG. Comments on the current state of
  discussions are often given at the end of open issues in an italic
  font. Such comments are for information only and should not be given
  undue importance.</p>

  <p><b><a name="Review">Review</a></b> - Exact wording of a
  <b>Proposed Resolution</b> is now available for review on an issue
  for which the LWG previously reached informal consensus.</p>

  <p><b><a name="Ready">Ready</a></b> - The LWG has reached consensus
  that the issue is a defect in the Standard, the <b>Proposed
  Resolution</b> is correct, and the issue is ready to forward to the
  full committee for further action as a Defect Report (DR).</p>

  <p>Typically, an issue must have a proposed resolution in the currently
  published issues list, whose wording does not change during LWG review, to
  move to the Ready status.</p>

  <p><b><a name="Voting">Voting</a></b> - This status should not be seen
  in a published issues list, but is a marker for use during meetings to
  indicate an issues was Ready in the pre-meeting mailing, the <b>Proposed
  Resolution</b> is correct, and the issue will be offered to the working
  group at the end of the current meeting to apply to the current working
  paper (WP) or to close in some other appropriate manner.  This easily
  distinguishes such issues from those moving to Ready status during the
  meeting itself, that should not be forwarded until the next meeting.  If
  the issue does not move forward, it should fall back to one of the other
  open states before the next list is published.</p>

  <p><b><a name="Immediate">Immediate</a></b> - This status should not be
  seen in a published issues list, but is a marker for use during meetings
  to indicate an issues was not Ready in the pre-meeting mailing, but the
  <b>Proposed Resolution</b> is correct, and the issue will be offered to
  the working group at the end of the current meeting to apply to the
  current working paper (WP) or to close in some other appropriate manner.
  This status is used only rarely, typically for fixes that are both small
  and obvious, and usually within a meeting of the expected publication of
  a revised standard.  If the issue does not move forward, it should fall
  back to one of the other open states before the next list is published.</p>

  <p>In addition, there are a few ways to categorise and issue that remains
  open to a resolution within the library, but is not actively being worked
  on.
  </p>

  <p><b><a name="Deferred">Deferred</a></b> - The LWG has discussed the issue,
  is not yet ready to move the issue forward, but neither does it deem the
  issue significant enough to delay publishing a standard or Technical Report.
  A typical deferred issue would be seeking to clarify wording that might be
  technically correct, but easily mis-read.</p>

  <p>A <b>Proposed Resolution</b> for a deferred issue is still not be
  construed as the view of LWG. Comments on the current state of
  discussions are often given at the end of open issues in an italic
  font. Such comments are for information only and should not be given
  undue importance.</p>

  <p><b><a name="Core">Core</a></b> - The LWG has discussed the issue, and feels
  that some key part of resolving the issue is better handled by a cleanup of
  the language in the Core part of the standard.  The issue is passed to the Core
  Working Group, which should ideally open a corresponding issue that can be
  linked from the library issue.  Such issues will be revisitted after Core have
  made (or declined to make) any changes.
  </p>

  <p><b><a name="EWG">EWG</a></b> - The LWG has discussed the issue, and wonder
  that some key part of resolving the issue is better handled by some (hopefully
  small) extension to the language.  The issue is passed to the Evolution Working
  Group, which should ideally open a corresponding issue that can be linked from
  the library issue.  Such issues will be revisitted after Evoltion have made (or
  declined to make) any recommendations.  Positive recommendations from EWG will
  often mean the issue transition to <i>Core</i> status while we wait for some
  proposed new feature to land in the working paper.
  </p>

  <p><b><a name="LEWG">LEWG</a></b> - The LWG has discussed the issue, and deemd
  the issue is either an extension, however small, or changes the library design
  in some fundamental way, and so has delegated the initial work to the Library
  Evolution Working Group.
  </p>

  <p>Ultimately, all issues should reach closure with one of the following statuses.
  </p>

  <p><b><a name="DR">DR</a></b> - (Defect Report) - The full WG21/PL22.16
  committee has voted to forward the issue to the Project Editor to be
  processed as a Potential Defect Report. The Project Editor reviews
  the issue, and then forwards it to the WG21 Convenor, who returns it
  to the full committee for final disposition. This issues list
  accords the status of DR to all these Defect Reports regardless of
  where they are in that process.</p>

  <p><b><a name="WP">WP</a></b> - (Working Paper) - The proposed resolution has not been
  accepted as a Technical Corrigendum, but the full WG21/PL22.16 committee has voted to
  apply the Defect Report's Proposed Resolution to the working paper.</p>

  <p><b><a name="C++14">C++14</a></b> - (C++ Standard, as revised for 2014) - The full
  WG21/PL22.16 committee has voted to accept the Defect Report's Proposed Resolution into
  the published 2014 revision to the C++ standard, ISO/IEC IS 14882:2014(E).</p>

   <p><b><a name="C++11">C++11</a></b> - (C++ Standard, as revised for 2011) - The full
  WG21/PL22.16 committee has voted to accept the Defect Report's Proposed Resolution into
  the published 2011 revision to the C++ standard, ISO/IEC IS 14882:2011(E).</p>

   <p><b><a name="CD1">CD1</a></b> - (Committee Draft 2008) - The full
  WG21/PL22.16 committee has voted to accept the Defect Report's Proposed
  Resolution into the Fall 2008 Committee Draft.</p>

  <p><b><a name="TC1">TC1</a></b> - (Technical Corrigenda 1) - The full
  WG21/PL22.16 committee has voted to accept the Defect Report's Proposed
  Resolution as a Technical Corrigenda.  Action on this issue is thus
  complete and no further action is possible under ISO rules.</p>

  <p><b><a name="TRDec">TRDec</a></b> - (Decimal TR defect) - The LWG has voted to
  accept the Defect Report's Proposed Resolution into the Decimal TR.  Action on this
  issue is thus complete and no further action is expected.</p>

  <p><b><a name="Resolved">Resolved</a></b> - The LWG has reached consensus
  that the issue is a defect in the Standard, but the resolution adopted to
  resolve the issue came via some other mechanism than this issue in the
  list - typically by applying a formal paper, occasionally as a side effect
  of consolidating several interacting issue resolutions into a single issue.</p>

  <p><b><a name="Dup">Dup</a></b> - The LWG has reached consensus that
  the issue is a duplicate of another issue, and will not be further
  dealt with. A <b>Rationale</b> identifies the duplicated issue's
  issue number.</p>

  <p><b><a name="NAD">NAD</a></b> - The LWG has reached consensus that
  the issue is not a defect in the Standard.</p>

  <p><b><a name="NAD Editorial">NAD Editorial</a></b> - The LWG has reached consensus that
  the issue can either be handled editorially, or is handled by a paper (usually
  linked to in the rationale).</p>

  <p><b>Tentatively</b> - This is a <i>status qualifier</i>.  The issue has
  been reviewed online, or at an unofficial meeting, but not in an official meeting, and
  some support has been formed for the qualified status.  Tentatively qualified issues may
  be moved to the unqualified status and forwarded to full committee (if Ready) within the
  same meeting.  Unlike Ready issues, Tentatively Ready issues will be reviewed in
  subcommittee prior to forwarding to full committee.  When a status is qualified with
  Tentatively, the issue is still considered active.</p>

  <p><b>Pending</b> - This is a <i>status qualifier</i>.  When prepended to a status this
  indicates the issue has been processed by the committee, and a decision has been made to
  move the issue to the associated unqualified status.  However for logistical reasons the
  indicated outcome of the issue has not yet appeared in the latest working paper.</p>

  <p>The following statuses have been retired, but may show up on older issues lists.</p>

  <p><b><a name="NAD Future">NAD Future</a></b> - In addition to the regular status, the
  LWG believes that this issue should be revisited at the next revision of the standard.
  That is now an ongoing task managed by the Library Evolution Working Group, and most
  issues in this status were reopended with the status <a href="#NAD Editorial">LEWG</a>.
  </p>

  <p><b><a name="NAD Concepts">NAD Concepts</a></b> - This status reflects an evolution
  of the language during the development of C++11, where a new feature entered the
  language, called <i>concepts</i>, that fundamentally changed the way templates would
  be specified and written.  While this language feature was removed towards the end of
  the C++11 project, there is a clear intent to revisit this part of the language design.
  During that development, a number of issues were opened against the updated library
  related to use of that feature, or requesting fixes that would require explicit use of
  the concepts feature.  All such issues have been closed with this status, and may be
  revisitted should this or a similar language feature return for a future standard.</p>

  <p><b><a name="NAD Arrays">NAD Arrays</a></b> - This status reflects an evolution
  of the language during the development of C++14/17, where work on a Technical 
  Specification, called the <i>Arrays TS</i> was begun. In early 2016, this work was
  abandoned, and the work item was officially withdrawn.  During development of the TS,
  a number of issues were opened the features in the TS. All such issues have been closed
  with this status, and may be revisitted should this or a similar language feature
  return for a future standard.</p>

  <p>Issues are always given the status of <a href="lwg-active.html#New">New</a> when
  they first appear on the issues list. They may progress to
  <a href="lwg-active.html#Open">Open</a> or <a href="lwg-active.html#Review">Review</a>
  while the LWG is actively working on them. When the LWG has reached consensus on
  the disposition of an issue, the status will then change to
  <a href="lwg-active.html#Dup">Dup</a>, <a href="lwg-active.html#NAD">NAD</a>, or
  <a href="lwg-active.html#Ready">Ready</a> as appropriate.  Once the full PL22.16 committee
  votes to forward Ready issues to the Project Editor, they are given the status of Defect
  Report (<a href="lwg-active.html#DR">DR</a>). These in turn may become the basis for
  Technical Corrigenda (<a href="lwg-active.html#TC1">TC1</a>), an updated standard
  (<a href="lwg-defects.html#C++11">C++11</a>, <a href="lwg-defects.html#C++14">C++14</a>),
  or are closed without action other than a Record of Response
  (<a href="lwg-active.html#Resolved">Resolved</a>) where the desired effect has already
  been achieved by some other process.  The intent of this LWG process is that only issues
  which are truly defects in the Standard move to the formal ISO DR status.
  </p>


<h2>Active Issues</h2>
<hr>
<h3><a name="255" href="#255">255.</a> Why do <tt>basic_streambuf&lt;&gt;::pbump()</tt> and <tt>gbump()</tt> take an int?</h3>
<p><b>Section:</b> 27.6.3 [streambuf] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2000-08-12 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#streambuf">active issues</a> in [streambuf].</p>
<p><b>View all other</b> <a href="lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The basic_streambuf members gbump() and pbump() are specified to take an
int argument. This requirement prevents the functions from effectively
manipulating buffers larger than std::numeric_limits&lt;int&gt;::max()
characters. It also makes the common use case for these functions
somewhat difficult as many compilers will issue a warning when an
argument of type larger than int (such as ptrdiff_t on LLP64
architectures) is passed to either of the function. Since it's often the
result of the subtraction of two pointers that is passed to the
functions, a cast is necessary to silence such warnings. Finally, the
usage of a native type in the functions signatures is inconsistent with
other member functions (such as sgetn() and sputn()) that manipulate the
underlying character buffer. Those functions take a streamsize argument.
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is part of a bigger problem. If anyone cares enough, they should
write a paper solving the bigger problem of offset types in iostreams.
</p>
<p>
This is related to the paper about large file sizes. Beman has already
agreed to drop the section of that paper that deals with this.
</p>
<p>
int is big enough for reasonable buffers.
</p>
<p>
Move to NAD Future.
</p>
<p>
This is related to LWG <a href="lwg-active.html#423">423</a>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change the signatures of these functions in the synopsis of template
class basic_streambuf (27.5.2) and in their descriptions (27.5.2.3.1, p4
and 27.5.2.3.2, p4) to take a streamsize argument.
</p>

<p>
Although this change has the potential of changing the ABI of the
library, the change will affect only platforms where int is different
than the definition of streamsize. However, since both functions are
typically inline (they are on all known implementations), even on such
platforms the change will not affect any user code unless it explicitly
relies on the existing type of the functions (e.g., by taking their
address). Such a possibility is IMO quite remote.
</p>

<p>
Alternate Suggestion from Howard Hinnant, c++std-lib-7780:
</p>

<p>
This is something of a nit, but I'm wondering if streamoff wouldn't be a 
better choice than streamsize.  The argument to pbump and gbump MUST be 
signed.  But the standard has this to say about streamsize 
(27.4.1/2/Footnote):
</p>

<blockquote><p>
     [Footnote: streamsize is used in most places where ISO C would use
     size_t.  Most of the uses of streamsize could use size_t, except for
     the strstreambuf constructors, which require negative values. It
     should probably be the signed type corresponding to size_t (which is
     what Posix.2 calls ssize_t). &mdash; end footnote]
</p></blockquote>

<p>
This seems a little weak for the argument to pbump and gbump.  Should we 
ever really get rid of strstream, this footnote might go with it, along 
with the reason to make streamsize signed.
</p>


<p><b>Rationale:</b></p>
<p>The LWG believes this change is too big for now.  We may wish to
reconsider this for a future revision of the standard.  One
possibility is overloading pbump, rather than changing the
signature.</p>
<p><i>[
[2006-05-04: Reopened at the request of Chris (Krzysztof &#379;elechowski)]
]</i></p>





<hr>
<h3><a name="423" href="#423">423.</a> effects of negative streamsize in iostreams</h3>
<p><b>Section:</b> 27 [input.output] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2003-09-18 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#input.output">issues</a> in [input.output].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
A third party test suite tries to exercise istream::ignore(N) with
a negative value of N and expects that the implementation will treat
N as if it were 0. Our implementation asserts that (N >= 0) holds and
aborts the test.
</p>

<p>
I can't find anything in section 27 that prohibits such values but I don't
see what the effects of such calls should be, either (this applies to
a number of unformatted input functions as well as some member functions
of the basic_streambuf template).
</p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
This is related to LWG <a href="lwg-active.html#255">255</a>.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
I propose that we add to each function in clause 27 that takes an argument,
say N, of type streamsize a Requires clause saying that "N >= 0." The intent
is to allow negative streamsize values in calls to precision() and width()
but disallow it in calls to streambuf::sgetn(), istream::ignore(), or
ostream::write().
</p>

<p><i>[Kona: The LWG agreed that this is probably what we want.  However, we
  need a review to find all places where functions in clause 27 take
  arguments of type streamsize that shouldn't be allowed to go
  negative.  Martin will do that review.]</i></p>






<hr>
<h3><a name="484" href="#484">484.</a> Convertible to <tt>T</tt></h3>
<p><b>Section:</b> 24.2.3 [input.iterators] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2004-09-16 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#input.iterators">issues</a> in [input.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>From comp.std.c++:</p>

<p>
I note that given an input iterator a for type <tt>T</tt>, 
then <tt>*a</tt> only has to be "convertable to <tt>T</tt>", 
not actually of type <tt>T</tt>.
</p>

<p>Firstly, I can't seem to find an exact definition of "convertable to <tt>T</tt>". 
While I assume it is the obvious definition (an implicit conversion), I 
can't find an exact definition. Is there one?</p>

<p>Slightly more worryingly, there doesn't seem to be any restriction on 
the this type, other than it is "convertable to <tt>T</tt>". Consider two input 
iterators <tt>a</tt> and <tt>b</tt>. I would personally assume that most people would 
expect <tt>*a==*b</tt> would perform <tt>T(*a)==T(*b)</tt>, however it doesn't seem that 
the standard requires that, and that whatever type <tt>*a</tt> is (call it <tt>U</tt>) 
could have == defined on it with totally different symantics and still 
be a valid inputer iterator.</p>

<p>Is this a correct reading? When using input iterators should I write 
<tt>T(*a)</tt> all over the place to be sure that the object I'm using is the 
class I expect?</p>

<p>This is especially a nuisance for operations that are defined to be
  "convertible to <tt>bool</tt>".  (This is probably allowed so that
  implementations could return say an <tt>int</tt> and avoid an unnessary
  conversion. However all implementations I have seen simply return a
  <tt>bool</tt> anyway.  Typical implemtations of STL algorithms just write
  things like <tt>while(a!=b &amp;&amp; *a!=0)</tt>.  But strictly
  speaking, there are lots of types that are convertible to <tt>T</tt> but
  that also overload the appropriate operators so this doesn't behave
  as expected.</p>

<p>If we want to make code like this legal (which most people seem to
  expect), then we'll need to tighten up what we mean by "convertible
  to <tt>T</tt>".</p>

<p><i>[Lillehammer: The first part is NAD, since "convertible" is
 well-defined in core. The second part is basically about pathological
 overloads. It's a minor problem but a real one. So leave open for
 now, hope we solve it as part of iterator redesign.]</i></p>


<p><i>[
2009-07-28 Reopened by Alisdair. No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD Future. We agree there's an issue, but there is no
proposed solution at this time and this will be solved by concepts in
the future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2758.pdf">N2758</a>.
</p></blockquote>





<hr>
<h3><a name="523" href="#523">523.</a> regex case-insensitive character ranges are unimplementable as specified</h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2005-07-01 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re">active issues</a> in [re].</p>
<p><b>View all other</b> <a href="lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A problem with TR1 regex is currently being discussed on the Boost 
developers list. It involves the handling of case-insensitive matching 
of character ranges such as [Z-a]. The proper behavior (according to the 
ECMAScript standard) is unimplementable given the current specification 
of the TR1 regex_traits&lt;&gt; class template. John Maddock, the author of 
the TR1 regex proposal, agrees there is a problem. The full discussion 
can be found at http://lists.boost.org/boost/2005/06/28850.php (first 
message copied below). We don't have any recommendations as yet.
</p>
<p>
-- Begin original message --
</p>
<p>
The situation of interest is described in the ECMAScript specification
(ECMA-262), section 15.10.2.15:
</p>
<p>
"Even if the pattern ignores case, the case of the two ends of a range
is significant in determining which characters belong to the range.
Thus, for example, the pattern /[E-F]/i matches only the letters E, F,
e, and f, while the pattern /[E-f]/i matches all upper and lower-case
ASCII letters as well as the symbols [, \, ], ^, _, and `."
</p>
<p>
A more interesting case is what should happen when doing a
case-insentitive match on a range such as [Z-a]. It should match z, Z,
a, A and the symbols [, \, ], ^, _, and `. This is not what happens with
Boost.Regex (it throws an exception from the regex constructor).
</p>
<p>
The tough pill to swallow is that, given the specification in TR1, I
don't think there is any effective way to handle this situation.
According to the spec, case-insensitivity is handled with
regex_traits&lt;&gt;::translate_nocase(CharT) -- two characters are equivalent
if they compare equal after both are sent through the translate_nocase
function. But I don't see any way of using this translation function to
make character ranges case-insensitive. Consider the difficulty of
detecting whether "z" is in the range [Z-a]. Applying the transformation
to "z" has no effect (it is essentially std::tolower). And we're not
allowed to apply the transformation to the ends of the range, because as
ECMA-262 says, "the case of the two ends of a range is significant."
</p>
<p>
So AFAICT, TR1 regex is just broken, as is Boost.Regex. One possible fix
is to redefine translate_nocase to return a string_type containing all
the characters that should compare equal to the specified character. But
this function is hard to implement for Unicode, and it doesn't play nice
with the existing ctype facet. What a mess!
</p>
<p>
-- End original message --
</p>

<p><i>[
John Maddock adds:
]</i></p>


<p>
One small correction, I have since found that ICU's regex package does 
implement this correctly, using a similar mechanism to the current 
TR1.Regex.
</p>
<p>
Given an expression [c1-c2] that is compiled as case insensitive it:
</p>
<p>
Enumerates every character in the range c1 to c2 and converts it to it's 
case folded equivalent.  That case folded character is then used a key to a 
table of equivalence classes, and each member of the class is added to the 
list of possible matches supported by the character-class.  This second step 
isn't possible with our current traits class design, but isn't necessary if 
the input text is also converted to a case-folded equivalent on the fly.
</p>
<p>
ICU applies similar brute force mechanisms to character classes such as 
[[:lower:]] and [[:word:]], however these are at least cached, so the impact 
is less noticeable in this case.
</p>
<p>
Quick and dirty performance comparisons show that expressions such as 
"[X-\\x{fff0}]+" are indeed very slow to compile with ICU (about 200 times 
slower than a "normal" expression).  For an application that uses a lot of 
regexes this could have a noticeable performance impact.  ICU also has an 
advantage in that it knows the range of valid characters codes: code points 
outside that range are assumed not to require enumeration, as they can not 
be part of any equivalence class.  I presume that if we want the TR1.Regex 
to work with arbitrarily large character sets enumeration really does become 
impractical.
</p>
<p>
Finally note that Unicode has:
</p>
<p>
Three cases (upper, lower and title).
One to many, and many to one case transformations.
Character that have context sensitive case translations - for example an 
uppercase sigma has two different lowercase forms  - the form chosen depends 
on context(is it end of a word or not), a caseless match for an upper case 
sigma should match either of the lower case forms, which is why case folding 
is often approximated by tolower(toupper(c)).
</p>
<p>
Probably we need some way to enumerate character equivalence classes, 
including digraphs (either as a result or an input), and some way to tell 
whether the next character pair is a valid digraph in the current locale.
</p>
<p>
Hoping this doesn't make this even more complex that it was already,
</p>

<p><i>[
Portland:  Alisdair: Detect as invalid, throw an exception.
Pete: Possible general problem with case insensitive ranges.
]</i></p>


<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We agree that this is a problem, but we do not know the answer.
</p>
<p>
We are going to declare this NAD until existing practice leads us in some direction.
</p>
<p>
No objection to NAD Future.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="532" href="#532">532.</a> Tuple comparison</h3>
<p><b>Section:</b> 20.5.2.8 [tuple.rel], 99 [tr.tuple.rel] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2005-11-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#348">348</a></p>
<p><b>Discussion:</b></p>
<p>
Where possible, <tt>tuple</tt> comparison operators &lt;,&lt;=,=&gt;, and &gt; ought to be
defined in terms of <tt>std::less</tt> rather than <tt>operator&lt;</tt>, in order to
support comparison of tuples of pointers.  
</p>

<p><i>[
2009-07-28 Reopened by Alisdair.  No longer solved by concepts.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
If we solve this for <tt>tuple</tt> we would have to solve it for <tt>pair</tt>
algorithms, etc.  It is too late to do that at this time.  Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
change 6.1.3.5/5 from:
</p>

<blockquote><p>
  Returns: The result of a lexicographical comparison between t and
  u. The result is defined as: (bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) ||
  (!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for
  some tuple r is a tuple containing all but the first element of
  r. For any two zero-length tuples e and f, e &lt; f returns false.
</p></blockquote>

<p>
to:
</p>

<blockquote>
<p>
  Returns: The result of a lexicographical comparison between t and
  u. For any two zero-length tuples e and f, e &lt; f returns false.
  Otherwise, the result is defined as: cmp( get&lt;0&gt;(t), get&lt;0&gt;(u)) ||
  (!cmp(get&lt;0&gt;(u), get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail), where rtail for some
  tuple r is a tuple containing all but the first element of r, and
  cmp(x,y) is an unspecified function template defined as follows.
</p>
<p>
  Where T is the type of x and U is the type of y:
</p>

<p>
     if T and U are pointer types and T is convertible to U, returns
     less&lt;U&gt;()(x,y)
</p>

<p>
     otherwise, if T and U are pointer types, returns less&lt;T&gt;()(x,y)
</p>

<p>
     otherwise, returns (bool)(x &lt; y)
</p>
</blockquote>

<p><i>[
Berlin: This issue is much bigger than just tuple (pair, containers,
algorithms). Dietmar will survey and work up proposed wording.
]</i></p>




<p><b>Rationale:</b></p>
<p>
Recommend NAD.  This will be fixed with the next revision of concepts.
</p>

<p><i>[
San Francisco:
]</i></p>


<blockquote><p>
Solved by
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2770.pdf">N2770</a>.
</p></blockquote>





<hr>
<h3><a name="708" href="#708">708.</a> Locales need to be per thread and updated for POSIX changes</h3>
<p><b>Section:</b> 22 [localization] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2007-07-28 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#localization">issues</a> in [localization].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The POSIX "Extended API Set Part 4,"
</p>
<blockquote><p>
<a href="http://www.opengroup.org/sib/details.tpl?id=C065">http://www.opengroup.org/sib/details.tpl?id=C065</a>
</p></blockquote>
<p>
introduces extensions to the C locale mechanism that
allow multiple concurrent locales to be used in the same application
by introducing a type <tt>locale_t</tt> that is very similar to
<tt>std::locale</tt>, and a number of <tt>_l</tt> functions that make use of it.
</p>
<p>
The global locale (set by setlocale) is now specified to be per-
process. If a thread does not call <tt>uselocale</tt>, the global locale is
in effect for that thread. It can install a per-thread locale by
using <tt>uselocale</tt>.
</p>
<p>
There is also a nice <tt>querylocale</tt> mechanism by which one can obtain
the name (such as "de_DE") for a specific <tt>facet</tt>, even for combined
locales, with no <tt>std::locale</tt> equivalent.
</p>
<p>
<tt>std::locale</tt> should be harmonized with the new POSIX <tt>locale_t</tt>
mechanism and provide equivalents for <tt>uselocale</tt> and <tt>querylocale</tt>.
</p>

<p><i>[
Kona (2007): Bill and Nick to provide wording.
]</i></p>


<p><i>[
San Francisco: Bill and Nick still intend to provide wording, but this
is a part of the task to be addressed by the group that will look into
issue <a href="lwg-defects.html#860">860</a>.
]</i></p>


<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
It's our intention to stay in sync with WG14. If WG14 makes a decision
that requires a change in WG21 the issue will be reopened.
</p>
<p>
Move to NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="760" href="#760">760.</a> The emplace issue</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2007-11-11 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In an <tt>emplace</tt> member function the function parameter pack may be bound
to a priori unlimited number of objects: some or all of them can be
elements of the container itself. Apparently, in order to conform to the
blanket statement 23.2 [container.requirements]/11, the
implementation must check all of them for that possibility. A possible
solution can involve extending the exception in 23.2 [container.requirements]/12 also to the emplace member. As a
side note, the <tt>push_back</tt> and <tt>push_front</tt> member
functions are luckily not affected by this problem, can be efficiently
implemented anyway.
</p>

<p><i>[
Related to <a href="lwg-defects.html#767">767</a> and to <a href="lwg-active.html#2164">2164</a>
]</i></p>


<p><i>[
Bellevue:
]</i></p>


<blockquote>
<p>
The proposed addition (13) is partially redundant with the existing
paragraph 12. Why was the qualifier "rvalues" added to paragraph 12? Why
does it not cover subelements and pointers?
</p>
<p>
Resolution: Alan Talbot to rework language, then set state to Review.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
The problem is broader than <tt>emplace</tt>. The LWG doesn't
feel that it knows how to write wording that prohibits all of the
problematic use cases at this time.
</p>
<p>
NAD Future.
</p>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG believes that <a href="lwg-active.html#2164">2164</a> addresses this issue and therefore considers <a href="lwg-active.html#760">760</a> as NAD. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add after 23.2 [container.requirements]/12:
</p>

<blockquote>
<p>
-12- Objects passed to member functions of a container as rvalue
references shall not be elements of that container. No diagnostic
required.
</p>
<p>
<ins>
-13- Objects bound to the function parameter pack of the
<tt>emplace</tt> member function shall not be elements or sub-objects of
elements of the container. No diagnostic required.
</ins>
</p>

</blockquote>






<hr>
<h3><a name="839" href="#839">839.</a> Maps and sets missing splice operation</h3>
<p><b>Section:</b> 23.4 [associative], 23.5 [unord] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Alan Talbot <b>Opened:</b> 2008-05-18 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Splice is a very useful feature of <tt>list</tt>. This functionality is also very
useful for any other node based container, and I frequently wish it were
available for maps and sets. It seems like an omission that these
containers lack this capability. Although the complexity for a splice is
the same as for an insert, the actual time can be much less since the
objects need not be reallocated and copied. When the element objects are
heavy and the compare operations are fast (say a <tt>map&lt;int, huge_thingy&gt;</tt>)
this can be a big win.
</p>

<p>
<b>Suggested resolution:</b>
</p>

<p>
Add the following signatures to map, set, multimap, multiset, and the unordered associative containers:
</p>
<blockquote><pre> 
void splice(list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p>
Hint versions of these are also useful to the extent hint is useful.
(I'm looking for guidance about whether hints are in fact useful.)
</p>
 
<blockquote><pre> 
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator i);
void splice(const_iterator position, list&lt;T,Allocator&gt;&amp;&amp; x, const_iterator first, const_iterator last);
</pre></blockquote>

<p><i>[
Sophia Antipolis:
]</i></p>


<blockquote>
<p>
Don't try to <tt>splice "list"</tt> into the other containers, it should be container-type.
</p>
<p>
<tt>forward_list</tt> already has <tt>splice_after</tt>.
</p>
<p>
Would "<tt>splice</tt>" make sense for an <tt>unordered_map</tt>?
</p>
<p>
Jens, Robert: "<tt>splice</tt>" is not the right term, it implies maintaining ordering in <tt>list</tt>s.
</p>
<p>
Howard: <tt>adopt</tt>?
</p>
<p>
Jens: <tt>absorb</tt>?
</p>
<p>
Alan: <tt>subsume</tt>?
</p>
<p>
Robert: <tt>recycle</tt>?
</p>
<p>
Howard: <tt>transfer</tt>? (but no direction)
</p>
<p>
Jens: <tt>transfer_from</tt>. No.
</p>
<p>
Alisdair: Can we give a nothrow guarantee? If your <tt>compare()</tt> and <tt>hash()</tt> doesn't throw, yes.
</p>
<p>
Daniel: For <tt>unordered_map</tt>, we can't guarantee nothrow.
</p>
</blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Martin: this would possibly outlaw an implementation technique that is
currently in use; caching nodes in containers.
</p>
<p>
Alan: if you cache in the allocator, rather than the individual
container, this proposal doesn't interfere with that.
</p>
<p>
Martin: I'm not opposed to this, but I'd like to see an implementation
that demonstrates that it works.
</p>
</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote><p>
NAD Future.
</p></blockquote>

<p><i>[
2009-09-19 Howard adds:
]</i></p>


<blockquote>
<p>
I'm not disagreeing with the NAD Future resolution.  But when the future gets
here, here is a possibility worth exploring:
</p>

<blockquote>
<p>
Add to the "unique" associative containers:
</p>

<blockquote><pre>
typedef <i>details</i>      node_ptr;

node_ptr             remove(const_iterator p);
pair&lt;iterator, bool&gt; insert(node_ptr&amp;&amp; nd);
iterator             insert(const_iterator p, node_ptr&amp;&amp; nd);
</pre></blockquote>

<p>
And add to the "multi" associative containers:
</p>

<blockquote><pre>
typedef <i>details</i> node_ptr;

node_ptr remove(const_iterator p);
iterator insert(node_ptr&amp;&amp; nd);
iterator insert(const_iterator p, node_ptr&amp;&amp; nd);
</pre></blockquote>

<p>
<tt>Container::node_ptr</tt> is a smart pointer much like <tt>unique_ptr</tt>.
It owns a node obtained from the container it was removed from.  It maintains a
reference to the allocator in the container so that it can properly deallocate
the node if asked to, even if the allocator is stateful.  This being said, the
<tt>node_ptr</tt> can not outlive the container for this reason.
</p>

<p>
The <tt>node_ptr</tt> offers "<tt>const</tt>-free" access to the node's
<tt>value_type</tt>.
</p>

<p>
With this interface, clients have a great deal of flexibility:
</p>

<ul>
<li>
A client can remove a node from one container, and insert it into another
(without any heap allocation).  This is the splice functionality this issue
asks for.
</li>
<li>
A client can remove a node from a container, change its key or value, and insert
it back into the same container, or another container, all without the cost of
allocating a node.
</li>
<li>
If the Compare function is nothrow (which is very common), then this functionality
is nothrow unless modifying the value throws.  And if this does throw, it does
so outside of the containers involved.
</li>
<li>
If the Compare function does throw, the <tt>insert</tt> function will have the
argument <tt>nd</tt> retain ownership of the node.
</li>
<li>
The <tt>node_ptr</tt> should be independent of the <tt>Compare</tt> parameter
so that a node can be transferred from <tt>set&lt;T, C1, A&gt;</tt>
to <tt>set&lt;T, C2, A&gt;</tt> (for example).
</li>
</ul>

<p>
Here is how the customer might use this functionality:
</p>

<ul>
<li>
<p>
Splice a node from one container to another:
</p>
<blockquote><pre>
m2.insert(m1.remove(i));
</pre></blockquote>
</li>

<li>
<p>
Change the "key" in a <tt>std::map</tt> without the cost of node reallocation:
</p>
<blockquote><pre>
auto p = m.remove(i);
p->first = new_key;
m.insert(std::move(p));
</pre></blockquote>
</li>

<li>
<p>
Change the "value" in a <tt>std::set</tt> without the cost of node reallocation:
</p>
<blockquote><pre>
auto p = s.remove(i);
*p = new_value;
s.insert(std::move(p));
</pre></blockquote>
</li>

<li>
<p>
Move a move-only or heavy object out of an associative container (as opposed to
the proposal in <a href="lwg-active.html#1041">1041</a>):
</p>
<blockquote><pre>
MoveOnly x = std::move(*s.remove(i));
</pre></blockquote>
<ol>
<li>
<tt>remove(i)</tt> transfers ownership of the node from the set to a temporary
<tt>node_ptr</tt>.
</li>
<li>
The <tt>node_ptr</tt> is dereferenced, and that non-const reference is sent to
<tt>move</tt> to cast it to an rvalue.
</li>
<li>
The rvalue <tt>MoveOnly</tt> is move constructed into <tt>x</tt> from
the <tt>node_ptr</tt>.
</li>
<li>
<tt>~node_ptr()</tt> destructs the moved-from <tt>MoveOnly</tt> and deallocates
the node.
</li>
</ol>

<p>
Contrast this with the <a href="lwg-active.html#1041">1041</a> solution:
</p>
<blockquote><pre>
MoveOnly x = std::move(s.extract(i).first);
</pre></blockquote>

<p>
The former requires one move construction for <tt>x</tt> while the latter
requires two (one into the <tt>pair</tt> and then one into <tt>x</tt>).  Either
of these constructions can throw (say if there is only a copy constructor for
<tt>x</tt>).  With the former, the point of throw is outside of the container
<tt>s</tt>, after the element has been removed from the container.  With the latter,
one throwing construction takes place prior to the removal of the element, and
the second takes place after the element is removed.
</p>

</li>
</ul>

<p>
The "node insertion" API maintains the API associated with inserting <tt>value_type</tt>s
so the customer can use familiar techniques for getting an iterator to the 
inserted node, or finding out whether it was inserted or not for the "unique"
containers.
</p>

<p>
Lightly prototyped.  No implementation problems.  Appears to work great
for the client.
</p>

</blockquote>
</blockquote>

<p><i>[08-2016, Post-Chicago]</i></p>

<p>Move to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>This functionality is provided by <a href="http://wg21.link/P0083R3">P0083R3</a></p>





<hr>
<h3><a name="851" href="#851">851.</a> simplified array construction</h3>
<p><b>Section:</b> 23.3.7 [array] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2008-06-05 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This is an issue that came up on the libstdc++ list, where a
discrepancy between "C" arrays and C++0x's <tt>std::array</tt> was pointed
out.
</p>

<p>
In "C," this array usage is possible:
</p>

<blockquote><pre>
int ar[] = {1, 4, 6};
</pre></blockquote>

<p>
But for C++, 
</p>

<blockquote><pre>
std::array&lt;int&gt; a = { 1, 4, 6 }; // error
</pre></blockquote>

<p>
Instead, the second parameter of the <tt>array</tt> template must be
explicit, like so:
</p>

<blockquote><pre>
std::array&lt;int, 3&gt; a = { 1, 4, 6 };
</pre></blockquote>

<p>
Doug Gregor proposes the following solution, that assumes
generalized initializer lists.
</p>

<blockquote><pre>
template&lt;typename T, typename... Args&gt;
inline array&lt;T, sizeof...(Args)&gt; 
make_array(Args&amp;&amp;... args) 
{ return { std::forward&lt;Args&gt;(args)... };  }
</pre></blockquote>

<p>
Then, the way to build an <tt>array</tt> from a list of unknown size is:
</p>

<blockquote><pre>
auto a = make_array&lt;T&gt;(1, 4, 6);
</pre></blockquote>

<p><i>[
San Francisco:
]</i></p>


<blockquote>
<p>
Benjamin: Move to Ready?
</p>
<p>
Bjarne: I'm not convinced this is useful enough to add, so I'd like us
to have time to reflect on it.
</p>
<p>
Alisdair: the constraints are wrong, they should be
</p>
<blockquote><pre>
template&lt;ValueType T, ValueType... Args&gt;
requires Convertible&lt;Args, T&gt;...
array&lt;T, sizeof...(Args)&gt; make_array(Args&amp;&amp;... args);
</pre></blockquote>
<p>
Alidair: this would be useful if we had a constexpr version.
</p>
<p>
Bjarne: this is probably useful for arrays with a small number of
elements, but it's not clearly useful otherwise.
</p>
<p>
Consensus is to move to Open.
</p>
</blockquote>

<p><i>[
2009-06-07 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest a fix and a simplification of the current proposal: Recent
prototyping by
Howard showed, that a fix is required because narrowing conversion
8.6.4 [dcl.init.list]/6 b.3
would severely limit the possible distribution of argument types, e.g.
the expression
<tt>make_array&lt;double&gt;(1, 2.0)</tt> is ill-formed, because the narrowing
happens <em>inside</em> the
function body where no constant expressions exist anymore. Furthermore
given e.g.
</p>
<blockquote><pre>
int f();
double g();
</pre></blockquote>
<p>
we probably want to support
</p>
<blockquote><pre>
make_array&lt;double&gt;(f(), g());
</pre></blockquote>

<p>
as well. To make this feasible, the currently suggested expansion
</p>

<blockquote><pre>
{ std::forward&lt;Args&gt;(args)... }
</pre></blockquote>

<p>
needs to be replaced by
</p>

<blockquote><pre>
{ static_cast&lt;T&gt;(std::forward&lt;Args&gt;(args))... }
</pre></blockquote>

<p>
which is safe, because we already ensure convertibility via the
element-wise <tt>Convertible&lt;Args, T&gt;</tt> requirement. Some other fixes are
necessary: The <tt>ValueType</tt> requirement for the function <em>parameters</em>
is invalid, because all lvalue arguments will deduce to an lvalue-reference,
thereby no longer satisfying this requirement.
</p>

<p>
The suggested simplification is to provide a default-computed effective
type for the result array based on common_type and decay, in
unconstrained form:
</p>

<blockquote><pre>
template&lt;typename... Args&gt;
array&lt;typename decay&lt;typename common_type&lt;Args...&gt;::type&gt;::type,
sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</pre></blockquote>

<p>
The approach used below is similar to that of <tt>make_pair</tt> and <tt>make_tuple</tt>
using a symbol <tt>C</tt> to represent the decayed common type [Note: Special
handling of <tt>reference_wrapper</tt> types is intentionally <em>not</em> provided, because
our target has so satisfy <tt>ValueType</tt>, thus under the revised proposal only
an all-<tt>reference_wrapper</tt>-arguments would be well-formed and an array of
<tt>reference_wrapper</tt> will be constructed]. I do currently not suggest to
add new concepts reflecting <tt>decay</tt> and <tt>common_type</tt>, but an implementor will
need something like this to succeed. Note that we use a similar fuzziness for
<tt>make_pair</tt> and <tt>make_tuple</tt> currently. This fuzziness is not related to
the currently
missing <tt>Constructible&lt;Vi, Ti&amp;&amp;&gt;</tt> requirement for those functions. The following
proposal fixes that miss for <tt>make_array</tt>. If the corresponding <tt>C</tt> type
deduction is
explicitly wanted for standardization, here the implementation
</p>

<blockquote><pre>
auto concept DC&lt;typename... T&gt; {
  typename type = typename decay&lt;typename common_type&lt;T...&gt;::type&gt;::type;
}
</pre></blockquote>

<p>
where <tt>C</tt> is identical to <tt>DC&lt;Args...&gt;::type</tt> in the proposed resolution below.
</p>
<p>
I intentionally added no further type relation between type and the concept
template parameters, but instead added this requirement below to make
the specification as transparent as possible. As written this concept is
satisfied, if the corresponding associated type exists.
</p>

<p><b>Suggested Resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 23.3 [sequences]:
</p>
<blockquote><pre>
<ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);
</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 23.3.7.9 [array.tuple] Tuple interface to class template array
the following new section:
</p>
<blockquote>
<p>
23.4.1.7 Array creation functions [array.creation]
</p>

<pre>
<ins>
template&lt;ReferentType... Args&gt;
requires ValueType&lt;C&gt; &amp;&amp; IdentityOf&lt;Args&gt; &amp;&amp; Constructible&lt;C, Args&amp;&amp;&gt;...
array&lt;C, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args);</ins>
</pre>

<blockquote>
<p><ins>
Let <tt>C</tt> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.
</ins></p>
<p>
<ins><i>Returns:</i> an <tt>array&lt;C, sizeof...(Args)&gt;</tt> initialized with
<tt>{ static_cast&lt;C&gt;(std::forward&lt;Args&gt;(args))... }</tt>.
</ins></p>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>

<p><i>[
2009-07 Frankfurt:
]</i></p>


<blockquote>
<p>
The proposed resolution uses concepts.
</p>
<p>
Daniel to rewrite the proposed resolution.
</p>
<p>
Leave Open.
</p>
</blockquote>

<p><i>[
2009-07-25 Daniel provides rewritten proposed resolution.
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Argument for NAD future: everything about this could be added on. This
does not require changes to the existing text.
</p></blockquote>

<p><i>[2015-11-29, Alisdair comments]</i></p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4391">N4391</a> was adopted for Fundamentals 2 at the Lenexa meeting.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>
Add to the array synopsis in 23.3 [sequences]:
</p>

<blockquote><pre>
<ins>template&lt;class... Args&gt;
  array&lt;<i>CT</i>, sizeof...(Args)&gt;
  make_array(Args&amp;&amp;... args);</ins>
</pre></blockquote>
</li>

<li>
<p>
Append after 23.3.7.9 [array.tuple] "Tuple interface to class template array" the
following new section:
</p>

<blockquote>
<p>
<ins>XX.X.X.X Array creation functions [array.creation]</ins>
</p>

<pre><ins>
template&lt;class... Args&gt;
array&lt;<i>CT</i>, sizeof...(Args)&gt;
make_array(Args&amp;&amp;... args)
</ins></pre>

<blockquote>
<p>
<ins>Let <i>CT</i> be <tt>decay&lt;common_type&lt;Args...&gt;::type&gt;::type</tt>.</ins>
</p>
<p>
<ins><i>Returns:</i> An <tt>array&lt;<i>CT</i>, sizeof...(Args)&gt;</tt> initialized with <tt>{
static_cast&lt;<i>CT</i>&gt;(std::forward&lt;Args&gt;(args))... }</tt>.</ins>
</p>

<p><ins>
[<i>Example:</i>
</ins></p>
<blockquote><pre><ins>
int i = 0; int&amp; ri = i;
make_array(42u, i, 2.78, ri);
</ins></pre></blockquote>
<p><ins>
returns an array of type
</ins></p>
<blockquote><pre><ins>
array&lt;double, 4&gt;
</ins></pre></blockquote>

<p><ins>
&mdash;<i>end example</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>








<hr>
<h3><a name="877" href="#877">877.</a> to <tt>throw()</tt> or to <i>Throw:</i> Nothing.</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Martin Sebor <b>Opened:</b> 2008-08-23 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
       <p>

Recent changes to
the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2691.pdf">working
draft</a> have introduced a gratuitous inconsistency with the C++ 2003
version of the specification with respect to exception guarantees
provided by standard functions. While the C++ 2003 standard
consistenly uses the empty exception specification, <tt>throw()</tt>,
to declare functions that are guaranteed not to throw exceptions, the
current working draft contains a number of "<i>Throws:</i> Nothing."
clause to specify essentially the same requirement. The difference
between the two approaches is that the former specifies the behavior
of programs that violate the requirement (<tt>std::unexpected()</tt>
is called) while the latter leaves the behavior undefined.

       </p>
       <p>

A survey of the working draft reveals that there are a total of 209
occurrences of <tt>throw()</tt> in the library portion of the spec,
the majority in clause 18, a couple (literally) in 19, a handful in
20, a bunch in 22, four in 24, one in 27, and about a dozen in D.9.

       </p>
       <p>

There are also 203 occurrences of "<i>Throws:</i> Nothing." scattered
throughout the spec.

       </p>
       <p>

While sometimes there are good reasons to use the "<i>Throws:</i>
Nothing."  approach rather than making use of <tt>throw()</tt>, these
reasons do not apply in most of the cases where this new clause has
been introduced and the empty exception specification would be a
better approach.

       </p>
       <p>

First, functions declared with the empty exception specification
permit compilers to generate better code for calls to such
functions. In some cases, the compiler might even be able to eliminate
whole chunks of user-written code when instantiating a generic
template on a type whose operations invoked from the template
specialization are known not to throw. The prototypical example are
the <tt>std::uninitialized_copy()</tt>
and <tt>std::uninitialized_fill()</tt> algorithms where the
entire <tt>catch(...)</tt> block can be optimized away.

       </p>
       <p>

For example, given the following definition of
the <tt>std::uninitialized_copy</tt> function template and a
user-defined type <tt>SomeType</tt>:

       </p>
       <blockquote>
           <pre>
template &lt;class InputIterator, class ForwardIterator&gt;
ForwardIterator
uninitialized_copy (InputIterator first, InputIterator last, ForwardIterator res)
{
   typedef iterator_traits&lt;ForwardIterator&gt;::value_type ValueType;

   ForwardIterator start = res;

   try {
       for (; first != last; ++first, ++res)
           ::new (&amp;*res) ValueType (*first);
   }
   catch (...) {
       for (; start != res; --start)
           (&amp;*start)->~ValueType ();
       throw;
   }
   return res;
}

struct SomeType {
   SomeType (const SomeType&amp;) <ins>throw ()</ins>;
}</pre>
       </blockquote>
       <p>

compilers are able to emit the following efficient specialization
of <tt>std::uninitialized_copy&lt;const SomeType*, SomeType*&gt;</tt>
(note that the <tt>catch</tt> block has been optimized away):

       </p>
       <blockquote>
           <pre>
template &lt;&gt; SomeType*
uninitialized_copy (const SomeType *first, const SomeType *last, SomeType *res)
{
   for (; first != last; ++first, ++res)
       ::new (res) SomeType (*first);

   return res;
}</pre>
       </blockquote>
       <p>

Another general example is default constructors which, when decorated
with <tt>throw()</tt>, allow the compiler to eliminate the
implicit <tt>try</tt> and <tt>catch</tt> blocks that it otherwise must
emit around each the invocation of the constructor
in <i>new-expressions</i>.

       </p>
       <p>

For example, given the following definitions of
class <tt>MayThrow</tt> and <tt>WontThrow</tt> and the two
statements below:

       </p>
       <blockquote>
           <pre>
struct MayThrow {
   MayThrow ();
};

struct WontThrow {
   WontThrow () <ins>throw ()</ins>;
};

MayThrow  *a = new MayThrow [N];
WontThrow *b = new WontThrow [N];</pre>

       </blockquote>
       <p>

the compiler generates the following code for the first statement:

       </p>
       <blockquote>
           <pre>
MayThrow *a;
{
   MayThrow *first = operator new[] (N * sizeof (*a));
   MayThrow *last  = first + N;
   MayThrow *next  = first;
   try {
       for ( ; next != last; ++next)
           new (next) MayThrow;
   }
   catch (...) {
       for ( ; first != first; --next)
           next->~MayThrow ();
       operator delete[] (first);
       throw;
   }
   a = first;
}</pre>
       </blockquote>
       <p>

but it is can generate much more compact code for the second statement:

       </p>
       <blockquote>
           <pre>
WontThrow *b    = operator new[] (N * sizeof (*b));
WontThrow *last = b + N;
for (WontThrow *next = b; next != last; ++next)
   new (next) WontThrow;
</pre>
       </blockquote>
       <p>

Second, in order for users to get the maximum benefit out of the new
<tt>std::has_nothrow_xxx</tt> traits when using standard library types
it will be important for implementations to decorate all non throwing
copy constructors and assignment operators with <tt>throw()</tt>. Note
that while an optimizer may be able to tell whether a function without
an explicit exception specification can throw or not based on its
definition, it can only do so when it can see the source code of the
definition. When it can't it must assume that the function may
throw. To prevent violating the One Definition Rule,
the <tt>std::has_nothrow_xxx</tt> trait must return the most
pessimistic guess across all translation units in the program, meaning
that <tt>std::has_nothrow_xxx&lt;T&gt;::value</tt> must evaluate to
<tt>false</tt> for any <tt>T</tt> whose <tt>xxx</tt>
(where <tt>xxx</tt> is default or copy ctor, or assignment operator)
is defined out-of-line.

       </p>
       <p>

<b>Counterarguments:</b>

       </p>
       <p>

During the discussion of this issue
on <a href="mailto:c++std-lib@accu.org">c++std-lib@accu.org</a>
(starting with post <tt>c++std-lib-21950</tt>) the following arguments
in favor of the "<i>Throws:</i> Nothing." style have been made.

       </p>
         <ol>
           <li>

Decorating functions that cannot throw with the empty exception
specification can cause the compiler to generate suboptimal code for
the implementation of the function when it calls other functions that
aren't known to the compiler not to throw (i.e., that aren't decorated
with <tt>throw()</tt> even if they don't actually throw). This is a
common situation when the called function is a C or POSIX function.

           </li>
           <li>

Alternate, proprietary mechanisms exist (such as
GCC <a href="http://gcc.gnu.org/onlinedocs/gcc-4.3.0/gcc/Function-Attributes.html#index-g_t_0040code_007bnothrow_007d-function-attribute-2160"><tt>__attribute__((nothrow))</tt></a>
or Visual
C++ <a href="http://msdn.microsoft.com/en-us/library/49147z04(VS.80).aspx"><tt>__declspec(nothrow)</tt></a>)
that let implementers mark up non-throwing functions, often without
the penalty mentioned in (1) above. The C++ standard shouldn't
preclude the use of these potentially more efficient mechanisms.

           </li>
           <li>

There are functions, especially function templates, that invoke
user-defined functions that may or may not be
declared <tt>throw()</tt>. Declaring such functions with the empty
exception specification will cause compilers to generate suboptimal
code when the user-defined function isn't also declared not to throw.

           </li>
        </ol>
       <p>

The answer to point (1) above is that implementers can (and some have)
declare functions with <tt>throw()</tt> to indicate to the compiler
that calls to the function can safely be assumed not to throw in order
to allow it to generate efficient code at the call site without also
having to define the functions the same way and causing the compiler
to generate suboptimal code for the function definition. That is, the
function is declared with <tt>throw()</tt> in a header but it's
defined without it in the source file. The <tt>throw()</tt>
declaration is suppressed when compiling the definition to avoid
compiler errors. This technique, while strictly speaking no permitted
by the language, is safe and has been employed in practice. For
example, the GNU C library takes this approach. Microsoft Visual C++
takes a similar approach by simply assuming that no function with C
language linkage can throw an exception unless it's explicitly
declared to do so using the language extension <tt>throw(...)</tt>.

       </p>
       <p>

Our answer to point (2) above is that there is no existing practice
where C++ Standard Library implementers have opted to make use of the
proprietary mechanisms to declare functions that don't throw. The
language provides a mechanism specifically designed for this
purpose. Avoiding its use in the specification itself in favor of
proprietary mechanisms defeats the purpose of the feature. In
addition, making use of the empty exception specification
inconsistently, in some areas of the standard, while conspicuously
avoiding it and making use of the "<i>Throws:</i> Nothing." form in
others is confusing to users.

       </p>
       <p>

The answer to point (3) is simply to exercise caution when declaring
functions and especially function templates with the empty exception
specification. Functions that required not to throw but that may call
back into user code are poor candidates for the empty exception
specification and should instead be specified using "<i>Throws:</i>
Nothing." clause.

      </p>

<p><i>[
2009-07 Frankfurt
]</i></p>


<blockquote>
<p>
We need someone to do an extensive review.
</p>
<p>
NAD Future.
</p>
</blockquote>

   
   <p><b>Proposed resolution:</b></p>
       <p>

We propose two possible solutions. Our recommendation is to adopt
Option 1 below.

       </p>
       <p>

<b>Option 1:</b>

       </p>
       <p>

Except for functions or function templates that make calls back to
user-defined functions that may not be declared <tt>throw()</tt>
replace all occurrences of the "<i>Throws:</i> Nothing." clause with
the empty exception specification. Functions that are required not to
throw but that make calls back to user code should be specified to
"<i>Throw:</i> Nothing."

       </p>
       <p>

<b>Option 2:</b>

       </p>
       <p>

For consistency, replace all occurrences of the empty exception
specification with a "<i>Throws:</i> Nothing." clause.

       </p>
   



<hr>
<h3><a name="933" href="#933">933.</a> Unique_ptr defect</h3>
<p><b>Section:</b> 20.11.1.2.5 [unique.ptr.single.modifiers] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2008-11-27 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single.modifiers">issues</a> in [unique.ptr.single.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we are supporting stateful deleters, we need an overload for
<tt>reset</tt> that
takes a deleter as well.
</p>

<blockquote><pre>
void reset( pointer p, deleter_type d);
</pre></blockquote>

<p>
We probably need two overloads to support move-only deleters, and
this
sounds uncomfortably like the two constructors I have been ignoring
for
now...
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Howard comments that we have the functionality via move-assigment.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD Future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="935" href="#935">935.</a> clock error handling needs to be specified</h3>
<p><b>Section:</b> 20.17.7 [time.clock] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2008-11-24 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Each of the three clocks specified in Clocks 20.17.7 [time.clock]
provides the member function:
</p>

<blockquote><pre>
static time_point now();
</pre></blockquote>

<p>
The semantics specified by Clock requirements 20.17.3 [time.clock.req]
make no mention of error handling. Thus the function may throw <tt>bad_alloc</tt>
or an implementation-defined exception (17.6.5.12 [res.on.exception.handling]
paragraph 4).
</p>

<p>
Some implementations of these functions on POSIX, Windows, and
presumably on other operating systems, may fail in ways only detectable
at runtime. Some failures on Windows are due to supporting chipset
errata and can even occur after successful calls to a clock's <tt>now()</tt>
function.
</p>

<p>
These functions are used in cases where exceptions are not appropriate
or where the specifics of the exception or cause of error need to be
available to the user. See
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error
handling (Rev 1)</i>, for more specific discussion of use cases. Thus some change in
the interface of now is required.
</p>

<p>
The proposed resolution has been implemented in the Boost version of the
chrono library. No problems were encountered.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
We recommend this issue be deferred until the next Committee Draft
has been issued and the prerequisite paper has been accepted.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD future. Too late to make this change without having already
accepted the hybrid error handling proposal.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Accept the proposed wording of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2828.html">N2828</a>,
<i>Library Support for hybrid error handling (Rev 1)</i>.
</p>

<p>
Change <tt>Clock</tt> requirements 20.17.3 [time.clock.req] as indicated:
</p>

<blockquote>
<p>
-2- In Table 55 <tt>C1</tt> and <tt>C2</tt> denote clock types. <tt>t1</tt> and
<tt>t2</tt> are values returned by <tt>C1::now()</tt> where the call 
returning <tt>t1</tt> happens before (1.10) the call returning <tt>t2</tt> and
both of these calls happen before <tt>C1::time_point::max()</tt>.
<ins><tt>ec</tt> denotes an object of type <tt>error_code</tt> 
(19.5.3.1 [syserr.errcode.overview]).</ins>
</p>

<table border="1">
<caption>Table 55 &mdash; Clock requirements</caption>
<tr>
<th>Expression</th><th>Return type</th><th>Operational semantics</th>
</tr>

<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>

<tr>
<td><tt>C1::now()</tt></td>
<td><tt>C1::time_point</tt></td>
<td>Returns a <tt>time_point</tt> object representing the current point in time.
</td>
</tr>

<tr>
<td><tt><ins>C1::now(ec)</ins></tt></td>
<td><tt><ins>C1::time_point</ins></tt></td>
<td><ins>Returns a <tt>time_point</tt> object representing the current point in time.</ins>
</td>
</tr>
</table>
</blockquote>

<p>
Change class <tt>system_clock</tt> 20.17.7.1 [time.clock.system] as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>monotonic_clock</tt> 99 [time.clock.monotonic] as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>

<p>
Change class <tt>high_resolution_clock</tt> 20.17.7.3 [time.clock.hires] as indicated:
</p>

<blockquote><pre>
static time_point now(<ins>error_code&amp; ec=throws()</ins>);
</pre></blockquote>






<hr>
<h3><a name="936" href="#936">936.</a> Mutex type overspecified</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2008-12-05 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-active.html#961">961</a></p>
<p><b>Discussion:</b></p>



<p>
30.4.1 [thread.mutex.requirements] describes the requirements for a type to be
a "Mutex type". A Mutex type can be used as the template argument for
the <tt>Lock</tt> type that's passed to <tt>condition_variable_any::wait</tt> (although
<tt>Lock</tt> seems like the wrong name here, since <tt>Lock</tt> is given a different
formal meaning in 30.4.2 [thread.lock]) and, although the WD doesn't quite say
so, as the template argument for <tt>lock_guard</tt> and <tt>unique_lock</tt>.
</p>

<p>
The requirements for a Mutex type include:
</p>

<ul>
<li>
<tt>m.lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
<li>
<tt>m.try_lock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>bool</tt>.
</li>
<li>
<tt>m.unlock()</tt> shall be well-formed and have [described] semantics, including a return type of <tt>void</tt>.
</li>
</ul>

<p>
Also, a Mutex type "shall not be copyable nor movable".
</p>

<p>
The latter requirement seems completely irrelevant, and the three
requirements on return types are tighter than they need to be. For
example, there's no reason that <tt>lock_guard</tt> can't be instantiated with a
type that's copyable. The rule is, in fact, that <tt>lock_guard</tt>, etc. won't
try to copy objects of that type. That's a constraint on locks, not on
mutexes. Similarly, the requirements for <tt>void</tt> return types are
unnecessary; the rule is, in fact, that <tt>lock_guard</tt>, etc. won't use any
returned value. And with the return type of <tt>bool</tt>, the requirement should
be that the return type is convertible to <tt>bool</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
Move to open. Related to conceptualization and should probably be tackled as part of that.
</p>
<ul>
<li>
The intention is not only to place a constraint on what types such as
<tt>lock_guard</tt> may do with mutex types, but on what any code, including user
code, may do with mutex types. Thus the constraints as they are apply to
the mutex types themselves, not the current users of mutex types in the
standard.
</li>
<li>
This is a low priority issue; the wording as it is may be overly
restrictive but this may not be a real issue.
</li>
</ul>
</blockquote>

<p><i>[
Post Summit Anthony adds:
]</i></p>


<blockquote>
<p>
Section 30.4.1 [thread.mutex.requirements] conflates the
requirements on a generic Mutex type (including user-supplied mutexes)
with the requirements placed on the standard-supplied mutex types in an
attempt to group everything together and save space.
</p>
<p>
When applying concepts to chapter 30, I suggest that the concepts
<tt>Lockable</tt> and <tt>TimedLockable</tt> embody the requirements for
*use* of a mutex type as required by
<tt>unique_lock/lock_guard/condition_variable_any</tt>. These should be
relaxed as Pete describes in the issue. The existing words in 30.4.1 [thread.mutex.requirements] are requirements on all of
<tt>std::mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_mutex</tt> and <tt>std::recursive_timed_mutex</tt>,
and should be rephrased as such.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="961" href="#961">961.</a> Various threading bugs #11</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-active.html#936">936</a></p>
<p><b>Discussion:</b></p>
<p>
30.4.1 [thread.mutex.requirements] describes required member
functions of mutex types, and requires that they throw exceptions under
certain circumstances. This is overspecified. User-defined types can
abort on such errors without affecting the operation of templates
supplied by standard-library.
</p>

<p><i>[
Summit:
]</i></p>

<blockquote><p>
Move to open. Related to conceptualization and should probably be
tackled as part of that.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
Would be OK to leave it as is for time constraints, could loosen later.
</p>

<p>
Mark as NAD Future.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1025" href="#1025">1025.</a> The library should provide more specializations for <tt>std::hash</tt></h3>
<p><b>Section:</b> 20.14.14 [unord.hash] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 208 [CD1]</b></p>

<p>
<tt>std::hash</tt> should be implemented for much more of the standard
library. In particular for <tt>pair</tt>, <tt>tuple</tt> and all the
standard containers.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1031" href="#1031">1031.</a> Need <tt>shared_ptr</tt> conversion to a <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.11.2.2 [util.smartptr.shared] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-11 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses US 78 [CD1]</b></p>

<p>
There is presently no way to convert directly from a <tt>shared_ptr</tt> to a
<tt>unique_ptr</tt>. Add an interface that performs the conversion. 
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We look forward to a paper on this topic. We recommend no action until a
paper is available. We believe that the shared pointer must use the default
deleter for the conversion to succeed.
</p></blockquote>

<p><i>[
Peter Dimov adds:
]</i></p>


<blockquote><p>
This is basically a request for <tt>shared_ptr&lt;&gt;::release</tt> in
disguise, with all the associated problems. Not a good idea.
</p></blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote>
<p>
The rationale for the omission of a release() member function from shared_ptr is given in:
<a href="http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm</a>
</p>
<p>
The implementation of such a member is non-trivial (and maybe
impossible), because it would need to account for the deleter.
</p>
</blockquote>

<p><i>[
2009-07-26 Howard sets to Tentatively NAD Future.
]</i></p>


<blockquote>
<p>
I took an online poll and got 3 votes for NAD and 3 for NAD Future.  Personally
I prefer NAD Future as this does refer to an extension that could conceivably be
considered beyond C++0X.
</p>

<p>
However such an extension would need to solve a couple of problems:
</p>

<ol>
<li>What is the interface for such a conversion when the <tt>shared_ptr</tt> does
not have unique ownership?  Throw an exception?  Create a null <tt>unique_ptr</tt>?
Undefined behavior?
</li>

<li>
<p>
How does one handle custom deleters given to the <tt>shared_ptr</tt> constructor?
</p>
<p>
I do not believe it is possible to implement a general answer to this question.
The <tt>shared_ptr</tt> deleter is a run time (or construction time) characteristic.
The <tt>unique_ptr</tt> deleter is a compile time characteristic.  In general one
can not know to what type of <tt>unqiue_ptr</tt> you are converting to.
</p>
<p>
One answer is for the user of the conversion to specify the deleter type and perhaps
throw an exception if the specification turns out to be incorrect.
</p>
<p>
Another answer is for the conversion to only be valid when the underlying deleter
is <tt>default_delete</tt>.  We would probalby need to specify that this is indeed the
underlying deleter of a <tt>shared_ptr</tt> when a custom deleter is not given in
the constructor.
</p>
</li>
</ol>

<p>
At any rate, there are non-trivial design issues which would need to be implemented
and tested in the field for usability prior to standardization.
</p>
</blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Moved to NAD Future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1041" href="#1041">1041.</a> Add associative/unordered container functions that allow to extract elements</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 239 [CD1]</b></p>

<p>
It is not possible to take a move-only key out of an unordered
container, such as (<tt>multi</tt>)<tt>set</tt> or
(<tt>multi</tt>)<tt>map</tt>, or the new unordered containers.
</p>

<p>
Add below <tt>a.erase(q)</tt>, <tt>a.extract(q)</tt>, with the following notation:
</p>
<p>
<tt>a.extract(q)></tt>, Return type <tt>pair&lt;key, iterator&gt;</tt>
Extracts the element pointed to by <tt>q</tt> and erases it from the
<tt>set</tt>. Returns a <tt>pair</tt> containing the value pointed to by
<tt>q</tt> and an <tt>iterator</tt> pointing to the element immediately
following <tt>q</tt> prior to the element being erased. If no such
element exists,returns <tt>a.end()</tt>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
We look forward to a paper on this topic. We recommend no action until a
paper is available. The paper would need to address exception safety.
</p></blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote><p>
Would <tt>value_type</tt> be a better return type than <tt>key_type</tt>?
</p></blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote><p>
Leave Open. Alisdair to contact Chris Jefferson about this.
</p></blockquote>

<p><i>[
2009-09-20 Howard adds:
]</i></p>


<blockquote><p>
See the 2009-09-19 comment of <a href="lwg-active.html#839">839</a> for an API which
accomplishes this functionality and also addresses several other use
cases which this proposal does not.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Mark as NAD Future. No consensus to make the change at this time.
</p></blockquote>

<p><strong>Original resolution [SUPERSEDED]:</strong></p>
<blockquote class = "note">
<p>
In 23.2.4 [associative.reqmts] Table 85, add:
</p>

<blockquote>
<table border="1">
<caption>Table 85 --  Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</table>
</blockquote>

<p>
In 23.2.5 [unord.req] Table 87, add:
</p>

<blockquote>
<table border="1">
<caption>Table 87 -- Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><tt>a.erase(q)</tt></td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td><ins><tt>a.extract(q)</tt></ins></td>
<td><ins><tt>pair&lt;key_type, iterator&gt;</tt></ins></td>
<td><ins>Extracts the element pointed to by <tt>q</tt> and erases it from the <tt>set</tt>. 
Returns a <tt>pair</tt> containing the value pointed to by <tt>q</tt> and an <tt>iterator</tt>
pointing to the element immediately following <tt>q</tt> prior to the element being
erased. If no such element 
exists, returns <tt>a.end()</tt>.</ins></td>
<td><ins>amortized constant</ins></td>
</tr>
</table>
</blockquote>
</blockquote>

<p><i>[08-2016, Post-Chicago]</i></p>

<p>Move to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>This functionality is provided by <a href="http://wg21.link/P0083R3">P0083R3</a></p>





<hr>
<h3><a name="1052" href="#1052">1052.</a> <tt>reverse_iterator::operator-&gt;</tt> should also support smart pointers</h3>
<p><b>Section:</b> 24.5.1.3.5 [reverse.iter.opref] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iter.opref">issues</a> in [reverse.iter.opref].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#2775">2775</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 281 [CD1]</b></p>

<p>
The current specification for return value for <tt>reverse_iterator::operator-&gt;</tt>
will always be a true pointer type, but <tt>reverse_iterator</tt> supports proxy
iterators where the pointer type may be some kind of 'smart pointer'.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
<tt>move_iterator</tt> avoids this problem by returning a value of the wrapped
Iterator type.
study group formed to come up with a suggested resolution.
</p>
<p>
<tt>move_iterator</tt> solution shown in proposed wording.
</p>
</blockquote>

<p><i>[
2009-07 post-Frankfurt:
]</i></p>


<blockquote><p>
Howard to deconceptize. Move to Review after that happens.
</p></blockquote>

<p><i>[
2009-08-01 Howard deconceptized:
]</i></p>


<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
<p>
We can't think of any reason we can't just define reverse
iterator's pointer types to be the same as the underlying iterator's
pointer type, and get it by calling the right arrow directly.
</p>
<p>
Here is the proposed wording that was replaced:
</p>
<blockquote><pre>
template &lt;class Iterator&gt; 
class reverse_iterator { 
  ...
  typedef <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del> pointer;
</pre></blockquote>

<p>
Change 24.5.1.3.5 [reverse.iter.opref]:
</p>

<blockquote><pre>
pointer operator-&gt;() const;
</pre>
<blockquote><p>
<i>Returns:</i>
</p><blockquote><pre>
<del>&amp;(operator*());</del>
<ins>this-&gt;tmp = current;</ins>
<ins>--this-&gt;tmp;</ins>
<ins>return this-&gt;tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</blockquote>

<p><i>[
2010-03-03 Daniel opens:
]</i></p>


<blockquote>
<ol>

<li>
There is a minor problem with the exposition-only declaration of the private
member <tt>deref_tmp</tt> which is modified in a const member function (and the
same problem occurs in the specification of <tt>operator*</tt>). The fix is to
make it a mutable member.
</li>

<li>
<p>
The more severe problem is that the resolution for some reasons
does not explain in the rationale why it was decided to differ from
the suggested fix (using <tt>deref_tmp</tt> instead of <tt>tmp</tt>) in the
[ 2009-10 Santa Cruz] comment:
</p>

<blockquote><pre>
this-&gt;deref_tmp = current;
--this-&gt;deref_tmp;
return this-&gt;deref_tmp;
</pre></blockquote>

<p>
combined with the change of
</p>

<blockquote><pre>
typedef typename iterator_traits&lt;Iterator&gt;::pointer pointer;
</pre></blockquote>

<p>
to
</p>

<blockquote><pre>
typedef Iterator pointer;
</pre></blockquote>

<p>
The problem of the agreed on wording is that the following rather
typical example, that compiled with the wording before 1052 had
been applied, won't compile anymore:
</p>

<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;utility&gt;

int main() {
  typedef std::pair&lt;int, double&gt; P;
  P op;
  std::reverse_iterator&lt;P*&gt; ri(&amp;op + 1);
  ri-&gt;first; // Error
}
</pre></blockquote>

<p>
Comeau online returns (if a correspondingly changed
<tt>reverse_iterator</tt> is used):
</p>

<blockquote><pre>
"error: expression must have class type
     return deref_tmp.operator-&gt;();
            ^
         detected during instantiation of "Iterator
                   reverse_iterator&lt;Iterator&gt;::operator-&gt;() const [with
                   Iterator=std::pair&lt;int, double&gt; *]""
</pre></blockquote>

<p>
Thus the change will break valid, existing code based
on <tt>std::reverse_iterator</tt>.
</p>

</li>

</ol>

<p>
IMO the suggestion proposed in the comment is a necessary fix, which harmonizes
with the similar specification of <tt>std::move_iterator</tt> and properly
reflects the recursive nature of the evaluation of <tt>operator-&gt;</tt>
overloads.
</p>

<p>
Suggested resolution:
</p>

<ol>

<li>
<p>
In the class template <tt>reverse_iterator</tt> synopsis of 24.5.1.1 [reverse.iterator] 
change as indicated:
</p>

<blockquote><pre>
namespace std {
template &lt;class Iterator&gt;
class reverse_iterator : public
             iterator&lt;typename iterator_traits&lt;Iterator&gt;::iterator_category,
             typename iterator_traits&lt;Iterator&gt;::value_type,
             typename iterator_traits&lt;Iterator&gt;::difference_type,
             <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del>,
             typename iterator_traits&lt;Iterator&gt;::reference&gt; {
public:
  [..]
  typedef <del>typename iterator_traits&lt;</del>Iterator<del>&gt;::pointer</del> pointer;
  [..]
protected:
  Iterator current;
private:
  <ins>mutable</ins> Iterator deref_tmp; // exposition only
};
</pre></blockquote>
</li>

<li>
Change 24.5.1.3.5 [reverse.iter.opref]/1 as indicated:

<blockquote><pre>
pointer operator-&gt;() const;
</pre>

<blockquote><p>
1 <i><del>Returns</del> <ins>Effects</ins>:</i> <del><tt>&amp;(operator*())</tt>.</del>
</p><blockquote><pre>
<ins>deref_tmp = current;</ins>
<ins>--deref_tmp;</ins>
<ins>return deref_tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>

</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
We prefer to make to use a local variable instead of <tt>deref_tmp</tt> within
<tt>operator-&gt;()</tt>.  And although this means that the <tt>mutable</tt>
change is no longer needed, we prefer to keep it because it is needed for
<tt>operator*()</tt> anyway.
</p>

<p>
Here is the proposed wording that was replaced:
</p>

<blockquote class="note">
<p>
Change 24.5.1.3.5 [reverse.iter.opref]:
</p>

<blockquote><pre>
pointer operator-&gt;() const;
</pre>

<blockquote><p>
<i>Returns:</i>
</p><blockquote><pre>
<del>&amp;(operator*());</del>
<ins>deref_tmp = current;
--deref_tmp;
return deref_tmp::operator-&gt;();</ins>
</pre></blockquote>

</blockquote>
</blockquote>


</blockquote>
</blockquote>

<p><i>[
2010-03-10 Howard adds:
]</i></p>


<blockquote>
<p>
Here are three tests that the current proposed wording passes, and no
other solution I've seen passes all three:
</p>

<ol>
<li>
<p>
Proxy pointer support:
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;cassert&gt;

struct X { int m; };

X x;

struct IterX {
    typedef std::bidirectional_iterator_tag iterator_category;
    typedef X&amp; reference;
    struct pointer
    {
        pointer(X&amp; v) : value(v) {}
        X&amp; value;
        X* operator-&gt;() const {return &amp;value;}
    };
    typedef std::ptrdiff_t difference_type;
    typedef X value_type;
    // additional iterator requirements not important for this issue
    
    reference operator*() const { return x; }
    pointer operator-&gt;() const { return pointer(x); }
    IterX&amp; operator--() {return *this;}

};

int main()
{
    std::reverse_iterator&lt;IterX&gt; ix;
    assert(&amp;ix-&gt;m == &amp;(*ix).m);
}
</pre></blockquote>
</li>
<li>
<p>
Raw pointer support:
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;utility&gt;

int main() {
  typedef std::pair&lt;int, double&gt; P;
  P op;
  std::reverse_iterator&lt;P*&gt; ri(&amp;op + 1);
  ri-&gt;first; // Error
}
</pre></blockquote>
</li>
<li>
<p>
Caching iterator support:
</p>
<blockquote><pre>
#include &lt;iterator&gt;
#include &lt;cassert&gt;

struct X { int m; };

struct IterX {
    typedef std::bidirectional_iterator_tag iterator_category;
    typedef X&amp; reference;
    typedef X* pointer;
    typedef std::ptrdiff_t difference_type;
    typedef X value_type;
    // additional iterator requirements not important for this issue
    
    reference operator*() const { return value; }
    pointer operator-&gt;() const { return &amp;value; }
    IterX&amp; operator--() {return *this;}

private:
    mutable X value;
};

int main()
{
    std::reverse_iterator&lt;IterX&gt; ix;
    assert(&amp;ix-&gt;m == &amp;(*ix).m);
}
</pre></blockquote>
</li>
</ol>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Future, rationale added.
</p></blockquote>




<p><b>Rationale:</b></p>
<p>
The LWG did not reach a consensus for a change to the WP.
</p>


<p><b>Proposed resolution:</b></p>

<ol>

<li>
<p>
In the class template <tt>reverse_iterator</tt> synopsis of 24.5.1.1 [reverse.iterator] change as indicated:
</p>

<blockquote><pre>
namespace std {
template &lt;class Iterator&gt;
class reverse_iterator : public
             iterator&lt;typename iterator_traits&lt;Iterator&gt;::iterator_category,
             typename iterator_traits&lt;Iterator&gt;::value_type,
             typename iterator_traits&lt;Iterator&gt;::difference_type,
             <del>typename iterator_traits&lt;</del>Iterator<ins>&amp;</ins><del>&gt;::pointer</del>,
             typename iterator_traits&lt;Iterator&gt;::reference&gt; {
public:
  [..]
  typedef <del>typename iterator_traits&lt;</del>Iterator<ins>&amp;</ins><del>&gt;::pointer</del> pointer;
  [..]
protected:
  Iterator current;
private:
  <ins>mutable</ins> Iterator deref_tmp; // exposition only
};
</pre></blockquote>
</li>

<li>
Change 24.5.1.3.5 [reverse.iter.opref]/1 as indicated:

<blockquote><pre>
pointer operator-&gt;() const;
</pre>

<blockquote><p>
1 <i><del>Returns</del> <ins>Effects</ins>:</i> <del><tt>&amp;(operator*())</tt>.</del>
</p><blockquote><pre>
<ins>deref_tmp = current;</ins>
<ins>--deref_tmp;</ins>
<ins>return deref_tmp;</ins>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>


<p><i>[Alternate Proposed Resolution from <a href="lwg-closed.html#2775">2775</a>, which was closed as a dup of this issue]</i></p>


<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 24.5.1.3.5 [reverse.iter.opref] as indicated:</p>
<blockquote>
<pre>
constexpr pointer operator-&gt;() const;
</pre>
<blockquote>
<p>
-1- <del><i>Returns:</i> <tt>addressof(operator*())</tt>.</del><ins><i>Effects:</i> If <tt>Iterator</tt>
is a pointer type, as if by:</ins>
</p>
<blockquote><pre>
<ins>Iterator tmp = current;
return --tmp;</ins>
</pre></blockquote>
<p>
<ins>Otherwise, as if by:</ins>
</p>
<blockquote><pre>
<ins>Iterator tmp = current;
--tmp;
return tmp.operator-&gt;();</ins>
</pre></blockquote>
</blockquote>
</blockquote>
</li>
</ol>









<hr>
<h3><a name="1053" href="#1053">1053.</a> Unify algorithms with operator and function object variants</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-03-12 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses UK 295 [CD1]</b></p>

<p>
There is a level of redundancy in the library specification for many
algorithms that can be eliminated with the combination of concepts and
default parameters for function templates. Eliminating redundancy simplified
specification and reduces the risk of introducing accidental
inconsistencies.
</p>
<p>
Proposed resolution: Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2743.pdf">N2743</a>.
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
<p>
NAD, this change would break code that takes the address of an algorithm.
</p>
</blockquote>

<p><i>[
Post Summit Alisdair adds:
]</i></p>


<blockquote>
<p>
Request 'Open'.  The issues in the paper go beyond just reducing
the number of signatures, but cover unifying the idea of the ordering
operation used by algorithms, containers and other library components.  At
least, it takes a first pass at the problem.
</p>

<p>
For me (personally) that was the more important part of the paper, and not
clearly addressed by the Summit resolution.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Too inventive, too late, would really need a paper. Moved to NAD Future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1112" href="#1112">1112.</a> bitsets and new style for loop</h3>
<p><b>Section:</b> 20.9 [template.bitset] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-06 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::bitset</tt> is a homogeneous container-like sequence of bits, yet it does
not model the Range concept so cannot be used with the new for-loop syntax.
It is the only such type in the library that does NOT support the new for
loop.
</p>
<p>
The obvious reason is that bitset does not support iterators.
</p>
<p>
At least two reasonable solutions are available:
</p>
<ol style="list-style-type:lower-roman">
<li>
Add an iterator interface to <tt>bitset</tt>, bringing its interface close to that
of <tt>std::array</tt>
</li>
<li>
Provide an unspecified concept_map for <tt>Range&lt;bitset&gt;</tt>.
</li>
</ol>
<p>
The latter will still need some kind of iterator-like adapter for <tt>bitset</tt>,
but gives implementers greater freedom on the details. E.g. begin/end return
some type that simply invokes <tt>operator[]</tt> on the object it wraps, and
increments its index on <tt>operator++</tt>.  A vendor can settle for <tt>InputIterator</tt>
support, rather than wrapping up a full <tt>RandomAccessIterator</tt>.
</p>
<p>
I have a mild preference for option (ii) as I think it is less work to
specify at this stage of the process, although (i) is probably more useful
in the long run.
</p>
<p>
Hmm, my wording looks a little woolly, as it does not say what the element
type of the range is.  Do I get a range of <tt>bool</tt>, <tt>bitset&lt;N&gt;::reference</tt>, or
something else entirely?
</p>
<p>
I guess most users will assume the behaviour of reference, but expect to
work with <tt>bool</tt>.  <tt>Bool</tt> is OK for read-only traversal, but you really need to
take a reference to a <tt>bitset::reference</tt> if you want to write back.
</p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote><p>
Move to Open.
We further recommend this be deferred until after the next Committee Draft.
</p></blockquote>

<p><i>[
2009-05-25 Alisdair adds:
]</i></p>


<blockquote>
<p>
I just stumbled over the <tt>Range concept_map</tt> for <tt>valarray</tt> and this should
probably set the precedent on how to write the wording.
</p>

<p><i>[
Howard: I've replaced the proposed wording with Alisdair's suggestion.
]</i></p>


</blockquote>

<p><i>[
2009-07-24 Daniel modifies the proposed wording for non-concepts.
]</i></p>


<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Mark as Tentatively NAD Future due to the loss of concepts.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
All concepts-related text has been removed from the draft.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Modify the section 20.9 [template.bitset] <tt>&lt;bitset&gt;</tt> synopsis by adding
the following at the end of the synopsis:
</p>
<blockquote><pre>
<ins>
// XX.X.X bitset range access [bitset.range]
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins>
</pre></blockquote>
</li>
<li>
<p>
Add a new section <ins>"bitset range access" [bitset.range]</ins>
after the current section 20.9.4 [bitset.operators] with the following series of
paragraphs:
</p>
<blockquote>
<p>
<ins>
1.  In the <tt>begin</tt> and <tt>end</tt> function templates that follow, <i>unspecified-1</i>
is a type that meets the requirements of a mutable random access
iterator (24.2.7 [random.access.iterators]) whose <tt>value_type</tt> is <tt>bool</tt> and
whose reference type is <tt>bitset&lt;N&gt;::reference</tt>.
<i>unspecified-2</i> is a type that meets the requirements of a constant
random access iterator (24.2.7 [random.access.iterators]) whose <tt>value_type</tt>
is <tt>bool</tt> and whose reference type is <tt>bool</tt>.
</ins>
</p>
<pre>
<ins>
template&lt;size_t N&gt; <i>unspecified-1</i> begin(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> begin(const bitset&lt;N&gt;&amp;);
</ins>
</pre>
<blockquote><p>
<ins>2.  Returns: an iterator referencing the first bit in the bitset.</ins>
</p></blockquote>

<pre><ins>
template&lt;size_t N&gt; <i>unspecified-1</i> end(bitset&lt;N&gt;&amp;);
template&lt;size_t N&gt; <i>unspecified-2</i> end(const bitset&lt;N&gt;&amp;);
</ins></pre>

<blockquote><p>
<ins>3.  Returns: an iterator referencing one past the last bit in the
bitset.</ins>
</p></blockquote>
</blockquote>
</li>
</ol>












<hr>
<h3><a name="1120" href="#1120">1120.</a> New type trait - remove_all</h3>
<p><b>Section:</b> 20.15 [meta] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-23 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sometimes it is necessary to remove all qualifiers from a type before
passing on to a further API.  A good example would be calling the
<tt>tuple</tt> query APIs <tt>tuple_size</tt> or <tt>tuple_element</tt>
with a deduced type inside a function template.  If the deduced type is
cv-qualified or a reference then the call will fail.  The solution is to
chain calls to
<tt>remove_cv&lt;remove_reference&lt;T&gt;::type&gt;::type</tt>, and
note that the order matters.
</p>
<p>
Suggest it would be helpful to add a new type trait,
<tt>remove_all</tt>, that removes all top-level qualifiers from a type
i.e. cv-qualification and any references.  Define the term in such a way
that if additional qualifiers are added to the language, then
<tt>remove_all</tt> is defined as stripping those as well.
</p>

<p><i>[
2009-10-14 Daniel adds:
]</i></p>


<blockquote><p>
<tt>remove_all</tt> seems too generic, a possible alternative matching
the current naming style could be <tt>remove_cv_reference</tt> or
<tt>remove_reference_cv</tt>. It should also be considered whether this
trait should also remove 'extents', or pointer 'decorations'. Especially
if the latter situations are considered as well, it might be easier to
chose the name not in terms of what it <em>removes</em> (which might be
a lot), but in terms of it <em>creates</em>. In this case I could think
of e.g. <tt>extract_value_type</tt>.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1121" href="#1121">1121.</a> Support for multiple arguments</h3>
<p><b>Section:</b> 20.16.4 [ratio.arithmetic] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-05-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ratio.arithmetic">issues</a> in [ratio.arithmetic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both add and multiply could sensibly be called with more than two arguments.
The variadic template facility makes such declarations simple, and is likely
to be frequently wrapped by end users if we do not supply the variant
ourselves.
</p>
<p>
We deliberately ignore divide at this point as it is not transitive.
Likewise, subtract places special meaning on the first argument so I do not
suggest extending that immediately.  Both could be supported with analogous
wording to that for add/multiply below.
</p>
<p>
Note that the proposed resolution is potentially incompatible with that
proposed for <a href="lwg-defects.html#921">921</a>, although the addition of the typedef to ratio would be
equally useful.
</p>

<p><i>[
2009-10-30 Alisdair adds:
]</i></p>


<blockquote>
<p>
The consensus of the group when we reviewed this in Santa Cruz was that
<a href="lwg-defects.html#921">921</a> would proceed to Ready as planned, and the
multi-paramater add/multiply templates should be renamed as
<tt>ratio_sum</tt> and <tt>ratio_product</tt> to avoid the problem
mixing template aliases with partial specializations.
</p>

<p>
It was also suggested to close this issue as NAD Future as it does not
correspond directly to any NB comment.  NBs are free to submit a
specific comment (and re-open) in CD2 though.
</p>

<p>
Walter Brown also had concerns on better directing the order of
evaluation to avoid overflows if we do proceed for 0x rather than TR1,
so wording may not be complete yet.
</p>

<p><i>[
Alisdair updates wording.
]</i></p>


</blockquote>

<p><i>[
2009-10-30 Howard:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the following type traits to p3 20.16 [ratio]
</p>

<blockquote><pre>
// ratio arithmetic
template &lt;class R1, class R2&gt; struct ratio_add;
template &lt;class R1, class R2&gt; struct ratio_subtract;
template &lt;class R1, class R2&gt; struct ratio_multiply;
template &lt;class R1, class R2&gt; struct ratio_divide;
<ins>template &lt;class R1, class ... RList&gt; struct ratio_sum;</ins>
<ins>template &lt;class R1, class ... RList&gt; struct ratio_product;</ins>
</pre></blockquote>

<p>
after 20.16.4 [ratio.arithmetic] p1: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_sum; // declared, never defined

template &lt;class R1&gt; struct ratio_sum&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_sum&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>

<p>
after 20.16.4 [ratio.arithmetic] p3: add
</p>

<blockquote><pre>
template &lt;class R1, class ... RList&gt; struct ratio_product; // declared, never defined

template &lt;class R1&gt; struct ratio_product&lt;R1&gt; : R1 {};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>

<pre>
template &lt;class R1, class R2, class ... RList&gt; 
 struct ratio_sum&lt;R1, R2, RList...&gt;
   : ratio_add&lt; R1, ratio_product&lt;R2, RList...&gt;&gt; {
};
</pre>

<blockquote><p>
<i>Requires:</i> <tt>R1</tt> and each element in parmater pack
<tt>RList</tt> is a specialization of class template <tt>ratio</tt>
</p></blockquote>
</blockquote>








<hr>
<h3><a name="1150" href="#1150">1150.</a> wchar_t, char16_t and char32_t filenames</h3>
<p><b>Section:</b> 27.9.5 [fstream] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP 73</b></p>

   <p><b>Description</b></p>
        <p>It is a problem
        from C++98, <tt>fstream</tt> cannot appoint a filename of wide
        character string(<tt>const wchar_t</tt> and <tt>const wstring&amp;</tt>).</p>
<p><b>Suggestion</b></p>
        <p>Add
        interface corresponding to <tt>wchar_t</tt>, <tt>char16_t</tt> and <tt>char32_t</tt>.</p>

<p><i>[
2009-07-01 Alisdair notes that this is a duplicate of <a href="lwg-closed.html#454">454</a> which has more
in-depth rationale.
]</i></p>


<p><i>[
2009-09-21 Daniel adds:
]</i></p>


<blockquote><p>
I suggest to mark this issue as NAD Future with the intend to
solve the issue with a single file path c'tor template assuming
a provision of a TR2 filesystem library.
</p></blockquote>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  This is a duplicate of <a href="lwg-closed.html#454">454</a>.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1154" href="#1154">1154.</a> <tt>complex</tt> should accept integral types</h3>
<p><b>Section:</b> 26.5 [complex.numbers] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> LWG <b>Opened:</b> 2009-06-28 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in [complex.numbers].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses FR 35</b></p>

<p><b>Description</b></p>
        <p>Instantiations of the class
        template <tt>complex&lt;&gt;</tt> have to be allowed for integral
        types, to reflect existing practice and ISO standards
        (LIA-III).</p>
        
<p><b>Suggestion</b></p>

<p><i>[
2009-10-26 Proposed wording in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3002.pdf">N3002</a>.
]</i></p>


<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote><p>
Moved to NAD Future.  Rationale added.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
There is no consensus for making this change at this time.
</p>


<p><b>Proposed resolution:</b></p><p>
Adopt
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3002.pdf">N3002</a>.
</p>




<hr>
<h3><a name="1173" href="#1173">1173.</a> "Equivalence" wishy-washiness</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2009-07-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue: The <tt>CopyConstructible</tt> requirements are wishy-washy.  It requires
that the copy is "equivalent" to the original, but "equivalent" is never
defined.
</p>
<p>
I believe this to be an example of a more general lack of rigor around
copy and assignment, although I haven't done the research to dig up all
the instances.
</p>
<p>
It's a problem because if you don't know what <tt>CopyConstructible</tt> means,
you also don't know what it means to copy a pair of <tt>CopyConstructible</tt>
types.  It doesn't prevent us from writing code, but it is a hole in our
ability to understand the meaning of copy.
</p>
<p>
Furthermore, I'm pretty sure that vector's copy constructor doesn't
require the elements to be <tt>EqualityComparable</tt>, so that table is actually
referring to some ill-defined notion of equivalence when it uses ==.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
Move to "Open". Dave is right that this is a big issue. Paper D2987
("Defining Move Special Member Functions", Bjarne Stroustrup and
Lawrence Crowl) touches on this but does not solve it. This issue is
discussed in Elements of Programming.
</p></blockquote>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This issue is quite vague, so it is difficult to know if and when it has been resolved.
John Lakos wrote a paper covering this area a while back, and there is a real interest 
in providing some sort of clean-up in the future. We need a more clearly draughted 
issues with an addressable set of concerns, ideally with a paper proposing a resolution, 
but for a future revision of the standard. Move to Tentatively NAD Future.
</p></blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1175" href="#1175">1175.</a> <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote><p>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</p></blockquote>

<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at 
both the clause 23 requirements tables and the constructor description of each unordered container to be sure.
</p>
<p>
Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.
</p>
<p>
Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[2011-02-26: Daniel provides wording]</i></p>


<p>I strongly suggest to clean-up the differences between requirement tables and individual
specifications. In the usual way, the most specific specifications wins, which is in this
case the wrong one. In regard to the concern expressed about missing <tt>DefaultConstructible</tt>
requirements of the value type I disagree: The function argument <tt>n</tt> is no size-control
parameter, but only some effective capacity parameter: No elements will be value-initialized
by these constructors. The necessary requirement for the value type, <tt>EmplaceConstructible</tt>
into <tt>*this</tt>, is already listed in Table 103 &mdash; Unordered associative container requirements.
Another part of the proposed resolution is the fact that there is an inconsistency of the
complexity counting when both a range <strong>and</strong> a bucket count is involved compared
to constructions where only bucket counts are provided: E.g. the construction <tt>X a(n);</tt>
has a complexity of <tt>n</tt> bucket allocations, but this part of the work is omitted for
<tt>X a(i, j, n);</tt>, even though it is considerable larger (in the average case) for 
<tt>n &#8811; distance(i, j)</tt>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The proposed wording looks good.  Move to Review.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Fix up some presentation issues with the wording, combining the big-O expressions into single
expressions rather than the sum of two separate big-Os.
</p>
<p>
Strike "constant or linear", prefer "linear in the number of buckets".
This allows for number of buckets being larger than requested <tt>n</tt> as well.
</p>
<p>
Default <tt>n</tt> to "unspecified" rather than "implementation-defined".  It seems an un-necessary
burden asking vendors to document a quantity that is easily determined through the public API of
these classes.
</p>
<p>
Replace <tt>distance(f,l)</tt> with "number of elements in the range <tt>[f,l)</tt>"
</p>
<p>
Retain in Review with the updated wording
</p>

<p><i>[2012, Portland: Move to Open]</i></p>

<p>
The wording still does not call out Pablo's original concern, that the element constructor is called
no more than <tt>N</tt> times, and that the <tt>N</tt> squared term applies to moves during rehash.
</p>

<p>
Inconsistent use of O(n)+O(N) vs. O(n+N), with a preference for the former.
</p>

<p>
AJM to update wording with a reference to "no more than <tt>N</tt> element constructor calls".
</p>

<p>
Matt concerned that calling out the O(n) requirements is noise, and dangerous noise in suggesting a precision
we do not mean.  The cost of constructing a bucket is very different to constructing an element of user-supplied
type.
</p>

<p>
AJM notes that if there are multiple rehashes, the 'n' complexity is probably not linear.
</p>

<p>
Matt suggests back to Open, Pablo suggests potentially NAD if we keep revisitting without achieving a resolution.
</p>

<p>
Matt suggests complexity we are concerned with is the number of operations, such as constructing elements, moving
nodes, and comparing/hashing keys.  We are less concerned with constructing buckets, which are generally noise in
this bigger picture.
</p>

<p><i>[2015-01-29 Telecon]</i></p>

<p>
AM: essentially correct, but do we want to complicate the spec?
<p/>
HH: Pablo has given us permission to NAD it
<p/>
JM: when I look at the first change in the P/R I find it mildly disturbing that the existing wording says you have a 
constant time constructor with a single element even if your <tt>n</tt> is 10^6, so I think adding this change makes people 
aware there might be a large cost in initializing the hash table, even though it doesn't show up in user-visible constructions.
<p/>
HH: one way to avoid that problem is make the default ctor <tt>noexcept</tt>. Then the container isn't allowed to create 
an arbitrarily large hash table
<p/>
AM: but this is the constructor where the user provides <tt>n</tt>
<p/>
MC: happy with the changes, except I agree with the editorial recommendation to keep the two &#x1d4aa;s separate.
<p/>
JW: yes, the constant '<tt>k</tt>' is different in &#x1d4aa;(n) and &#x1d4aa;(N)
<p/>
GR: do we want to talk about buckets at all
<p/>
JM: yes, good to highlight that bucket construction might be a significant cost
<p/>
HH: suggest we take the suggestion to split &#x1d4aa;(n+N) to &#x1d4aa;(n)+&#x1d4aa;(N) and move to Tentatively Ready
<p/>
GR: 23.2.1p2 says all complexity requirements are stated solely in terms of the number of operations on the contained 
object, so we shouldn't be stating complexity in terms of the hash table initialization
<p/>
HH: channeling Pete, there's an implicit "unless otherwise specified" everywhere.
<p/>
VV: seem to be requesting modifications that render this not Tentatively Ready
<p/>
GR: I think it can't be T/R
<p/>
AM: make the editorial recommendation, consider fixing 23.2.1/3 to give us permission to state complexity in terms 
of bucket initialization
<p/>
HH: only set it to Review after we get new wording to review 
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Update wording, revisit later.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Modify the following rows in Table 103 &mdash; Unordered associative container requirements to
add the explicit bucket allocation overhead of some constructions. As editorial recommendation it is 
suggested <em>not</em> to shorten the sum <tt>&#x1d4aa;(n) + &#x1d4aa;(<em>N</em>)</tt> to
<tt>&#x1d4aa;(n + <em>N</em>)</tt>, because two different work units are involved.</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf, eq)</tt><br/>
<tt>X a(i, j, n, hf, eq)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>eq</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf)</tt><br/>
<tt>X a(i, j, n, hf)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case &#x1d4aa;(<tt><i><ins>n + </ins>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n)</tt><br/>
<tt>X a(i, j, n)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hasher()</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case &#x1d4aa;(<tt><i><ins>n + </ins>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case &#x1d4aa;(<tt><i><ins>n + </ins>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 23.5.4.2 [unord.map.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_map(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_map(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.5.2 [unord.multimap.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multimap(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.2 [unord.set.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_set(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_set(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.7.2 [unord.multiset.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multiset(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: <del>Constant</del><ins>Linear in the number of buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multiset(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>unspecified</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Linear in the number of buckets.
In the average case linear in <tt><i>N</i></tt> and in the worst case quadratic in <tt><i>N</i></tt> to insert
the elements, where <tt><i>N</i></tt> is equal to number of elements in the range <tt>[f,l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1184" href="#1184">1184.</a> Feature request: dynamic bitset</h3>
<p><b>Section:</b> 23.3.11 [vector] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-07-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector">issues</a> in [vector].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Opened at Alisdair's request, steming from <a href="lwg-closed.html#96">96</a>.
Alisdair recommends NAD Future.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  We want a heap allocated bitset, but we don't have one today and
don't have time to add one.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1188" href="#1188">1188.</a> Unordered containers should have a minimum load factor as well as a maximum</h3>
<p><b>Section:</b> 23.2.5 [unord.req], 23.5 [unord] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2009-08-10 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Unordered associative containers have a notion of a maximum load factor:
when the number of elements grows large enough, the containers
automatically perform a rehash so that the number of elements per bucket
stays below a user-specified bound. This ensures that the hash table's
performance characteristics don't change dramatically as the size
increases.
</p>

<p>
For similar reasons, Google has found it useful to specify a minimum
load factor: when the number of elements shrinks by a large enough, the
containers automatically perform a rehash so that the number of elements
per bucket stays above a user-specified bound. This is useful for two
reasons. First, it prevents wasting a lot of memory when an unordered
associative container grows temporarily. Second, it prevents amortized
iteration time from being arbitrarily large; consider the case of a hash
table with a billion buckets and only one element. (This was discussed
even before TR1 was published; it was TR issue 6.13, which the LWG
closed as NAD on the grounds that it was a known design feature.
However, the LWG did not consider the approach of a minimum load
factor.)
</p>

<p>
The only interesting question is when shrinking is allowed. In principle
the cleanest solution would be shrinking on erase, just as we grow on
insert. However, that would be a usability problem; it would break a
number of common idioms involving erase. Instead, Google's hash tables
only shrink on insert and rehash.
</p>

<p>
The proposed resolution allows, but does not require, shrinking in
rehash, mostly because a postcondition for rehash that involves the
minimum load factor would be fairly complicated. (It would probably have
to involve a number of special cases and it would probably have to
mention yet another parameter, a minimum bucket count.)
</p>

<p>
The current behavior is equivalent to a minimum load factor of 0. If we
specify that 0 is the default, this change will have no impact on
backward compatibility.
</p>


<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
This seems to a useful extension, but is too late for 0x.

Move to Tentatively NAD Future.
</p></blockquote>

<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Add two new rows, and change rehash's postcondition in the unordered
associative container requirements table in 23.2.5 [unord.req]:
</p>

<blockquote>
<table border="1">
<caption>Table 87 &mdash; Unordered associative container requirements
(in addition to container)</caption>

<tr>
<th>Expression</th><th>Return type</th><th>Assertion/note pre-/post-condition</th>
<th>Complexity</th>
</tr>
<tr>
<td><ins>
<tt>a.min_load_factor()</tt>
</ins></td>
<td><ins>
<tt>float</tt>
</ins></td>
<td><ins>
Returns a non-negative number that the container attempts to keep the
load factor greater than or equal to. The container automatically
decreases the number of buckets as necessary to keep the load factor
above this number.
</ins></td>
<td><ins>
constant
</ins></td>
</tr>

<tr>
<td><ins><tt>a.min_load_factor(z)</tt></ins></td>
<td><ins><tt>void</tt></ins></td>
<td><ins>Pre: <tt>z</tt> shall be non-negative. Changes the container's minimum
load factor, using <tt>z</tt> as a hint. [<i>Footnote:</i> the minimum
load factor should be significantly smaller than the maximum. 
If <tt>z</tt> is too large, the implementation may reduce it to a more sensible value.]
</ins></td>
<td><ins>
constant
</ins></td>
</tr>
<tr>
<td><tt>a.rehash(n)</tt></td>
<td><tt>void</tt></td>
<td>
Post: <ins><tt>a.bucket_count() &gt;= n</tt>, and <tt>a.size() &lt;= a.bucket_count()
* a.max_load_factor()</tt>. [<i>Footnote:</i> It is intentional that the
postcondition does not mention the minimum load factor.
This member function is primarily intended for cases where the user knows
that the container's size will increase soon, in which case the container's
load factor will temporarily fall below <tt>a.min_load_factor()</tt>.]</ins>
<del>
<tt>a.bucket_cout &gt; a.size() / a.max_load_factor()</tt> and <tt>a.bucket_count()
&gt;= n</tt>.
</del>
</td>
<td>
Average case linear in <tt>a.size()</tt>, worst case quadratic.
</td>
</tr>
</table>
</blockquote>

<p>
Add a footnote to 23.2.5 [unord.req] p12:
</p>

<blockquote>
<p>
The insert members shall not affect the validity of references to
container elements, but may invalidate all iterators to the container.
The erase members shall invalidate only iterators and references to the
erased elements.
</p>

<blockquote><p>
[A consequence of these requirements is that while insert may change the
number of buckets, erase may not. The number of buckets may be reduced
on calls to insert or rehash.]
</p></blockquote>
</blockquote>

<p>
Change paragraph 13:
</p>

<blockquote><p>
The insert members shall not affect the validity of iterators if
<del><tt>(N+n) &lt; z * B</tt></del> <ins><tt>zmin * B &lt;= (N+n) &lt;= zmax * B</tt></ins>,
where <tt>N</tt> is the number of elements in
the container prior to the insert operation, <tt>n</tt> is the number of
elements inserted, <tt>B</tt> is the container's bucket count,
<ins><tt>zmin</tt> is the container's minimum load factor,</ins>
and <tt>z<ins>max</ins></tt> is the container's maximum load factor.
</p></blockquote>

<p>
Add to the <tt>unordered_map</tt> class synopsis in section 23.5.4 [unord.map],
the <tt>unordered_multimap</tt> class synopsis
in 23.5.5 [unord.multimap], the <tt>unordered_set</tt> class synopsis in
23.5.6 [unord.set], and the <tt>unordered_multiset</tt> class synopsis
in 23.5.7 [unord.multiset]:
</p>

<blockquote><pre><ins>
float min_load_factor() const;
void min_load_factor(float z);
</ins></pre></blockquote>

<p>
In 23.5.4.2 [unord.map.cnstr], 23.5.5.2 [unord.multimap.cnstr], 23.5.6.2 [unord.set.cnstr], and
23.5.7.2 [unord.multiset.cnstr], change:
</p>

<blockquote><p>
... <tt>max_load_factor()</tt> returns 1.0 <ins>and
<tt>min_load_factor()</tt> returns 0</ins>.
</p></blockquote>





<hr>
<h3><a name="1201" href="#1201">1201.</a> Do we always want to unwrap <tt>ref</tt>-wrappers in <tt>make_tuple</tt></h3>
<p><b>Section:</b> 20.5.2.4 [tuple.creation], 20.4 [pairs] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-09-05 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.creation">issues</a> in [tuple.creation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Spotting a recent thread on the boost lists regarding collapsing
optional representations in <tt>optional&lt;optional&lt;T&gt;&gt;</tt> instances, I wonder if
we have some of the same issues with <tt>make_tuple</tt>, and now <tt>make_pair</tt>?
</p>

<p>
Essentially, if my generic code in my own library is handed a
<tt>reference_wrapper</tt> by a user, and my library in turn delegates some logic
to <tt>make_pair</tt> or <tt>make_tuple</tt>, then I am going to end up with a <tt>pair</tt>/<tt>tuple</tt>
holding a real reference rather than the intended reference wrapper.
</p>

<p>
There are two things as a library author I can do at this point:
</p>

<ol style="list-style-type:lower-roman">
<li>
document my library also has the same reference-wrapper behaviour as
<tt>std::make_tuple</tt>
</li>
<li>
roll my own <tt>make_tuple</tt> that does not unwrap rereferences, a lost
opportunity to re-use the standard library.
</li>
</ol>

<p>
(There may be some metaprogramming approaches my library can use to wrap
the <tt>make_tuple</tt> call, but all will be significantly more complex than
simply implementing a simplified <tt>make_tuple</tt>.)
</p>

<p>
Now I don't propose we lose this library facility, I think unwrapping
references will be the common behaviour.  However, we might want to
consider adding another overload that does nothing special with
<tt>ref</tt>-wrappers.  Note that we already have a second overload of 
<tt>make_tuple</tt> in the library, called <tt>tie</tt>.
</p>

<p><i>[
2009-09-30 Daniel adds:
]</i></p>


<blockquote>
<p>
I suggest to change the currently proposed paragraph for
<tt>make_simple_pair</tt>
</p>

<blockquote><pre>
template&lt;typename... Types&gt;
  pair&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_pair(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<del><i>Type requirements:</i> <tt>sizeof...(Types) == 2</tt>.</del>
<ins><i>Remarks:</i> The program shall be ill-formed, if
<tt>sizeof...(Types) != 2</tt>.</ins>
</p>
<p>
...
</p>
</blockquote>
</blockquote>

<p>
or alternatively (but with a slightly different semantic):
</p>

<blockquote>
<blockquote><p>
<i>Remarks:</i> If <tt>sizeof...(Types) != 2</tt>, this function shall not
participate in overload resolution.
</p></blockquote>
</blockquote>

<p>
to follow a currently introduced style and because the library does
not have yet a specific "<i>Type requirements</i>" element. If such thing
would be considered as useful this should be done as a separate
issue. Given the increasing complexity of either of these wordings
it might be preferable to use the normal two-argument-declaration
style again in either of the following ways:
</p>

<ol style="list-style-type:upper-alpha">
<li>
<pre>template&lt;class T1, class T2&gt;
pair&lt;typename decay&lt;T1&gt;::type, typename decay&lt;T2&gt;::type&gt;
make_simple_pair(T1&amp;&amp; t1, T2&amp;&amp; t2);
</pre>
</li>
<li>
<pre>template&lt;class T1, class T2&gt;
pair&lt;V1, V2&gt; make_simple_pair(T1&amp;&amp; t1, T2&amp;&amp; t2);
</pre>
<blockquote><p>
Let <tt>V1</tt> be <tt>typename decay&lt;T1&gt;::type</tt> and <tt>V2</tt> be
<tt>typename decay&lt;T2&gt;::type</tt>.
</p></blockquote>
</li>
</ol>

</blockquote>

<p><i>[
2009-10 post-Santa Cruz:
]</i></p>


<blockquote><p>
Mark as Tentatively NAD Future.
</p></blockquote>



<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following function to 20.4 [pairs] and signature in
appropriate synopses:
</p>

<blockquote><pre>
template&lt;typename... Types&gt;
  pair&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_pair(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<i>Type requirements:</i> <tt>sizeof...(Types) == 2</tt>.
</p>
<p>
<i>Returns:</i> <tt>pair&lt;typename decay&lt;Types&gt;::type...&gt;(std::forward&lt;Types&gt;(t)...)</tt>.
</p>
</blockquote>
</blockquote>

<p><i>[
Draughting note: I chose a variadic representation similar to <tt>make_tuple</tt>
rather than naming both types as it is easier to read through the
clutter of metaprogramming this way.  Given there are exactly two
elements, the committee may prefer to draught with two explicit template
type parameters instead
]</i></p>


<p>
Add the following function to 20.5.2.4 [tuple.creation] and
signature in appropriate synopses:
</p>

<blockquote><pre>
template&lt;typename... Types&gt;
  tuple&lt;typename decay&lt;Types&gt;::type...&gt; make_simple_tuple(Types&amp;&amp;... t);
</pre>
<blockquote>
<p>
<i>Returns:</i> <tt>tuple&lt;typename decay&lt;Types&gt;::type...&gt;(std::forward&lt;Types&gt;(t)...)</tt>.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1203" href="#1203">1203.</a> More useful rvalue stream insertion</h3>
<p><b>Section:</b> 27.7.3.9 [ostream.rvalue], 27.7.2.6 [istream.rvalue] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2009-09-06 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ostream.rvalue">active issues</a> in [ostream.rvalue].</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.rvalue">issues</a> in [ostream.rvalue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.7.3.9 [ostream.rvalue] was created to preserve the ability to insert
into (and extract from 27.7.2.6 [istream.rvalue]) rvalue streams:
</p>

<blockquote><pre>
template &lt;class charT, class traits, class T&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>os &lt;&lt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt>os</tt>
</p>
</blockquote>
</blockquote>

<p>
This is good as it allows code that wants to (for example) open, write to, and
close an <tt>ofstream</tt> all in one statement:
</p>

<blockquote><pre>
std::ofstream("log file") &lt;&lt; "Some message\n";
</pre></blockquote>

<p>
However, I think we can easily make this "rvalue stream helper" even easier to
use.  Consider trying to quickly create a formatted string.  With the current
spec you have to write:
</p>

<blockquote><pre>
std::string s = static_cast&lt;std::ostringstream&amp;&gt;(std::ostringstream() &lt;&lt; "i = " &lt;&lt; i).str();
</pre></blockquote>

<p>
This will store "<tt>i = 10</tt>" (for example) in the string <tt>s</tt>.  Note
the need to cast the stream back to <tt>ostringstream&amp;</tt> prior to using
the member <tt>.str()</tt>.  This is necessary because the inserter has cast
the <tt>ostringstream</tt> down to a more generic <tt>ostream</tt> during the
insertion process.
</p>

<p>
I believe we can re-specify the rvalue-inserter so that this cast is unnecessary.
Thus our customer now has to only type:
</p>

<blockquote><pre>
std::string s = (std::ostringstream() &lt;&lt; "i = " &lt;&lt; i).str();
</pre></blockquote>

<p>
This is accomplished by having the rvalue stream inserter return an rvalue of
the same type, instead of casting it down to the base class.  This is done by
making the stream generic, and constraining it to be an rvalue of a type derived
from <tt>ios_base</tt>.
</p>

<p>
The same argument and solution also applies to the inserter.  This code has been
implemented and tested.
</p>

<p><i>[
2009 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  No concensus for change.
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Change 27.7.2.6 [istream.rvalue]:
</p>

<blockquote><pre>
template &lt;class <del>charT, class traits</del> <ins>Istream</ins>, class T&gt;
  <del>basic_istream&lt;charT, traits&gt;&amp;</del> <ins>Istream&amp;&amp;</ins>
  operator&gt;&gt;(<del>basic_istream&lt;charT, traits&gt;</del> <ins>Istream</ins>&amp;&amp; is, T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>is &gt;&gt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt><ins>std::move(</ins>is<ins>)</ins></tt>
</p>
<p><ins>
3 <i>Remarks:</i> This signature shall participate in overload resolution if
and only if <tt>Istream</tt> is not an lvalue reference type and is derived from
<tt>ios_base</tt>.
</ins></p>
</blockquote>
</blockquote>

<p>
Change 27.7.3.9 [ostream.rvalue]:
</p>

<blockquote><pre>
template &lt;class <del>charT, class traits</del> <ins>Ostream</ins>, class T&gt;
  <del>basic_ostream&lt;charT, traits&gt;&amp;</del> <ins>Ostream&amp;&amp;</ins>
  operator&lt;&lt;(<del>basic_ostream&lt;charT, traits&gt;</del> <ins>Ostream</ins>&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
1 <i>Effects:</i> <tt>os &lt;&lt; x</tt>
</p>
<p>
2 <i>Returns:</i> <tt><ins>std::move(</ins>os<ins>)</ins></tt>
</p>
<p><ins>
3 <i>Remarks:</i> This signature shall participate in overload resolution if
and only if <tt>Ostream</tt> is not an lvalue reference type and is derived from
<tt>ios_base</tt>.
</ins></p>
</blockquote>
</blockquote>






<hr>
<h3><a name="1213" href="#1213">1213.</a> Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="lwg-defects.html#208">208</a> (including further updates by <a href="lwg-defects.html#278">278</a>). In
24.2 [iterator.requirements] as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="lwg-defects.html#208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote><p>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</p></blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote><p>
An iterator is valid if it is dereferenceable or past-the-end.
</p></blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was incomplete, because by restricting feasible expressions of singular
iterators to destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 20.10.10 [specialized.algorithms]/1 says:
</p>

<blockquote><p>
In all of the following algorithms, the formal template parameter <tt>ForwardIterator</tt> 
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</p></blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In 99 [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote><p>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &mdash;<i>end note</i>]
</p></blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote><p>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</p></blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
Doesn't need to be resolved for Ox
</p>


<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p>
Consider to await the paper.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1217" href="#1217">1217.</a> Quaternion support</h3>
<p><b>Section:</b> 26.5 [complex.numbers] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Ted Shaneyfelt <b>Opened:</b> 2009-09-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in [complex.numbers].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Concerning mathematically proper operation of the type:
</p>

<blockquote><pre>
complex&lt;complex&lt;T&gt; &gt;
</pre></blockquote>

<p>
Generally accepted mathematical semantics of such a construct correspond
to quaternions through Cayly-Dickson construct
</p>

<blockquote><pre>
(w+xi) + (y+zi) j
</pre></blockquote>

<p>
The proper implementation seems straightforward by adding a few
declarations like those below. I have included operator definition for
combining real scalars and complex types, as well, which seems
appropriate, as algebra of complex numbers allows mixing complex and
real numbers with operators. It also allows for constructs such as
<tt>complex&lt;double&gt; i=(0,1),  x = 12.34 + 5*i;</tt>
</p>

<p>
Quaternions are often used in areas such as computer graphics, where,
for example, they avoid the problem of Gimbal lock when rotating objects
in 3D space, and can be more efficient than matrix multiplications,
although I am applying them to a different field.
</p>

<pre>
/////////////////////////ALLOW OPERATORS TO COMBINE REAL SCALARS AND COMPLEX VALUES /////////////////////////
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()+a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator+(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a+x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()-a, x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator-(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a-x.real(), x.imag());
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const complex&lt;T&gt; x,const S a) {
    complex&lt;T&gt; result(x.real()*a, x.imag()*a);
    return result;
}
template&lt;typename T,typename S&gt; complex&lt;T&gt; operator*(const S a,const complex&lt;T&gt; x) {
    complex&lt;T&gt; result(a*x.real(), a*x.imag());
    return result;
}

/////////////////////////PROPERLY IMPLEMENT QUATERNION SEMANTICS/////////////////////////
template&lt;typename T&gt; double normSq(const complex&lt;complex&lt;T&gt; &gt;q) {
    return q.real().real()*q.real().real()
         + q.real().imag()*q.real().imag()
         + q.imag().real()*q.imag().real()
         + q.imag().imag()*q.imag().imag();
}
template&lt;typename T&gt; double norm(const complex&lt;complex&lt;T&gt; &gt;q) {
    return sqrt(normSq(q));
}
/////// Cayley-Dickson Construction
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; conj(const complex&lt;complex&lt;T&gt; &gt; x) {
    complex&lt;complex&lt;T&gt; &gt; result(conj(x.real()),-x.imag());
    return result;
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator*(const complex&lt;complex&lt;T&gt; &gt; ab,const complex&lt;complex&lt;T&gt; &gt; cd) {
    complex&lt;T&gt; re(ab.real()*cd.real()-conj(cd.imag())*ab.imag());
    complex&lt;T&gt; im(cd.imag()*ab.real()+ab.imag()*conj(cd.real()));
    complex&lt;complex&lt;double&gt; &gt; q(re,im);
    return q;
}
//// Quaternion division
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; q,const S a) {
    return q * (1/a);
}
template&lt;typename S,typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const S a,const complex&lt;complex&lt;T&gt; &gt; q) {
    return a*conj(q)/normSq(q);
}
template&lt;typename T&gt; complex&lt;complex&lt;T&gt; &gt; operator/(const complex&lt;complex&lt;T&gt; &gt; n, const complex&lt;complex&lt;T&gt; &gt; d) {
    return n * (conj(d)/normSq(d));
}
</pre>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  There is no consensus or time to move this into C++0X.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1235" href="#1235">1235.</a> Issue with C++0x random number proposal</h3>
<p><b>Section:</b> 99 [rand.concept.dist] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Matthias Troyer <b>Opened:</b> 2009-10-12 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There exist optimized, vectorized vendor libraries for the creation of
random number generators, such as Intel's MKL [1] and AMD's ACML [2]. In
timing tests we have seen a performance gain of a factor of up to 80
(eighty) compared to a pure C++ implementation (in Boost.Random) when
using these generator to generate a sequence of normally distributed
random numbers. In codes dominated by the generation of random numbers
(we have application codes where random number generation is more than
50% of the CPU time) this factor 80 is very significant.
</p>

<p>
To make use of these vectorized generators, we use a C++ class modeling
the <tt>RandomNumberEngine</tt> concept and forwarding the generation of random
numbers to those optimized generators. For example:
</p>

<blockquote><pre>
namespace mkl {
 class mt19937 {.... };
}
</pre></blockquote>

<p>
For the generation of random variates we also want to dispatch to
optimized vectorized functions in the MKL or ACML libraries. See this
example:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::normal_distribution&lt;double&gt; dist;

double n = dist(eng);
</pre></blockquote>

<p>
Since the variate generation is done through the <tt>operator()</tt> of the
distribution there is no customization point to dispatch to Intel's or
AMD's optimized functions to generate normally distributed numbers based
on the <tt>mt19937</tt> generator. Hence, the performance gain of 80 cannot be
achieved.
</p>

<p>
Contrast this with TR1:
</p>

<blockquote><pre>
mkl::mt19937 eng;
std::tr1::normal_distribution&lt;double&gt; dist;
std::tr1::variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; rng(eng,dist);
double n = rng();
</pre></blockquote>

<p>
This - admittedly much uglier from an aestethic point of view - design
allowed optimization by specializing the <tt>variate_generator</tt> template for
<tt>mkl::mt19937</tt>:
</p>

<blockquote><pre>
namespace std { namespace tr1 {

template&lt;&gt;
class variate_generator&lt;mkl::mt19937,std::tr1::normal_distribution&lt;double&gt; &gt; { .... };

} }
</pre></blockquote>

<p>
A similar customization point is missing in the C++0x design and
prevents the optimized vectorized version to be used.
</p>

<p>
Suggested resolution:
</p>

<p>
Add a customization point to the distribution concept. Instead of the
<tt>variate_generator</tt> template this can be done through a call to a
free function <tt>generate_variate</tt> found by ADL instead of
<tt>operator()</tt> of the distribution:
</p>

<blockquote><pre>
template &lt;RandomNumberDistribution, class RandomNumberEngine&gt;
typename RandomNumberDistribution ::result_type
generate_variate(RandomNumberDistribution const&amp; dist, RandomNumberEngine&amp; eng);
</pre></blockquote>

<p>
This function can be overloaded for optimized enginges like
<tt>mkl::mt19937</tt>.
</p>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
NAD Future.  No time to add this feature for C++0X.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1238" href="#1238">1238.</a> defining algorithms taking iterator for range</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2009-10-15 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library has many algorithms that take a source range represented by
a pair of iterators, and the start of some second sequence given by a
single iterator.  Internally, these algorithms will produce undefined
behaviour if the second 'range' is not as large as the input range, but
none of the algorithms spell this out in Requires clauses, and there is
no catch-all wording to cover this in clause 17 or the front matter of
25.
</p>

<p>
There was an attempt to provide such wording in paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a>
but this
seems incidental to the focus of the paper, and getting the wording of
this issue right seems substantially more difficult than the simple
approach taken in that paper.  Such wording will be removed from an
updated paper, and hopefully tracked via the LWG issues list instead.
</p>

<p>
It seems there are several classes of problems here and finding wording
to solve all in one paragraph could be too much.  I suspect we need
several overlapping requirements that should cover the desired range of
behaviours.
</p>

<p>
Motivating examples:
</p>

<p>
A good initial example is the <tt>swap_ranges</tt> algorithm.  Here there is a
clear requirement that <tt>first2</tt> refers to the start of a valid range at
least as long as the range <tt>[first1, last1)</tt>.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf">n2944</a> tries to solve this
by positing a hypothetical <tt>last2</tt> iterator that is implied by the
signature, and requires <tt>distance(first2,last2) &lt; distance(first1,last1)</tt>.
 This mostly works, although I am uncomfortable assuming that <tt>last2</tt> is
clearly defined and well known without any description of how to obtain
it (and I have no idea how to write that).
</p>

<p>
A second motivating example might be the <tt>copy</tt> algorithm.  Specifically,
let us image a call like:
</p>

<blockquote><pre>
copy(istream_iterator&lt;int&gt;(is),istream_iterator(),ostream_iterator&lt;int&gt;(os));
</pre></blockquote>

<p>
In this case, our input iterators are literally simple <tt>InputIterators</tt>,
and the destination is a simple <tt>OutputIterator</tt>.  In neither case am I
happy referring to <tt>std::distance</tt>, in fact it is not possible for the
<tt>ostream_iterator</tt> at all as it does not meet the requirements.  However,
any wording we provide must cover both cases.  Perhaps we might deduce
<tt>last2 == ostream_iterator&lt;int&gt;{}</tt>, but that might not always be valid for
user-defined iterator types.  I can well imagine an 'infinite range'
that writes to <tt>/dev/null</tt> and has no meaningful <tt>last2</tt>.
</p>

<p>
The motivating example in <a
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2944.pdf"
>n2944</a> is <tt>std::equal</tt>, and that seems to fall somewhere between the
two.
</p>

<p>
Outlying examples might be <tt>partition_copy</tt> that takes two output
iterators, and the <tt>_n</tt> algorithms where a range is specified by a
specific number of iterations, rather than traditional iterator pair. 
We should also <em>not</em> accidentally apply inappropriate constraints to
<tt>std::rotate</tt> which takes a third iterator that is not intended to be a
separate range at all.
</p>

<p>
I suspect we want some wording similar to:
</p>

<blockquote><p>
For algorithms that operate on ranges where the end iterator of the
second range is not specified, the second range shall contain at least
as many elements as the first.
</p></blockquote>

<p>
I don't think this quite captures the intent yet though.  I am not sure
if 'range' is the right term here rather than sequence.  More awkwardly,
I am not convinced we can describe an Output sequence such as produce by
an <tt>ostream_iterator</tt> as "containing elements", at least not as a
precondition to the call before they have been written.
</p>

<p>
Another idea was to describe require that the trailing iterator support
at least distance(input range) applications of <tt>operator++</tt> and may be
written through the same number of times if a mutable/output iterator.
</p>

<p>
We might also consider handling the case of an output range vs. an input
range in separate paragraphs, if that simplifies how we describe some of
these constraints.
</p>

<p><i>[
2009-11-03 Howard adds:
]</i></p>


<blockquote><p>
Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
</p></blockquote>


<p><b>Rationale:</b></p>
<p>
Does not have sufficient support at this time. May wish to reconsider for a
future standard.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1242" href="#1242">1242.</a> Enable SCARY iterators</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Herb Sutter <b>Opened:</b> 2009-10-21 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2980.pdf">N2980</a>.
</p>

<p><i>[
2009-10 Santa Cruz
]</i></p>


<blockquote><p>
The paper was lengthy discussed but considerable concern remained to add this feature to C++0x. 
Strong consensus was found to consider it for C++1x, though.
</p></blockquote>


<p><b>Proposed resolution:</b></p><p>
The LWG does not wish to make a change at this time. 
</p>




<hr>
<h3><a name="1282" href="#1282">1282.</a> A proposal to add <tt>std::split</tt> algorithm</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Igor Semenov <b>Opened:</b> 2009-12-07 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<ol style="list-style-type:upper-roman">

<li>
<p>
Motivation and Scope
</p>
<p>
Splitting strings into parts by some set of delimiters is an often task, but
there is no simple and generalized solution in C++ Standard. Usually C++
developers use <tt>std::basic_stringstream&lt;&gt;</tt> to split string into
parts, but there are several inconvenient restrictions:
</p>

<ul>
<li>
we cannot explicitly assign the set of delimiters;
</li>
<li>
this approach is suitable only for strings, but not for other types of
containers;
</li>
<li>
we have (possible) performance leak due to string instantiation.
</li>
</ul>
</li>

<li>
<p>
Impact on the Standard
</p>
<p>
This algorithm doesn't interfere with any of current standard algorithms.
</p>
</li>

<li>
<p>
Design Decisions
</p>
<p>
This algorithm is implemented in terms of input/output iterators. Also, there is
one additional wrapper for <tt>const CharType *</tt> specified delimiters.
</p>
</li>

<li>
<p>
Example implementation
</p>
<pre>
template&lt; class It, class DelimIt, class OutIt &gt;
void split( It begin, It end, DelimIt d_begin, DelimIt d_end, OutIt out )
{
   while ( begin != end )
   {
       It it = std::find_first_of( begin, end, d_begin, d_end );
       *out++ = std::make_pair( begin, it );
       begin = std::find_first_of( it, end, d_begin, d_end,
           std::not2( std::equal_to&lt; typename It::value_type &gt;() ) );
   }
}

template&lt; class It, class CharType, class OutIt &gt;
void split( It begin, It end, const CharType * delim, OutIt out )
{
   split( begin, end, delim, delim + std::strlen( delim ), out );
}
</pre>
</li>

<li>
<p>
Usage
</p>
<pre>
std::string ss( "word1 word2 word3" );
std::vector&lt; std::pair&lt; std::string::const_iterator, std::string::const_iterator &gt; &gt; v;
split( ss.begin(), ss.end(), " ", std::back_inserter( v ) );

for ( int i = 0; i &lt; v.size(); ++i )
{
   std::cout &lt;&lt; std::string( v[ i ].first, v[ i ].second ) &lt;&lt; std::endl;
}
// word1
// word2
// word3
</pre>
</li>

</ol>

<p><i>[
2010-01-22 Moved to Tentatively NAD Future after 5 positive votes on c++std-lib.
Rationale added below.
]</i></p>



<p><b>Rationale:</b></p>
<p>
The LWG is not considering completely new features for standardization at this
time.  We would like to revisit this good suggestion for a future TR and/or
standard.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis in 25.1 [algorithms.general]:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );

template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre></blockquote>

<p>
Add a new section [alg.split]:
</p>

<blockquote><pre>
template&lt; class ForwardIterator1, class ForwardIterator2, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              ForwardIterator2 delimiter_first, ForwardIterator2 delimiter_last,
              OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> splits the range <tt>[first, last)</tt> into parts, using any
element of <tt>[delimiter_first, delimiter_last)</tt> as a delimiter. Results
are pushed to output iterator in the form of <tt>std::pair&lt;ForwardIterator1,
ForwardIterator1&gt;</tt>. Each of these pairs specifies a maximal subrange of
<tt>[first, last)</tt> which does not contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

<pre>
template&lt; class ForwardIterator1, class CharType, class OutputIterator &gt;
  void split( ForwardIterator1 first, ForwardIterator1 last,
              const CharType * delimiters, OutputIterator result );
</pre>

<blockquote>
<p>
1. <i>Effects:</i> split the range <tt>[first, last)</tt> into parts, using any
element of <tt>delimiters</tt> (interpreted as zero-terminated string) as a
delimiter. Results are pushed to output iterator in the form of
<tt>std::pair&lt;ForwardIterator1, ForwardIterator1&gt;</tt>. Each of these
pairs specifies a maximal subrange of <tt>[first, last)</tt> which does not
contain a delimiter.
</p>
<p>
2. <i>Returns:</i> nothing.
</p>
<p>
3. <i>Complexity:</i> Exactly <tt>last - first</tt> assignments.
</p>
</blockquote>

</blockquote>





<hr>
<h3><a name="1289" href="#1289">1289.</a> Generic casting requirements for smart pointers</h3>
<p><b>Section:</b> 20.2 [utility] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Ion Gazta&ntilde;aga <b>Opened:</b> 2009-12-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility">issues</a> in [utility].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In section 17.6.3.5 [allocator.requirements], Table 40 &mdash; Allocator requirements,
the following expression is required for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>
<tr>
<td><tt>static_cast&lt;X::pointer&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static_cast&lt;X::pointer&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>
</table>
</blockquote>

<p>
To achieve this expression, a smart pointer writer must introduce an explicit
conversion operator from <tt>smart_ptr&lt;void&gt;</tt> to
<tt>smart_ptr&lt;T&gt;</tt> so that
<tt>static_cast&lt;pointer&gt;(void_ptr)</tt> is a valid expression.
Unfortunately this explicit conversion weakens the safety of a smart pointer
since the following expression (invalid for raw pointers) would become valid:
</p>

<blockquote><pre>
smart_ptr&lt;void&gt; smart_v = ...;
smart_ptr&lt;T&gt; smart_t(smart_v);
</pre></blockquote>

<p>
On the other hand, <tt>shared_ptr</tt> also defines its own casting functions in
20.11.2.2.9 [util.smartptr.shared.cast], and although it's unlikely that a
programmer will use <tt>shared_ptr</tt> as <tt>allocator::pointer</tt>, having
two different ways to do the same cast operation does not seem reasonable. A
possible solution would be to replace <tt>static_cast&lt;X::pointer&gt;(w)</tt>
expression with a user customizable (via ADL)
<tt>static_pointer_cast&lt;value_type&gt;(w)</tt>, and establish the
<tt>xxx_pointer_cast</tt> functions introduced by <tt>shared_ptr</tt> as the
recommended generic casting utilities of the standard.
</p>

<p>
Unfortunately, we've experienced problems in Boost when trying to establish
<tt>xxx_pointer_cast</tt> as customization points for generic libraries (<a
href="http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html"
>http://objectmix.com/c/40424-adl-lookup-explicit-template-parameters.html</a>)
because these casting functions are called with explicit template parameters and
the standard says in 14.8.1 [temp.arg.explicit] p.8 "Explicit template
argument specification":
</p>

<blockquote><p>
8 ...But when a function template with explicit template arguments is used, the
call does not have the correct syntactic form unless there is a function
template with that name visible at the point of the call. If no such name is
visible, the call is not syntactically well-formed and argument-dependent lookup
does not apply.
</p></blockquote>

<p>
So we can do this:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_swap(BasePtr p)
{
  //ADL customization point
  swap(p, p);
  //...
}
</pre></blockquote>

<p>
but not the following:
</p>

<blockquote><pre>
template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;
  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);
}
</pre></blockquote>

<p>
The solution to make <tt>static_pointer_cast</tt> a customization point is to
add a generic declaration (no definition) of <tt>static_pointer_cast</tt> in a
namespace (like <tt>std</tt>) and apply "<tt>using
std::static_pointer_cast</tt>" declaration to activate ADL:
</p>

<blockquote><pre>
namespace std{

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

}

template&lt;class BasePtr&gt;
void generic_ptr_algo(BasePtr p)
{
  typedef std::pointer_traits&lt;BasePtr&gt;::template
     rebind&lt;Derived&gt; DerivedPtr;

  //ADL applies because static_pointer_cast is made
  //  visible according to [temp.arg.explicit]/8
  using std::static_pointer_cast;

  DerivedPtr dp = static_pointer_cast&lt;Derived&gt;(p);

  //...
}
</pre></blockquote>

<p>
A complete solution will need also the definition of
<tt>static_pointer_cast</tt> for raw pointers, and this definition has been
present in Boost (<a
href="http://www.boost.org/boost/pointer_cast.hpp">http://www.boost.org/boost/
pointer_cast.hpp</a>) for years.
</p>

<p><i>[
2010-03-26 Daniel made editorial adjustments to the proposed wording.
]</i></p>


<p><i>[
Moved to NAD Future at 2010-11 Batavia
]</i></p>

<blockquote><p>
This is a new feature rather than a defect. 
It can be added later: "this is such a hairy area that people will put up with changes"
</p></blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Add to section 20.2 [utility] Utility components, Header
<tt>&lt;utility&gt;</tt> synopsis:
</p>

<blockquote><pre>
// 20.3.X, generic pointer cast functions

template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;

//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));

template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre></blockquote>

<p>
Add to section 20.2 [utility] Utility components, a new subclause
20.3.X Pointer cast utilities [pointer.cast]:
</p>

<blockquote>
<p>
20.3.X Pointer cast utilities [pointer.cast]
</p>

<p>
1 The library defines generic pointer casting function templates so that template code
can explicitly make these names visible and activate argument-dependent lookup
for pointer cast calls.
</p>

<pre>
//Generic declarations
template&lt;typename U, typename T&gt;
<i>unspecified</i>
static_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
dynamic_pointer_cast(T&amp;&amp;) = delete;

template&lt;typename U, typename T&gt;
<i>unspecified</i>
const_pointer_cast(T&amp;&amp;) = delete;
</pre>

<p>
2 The library also defines overloads of these functions for raw pointers.
</p>

<pre>
//Overloads for raw pointers
template&lt;typename U, typename T&gt;
auto static_pointer_cast(T* t) -&gt; decltype(static_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>static_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto dynamic_pointer_cast(T* t) -&gt; decltype(dynamic_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>dynamic_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<pre>
template&lt;typename U, typename T&gt;
auto const_pointer_cast(T* t) -&gt; decltype(const_cast&lt;U*&gt;(t));
</pre>

<blockquote><p>
<i>Returns:</i> <tt>const_cast&lt;U*&gt;(t)</tt>
</p></blockquote>

<p>
[<i>Example:</i>
</p>

<blockquote><pre>
#include &lt;utility&gt; //static_pointer_cast
#include &lt;memory&gt;  //pointer_traits

class Base{};
class Derived : public Base{};

template&lt;class BasePtr&gt;
void generic_pointer_code(BasePtr b)
{
   typedef std::pointer_traits&lt;BasePtr&gt;::template
      rebind&lt;Derived&gt; DerivedPtr;

   using std::static_pointer_cast;
   //ADL applies now that static_pointer_cast is visible
   DerivedPtr d = static_pointer_cast&lt;Derived&gt;(b);
}
</pre></blockquote>

<p>
&mdash; <i>end example</i>]
</p>

</blockquote>

<p>
Replace in section 17.6.3.5 [allocator.requirements] Table 40 &mdash; Allocator
requirements, the following table entries for allocator pointers:
</p>

<blockquote>
<table border="1">
<caption>Table 40 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Default</th>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w)</tt></td>
<td><tt>X::pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::pointer</del><ins>T</ins>&gt;(w) == p</tt></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(w)</tt></td>
<td><tt>X::const_pointer</tt></td>
<td><tt>static<ins>_pointer</ins>_cast&lt;<del>X::const_pointer</del><ins>const T</ins>&gt;(z) == q</tt></td>
<td>&nbsp;</td>
</tr>

</table>
</blockquote>






<hr>
<h3><a name="1317" href="#1317">1317.</a> make_hash</h3>
<p><b>Section:</b> 20.14.14 [unord.hash] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Nicolai M. Josuttis <b>Opened:</b> 2010-02-10 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, the library lacks a convenient way to provide a hash function that
can be used with the provided unordered containers to allow the usage of non
trivial element types.
</p>

<p>
While we can easily declare an
</p>

<blockquote><pre>
std::unordered_set&lt;int&gt;
</pre></blockquote>

<p>
or
</p>

<blockquote><pre>
std::unordered_set&lt;std::string&gt;
</pre></blockquote>

<p>
we have no easy way to declare an <tt>unordered_set</tt> for a user defined
type. IMO, this is a big obstacle to use unordered containers in practice. Note
that in Java, the wide usage of <tt>HashMap</tt> is based on the fact that there
is always a default hash function provided.
</p>

<p>
Of course, a default hash function implies the risk to provide poor hash
functions. But often even poor hash functions are good enough.
</p>

<p>
While I really would like to see a default hash function, I don't propose it
here because this would probably introduce a discussion that's too big for this
state of C++0x.
</p>

<p>
However, I strongly suggest at least to provide a convenience variadic template
function <tt>make_hash&lt;&gt;()</tt> to allow an easy definition of a (possibly
poor) hash function.
</p>

<p>
As a consequence for a user-defined type such as
</p>

<blockquote><pre>
class Customer {
   friend class CustomerHash;
   private:
     string firstname;
     string lastname;
     long   no;
   ...
 };
</pre></blockquote>

<p>
would allow to specify:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return make_hash(c.firstname,c.lastname,c.no);
    }
};
</pre></blockquote>

<p>
instead of:
</p>

<blockquote><pre>
class CustomerHash : public std::unary_function&lt;Customer, std::size_t&gt;
{
  public:
    std::size_t operator() (const Customer&amp; c) const  {
       return std::hash&lt;std::string&gt;()(c.firstname) +
              std::hash&lt;std::string&gt;()(c.lastname) +
              std::hash&lt;long&gt;()(c.no);
    }
};
</pre></blockquote>

<p>
Note that, in principle, we can either specify that
</p>

<blockquote><p>
<tt>make_hash</tt> returns the sum of a call of
<tt>std::hash&lt;T&gt;()(x)</tt> for each argument <tt>x</tt> of type
<tt>T</tt>
</p></blockquote>

<p>
or we can specify that
</p>

<blockquote><p>
<tt>make_hash</tt> provides a hash value for each argument, for which a
<tt>std::hash()</tt> function is provided
</p></blockquote>

<p>
with the possible note that the hash value may be poor or only a good hash value
if the ranges of all passed arguments is equally distributed.
</p>

<p>
For my convenience, I propose wording that describes
the concrete implementation.
</p>

<p><i>[
2010 Pittsburgh:  Moved to NAD Editorial, rationale added below.
]</i></p>




<p><b>Rationale:</b></p>
<p>
There is no consensus to make this change at this time.
</p>


<p><b>Proposed resolution:</b></p>
<p>
In Function objects 20.14 [function.objects]
in paragraph 2 at the end of the Header <tt>&lt;functional&gt;</tt> synopsis
insert:
</p>

<blockquote><pre>
// convenience functions
template &lt;class T&gt;
  size_t make_hash (const T&amp;);
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp;, const Types&amp;...);
</pre></blockquote>

<p>
In Class template hash 20.14.14 [unord.hash]
add:
</p>

<blockquote>
<p>
<b>20.7.16.1 Hash creation functions [hash.creation]</b>
</p>

<pre>
template &lt;class T&gt;
  size_t make_hash (const T&amp; val);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val);</tt>
</p></blockquote>

<pre>
template &lt;class T, class... Types&gt;
  size_t make_hash (const T&amp; val, const Types&amp;... args);
</pre>

<blockquote><p>
<i>Returns:</i> <tt>hash&lt;T&gt;()(val) + std::make_hash(args...)</tt>
</p></blockquote>

</blockquote>






<hr>
<h3><a name="1320" href="#1320">1320.</a> Header for <tt>iter_swap</tt></h3>
<p><b>Section:</b> 24.3 [iterator.synopsis] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.synopsis">issues</a> in [iterator.synopsis].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>iter_swap</tt> function template appears in the
<tt>&lt;algorithm&gt;</tt> header, yet its main use is in building further
algorithms, not calling existing ones. The main clients are implementers of data
structures and their iterators, so it seems most appropriate to place the
template in the <tt>&lt;iterator&gt;</tt> header instead.
</p>

<p>
Note that this is not an issue for implementers of the standard library, as they
rarely use the standard headers directly, designing a more fine-grained set of
headers for their own internal use.  This option is not available to customers
of the standard library.
</p>

<p>
Note that we cannot remove <tt>iter_swap</tt> from <tt>&lt;algorithm&gt;</tt>
without breaking code, but there is no reason we cannot offer the same
declaration via two standard headers.  Alternatively, require
<tt>&lt;algorithm&gt;</tt> to <tt>#include &lt;iterator&gt;</tt>, but
introducing the dependency on the iterator adaptors seems un-necessary.
</p>

<p><i>[
]</i></p>


<p>
Discussed possibly moving to <tt>&lt;utility&gt;</tt> but don't like that. Some not seeing this 
as a defect, and want to keep it in <tt>&lt;algorithm&gt;</tt>. No one seems to feel strongly 
about moving to <tt>&lt;iterator&gt;</tt>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the declaration of <tt>iter_swap</tt> to the <tt>&lt;iterator&gt;</tt>
header synopsis (24.3 [iterator.synopsis]), with a note that it is
documented in clause 25 [algorithms].
</p>

<blockquote><pre>
...
template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);

<ins><i>// documented in 25 [algorithms]</i>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</ins>
</pre></blockquote>






<hr>
<h3><a name="1396" href="#1396">1396.</a> <tt>regex</tt> should support allocators</h3>
<p><b>Section:</b> 28.8 [re.regex] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1451">1451</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>
<p>
<tt>std::basic_regex</tt> should have an allocator for all the
reasons that a <tt>std::string</tt> does. For example, I can use
<tt>boost::interprocess</tt> to put a <tt>string</tt> or <tt>vector</tt>
in shared memory, but not a <tt>regex</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Add allocators to regexes
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote><p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">n3171</a> 
would solve this issue.
</p></blockquote>

<p><i>[2011-03-22 Madrid]</i></p>


<p>Close 1396 as NAD Future.</p>


<p><b>Rationale:</b></p><p>No consensus for a change at this time</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1406" href="#1406">1406.</a> Support hashing smart-pointers based on <i>owner</i></h3>
<p><b>Section:</b> 20.11.2.2 [util.smartptr.shared] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Japan <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses JP-5</b></p>
<p>
Hash support based on ownership sharing should be
supplied for <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
For two <tt>shared_ptr</tt> objects <tt>p</tt> and <tt>q</tt>, two distinct
equivalence relations can be defined. One is based on
equivalence of pointer values, which is derived from the
expression <tt>p.get() == q.get()</tt> (hereafter called <i>address based
equivalence relation</i>), the other is based on
equivalence of ownership sharing, which is derived from
the expression <tt>!p.owner_before(q) &amp;&amp; !q.owner_before(p)</tt>
(hereafter called <i>ownership-based equivalence relation</i>).
These two equivalence relations are independent in
general. For example, a <tt>shared_ptr</tt> object created by the
constructor of the signature <tt>shared_ptr(shared_ptr&lt;U>
const &amp;, T *)</tt> could reveal a difference between these two
relations. Therefore, hash support based on each
equivalence relation should be supplied for <tt>shared_ptr</tt>.
However, while the standard library provides the hash
support for address-based one (20.9.11.6 paragraph 2), it
lacks the hash support for ownership-based one. In
addition, associative containers work well in combination
with the <tt>shared_ptr</tt>'s ownership-based comparison but
unordered associative containers don't. This is
inconsistent.
</p>
<p>
For the case of <tt>weak_ptr</tt>, hash support for the ownership based
equivalence relation can be safely defined on
<tt>weak_ptr</tt>s, and even on expired ones. The absence of
hash support for the ownership-based equivalence
relation is fatal, especially for expired <tt>weak_ptr</tt>s. And the
absence of such hash support precludes some quite
effective use-cases, e.g. erasing the <tt>unordered_map</tt> entry
of an expired <tt>weak_ptr</tt> key from a customized deleter
supplied to <tt>shared_ptr</tt>s.
</p>
<p>
Hash support for the ownership-based equivalence
relation cannot be provided by any user-defined manner
because information about ownership sharing is not
available to users at all. Therefore, the only way to provide
ownership-based hash support is to offer it intrusively by
the standard library.
</p>
<p>
As far as we know, such hash support is implementable.
Typical implementation of such hash function could return
the hash value of the pointer of the counter object that is
internally managed by <tt>shared_ptr</tt> and <tt>weak_ptr</tt>.
</p>

<p><i>[2010 Rapperswil:]</i></p>

<blockquote>
<p>No consensus to make this change at this time.</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Add the following non-static member functions to
<tt>shared_ptr</tt> and <tt>weak_ptr</tt> class template;
</p>
<p>
Update [util.smartptr.shared], 20.9.11.2 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class shared_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
Update [util.smartptr.weak], 20.9.11.3 paragraph 1
</p>
<pre>
namespace std{
template&lt;class T&gt; class weak_ptr {
public:
...
  <ins>size_t owner_hash() const;</ins>
...
};
}
</pre>
<p>
These functions satisfy the following
requirements. Let <tt>p</tt> and <tt>q</tt> be objects of either
<tt>shared_ptr</tt> or <tt>weak_ptr</tt>, <tt>H</tt> be a hypothetical
function object type that satisfies the hash
requirements ([hash.requirements], 20.2.4) and <tt>h</tt> be an object of the
type <tt>H</tt>. The expression <tt>p.owner_hash()</tt> behaves
as if it were equivalent to the expression <tt>h(p)</tt>. In
addition, <tt>h(p) == h(q)</tt> must become <tt>true</tt> if <tt>p</tt> and
<tt>q</tt> share ownership.
</p>





<hr>
<h3><a name="1422" href="#1422">1422.</a> <tt>vector&lt;bool&gt;</tt> iterators are not random access</h3>
<p><b>Section:</b> 23.3.12 [vector.bool] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-118</b></p>
<p>
<tt>vector&lt;bool&gt;</tt> iterators are not random access iterators
because their reference type is a special class, and not
<tt>bool &amp;</tt>. All standard libary operations taking iterators
should treat this iterator as if it was a random access iterator, rather
than a simple input iterator.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Either revise the iterator requirements to support proxy iterators
(restoring functionality that was lost when the Concept facility was
removed) or add an extra paragraph to the <tt>vector&lt;bool&gt;</tt>
specification requiring the library to treat <tt>vector&lt;bool&gt;</tt>
iterators as-if they were random access iterators, despite having the wrong
reference type.
</p>

<p><i>[
Rapperswil Review
]</i></p>

<p>
The consensus at Rapperswil is that it is too late for full support for
proxy iterators, but requiring the library to respect <tt>vector&lt;bool&gt;</tt>
iterators as-if they were random access would be preferable to flagging
this container as deliberately incompatible with standard library algorithms.
</p>
<p>
Alisdair to write the note, which may become normative <i>Remark</i> depending
on the preferences of the project editor.
</p>

<p><i>[
Post-Rapperswil Alisdair provides wording
]</i></p>

<p>
Initial wording is supplied, deliberately using <i>Note</i> in preference to
<i>Remark</i> although the author notes his preference for <i>Remark</i>.  The
issue of whether <tt>iterator_traits&lt;vector&lt;bool&gt;&gt;::iterator_category</tt>
is permitted to report <tt>random_access_iterator_tag</tt> or must report 
<tt>input_iterator_tag</tt> is not addressed.
</p>

<p><i>[
Old Proposed Resolution:
]</i></p>

<blockquote>
<p>
Insert a new paragraph into 23.3.12 [vector.bool] between p4 and p5:
</p>
<blockquote><p>
[<i>Note</i> All functions in the library that take a pair of iterators to
denote a range shall treat <tt>vector&lt;bool&gt;</tt> iterators as-if they were
random access iterators, even though the <tt>reference</tt> type is not a
true reference.<i>-- end note</i>]
</p></blockquote>
</blockquote>

<p><i>[
2010-11 Batavia:
]</i></p>

<blockquote><p>
Closed as NAD Future, because the current iterator categories cannot correctly describe
<tt>vector&lt;bool&gt;::iterator</tt>. But saying that they are Random Access Iterators
is also incorrect, because it is not too hard to create a corresponding test that fails.
We should deal with the more general proxy iterator problem in the future, and see no
benefit to take a partial workaround specific to <tt>vector&lt;bool&gt;</tt> now.
</p></blockquote>



<p><b>Proposed resolution:</b></p>


<p><b>Rationale:</b></p>
<p>
No consensus to make this change at this time.
</p>





<hr>
<h3><a name="1459" href="#1459">1459.</a> Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1458">1458</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-21, GB-131</b></p>
<p>
29.4 [atomics.lockfree] p.8 states:
</p>
<blockquote><p>
An atomic store shall only store a value that has
been computed from constants and program input values
by a finite sequence of program evaluations, such
that each evaluation observes the values of variables
as computed by the last prior assignment in the
sequence.
</p></blockquote>
<p>
... but 1.9 [intro.execution] p.13 states:
</p>
<blockquote><p>
If A is not sequenced before B and B is not
sequenced before A, then A and B are unsequenced.
[ <em>Note</em>: The execution of unsequenced
evaluations can overlap. &mdash; <em>end note</em> ]
</p></blockquote>
<p>
Overlapping executions can make it impossible to
construct the sequence described in 29.4 [atomics.lockfree] p.8. We are not
sure of the intention here and do not offer a suggestion for
change, but note that 29.4 [atomics.lockfree] p.8 is the condition that prevents
out-of-thin-air reads.
</p>
<p>
For an example, suppose we have a function invocation
f(e1,e2). The evaluations of e1 and e2 can overlap.
Suppose that the evaluation of e1 writes y and reads x
whereas the evaluation of e2 reads y and writes x, with
reads-from edges as below (all this is within a single
thread).
</p>
<pre>
 e1           e2
Wrlx y--   --Wrlx x
      rf\ /rf
         X
        / \
Rrlx x&lt;-   -&gt;Rrlx y
</pre>
<p>
This seems like it should be allowed, but there seems to
be no way to produce a sequence of evaluations with the
property above.
</p>
<p>
In more detail, here the two evaluations, e1 and e2, are
being executed as the arguments of a function and are
consequently not sequenced-before each other. In
practice we'd expect that they could overlap (as allowed
by 1.9 [intro.execution] p.13), with the two writes taking effect before the two
reads. However, if we have to construct a linear order of
evaluations, as in 29.4 [atomics.lockfree] p.8, then the execution above is not
permited. Is that really intended?
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Please clarify.
</p>

<p><i>[2011-03-09 Hans comments:]</i></p>


<p>I'm not proud of 29.3 [atomics.order] p9 (formerly p8), and I agree with the comments that this
isn't entirely satisfactory. 29.3 [atomics.order] p9 was designed to preclude
out-of-thin-air results for races among <tt>memory_order_relaxed</tt> atomics, in spite of 
the fact that Java experience has shown we don't really know how to do that adequately. In 
the long run, we probably want to revisit this.
<p/>
However, in the short term, I'm still inclined to declare this NAD, for two separate reasons:
</p>

<ol>
<li><p>1.9 [intro.execution] p15 states: "If a side effect on a scalar
object is unsequenced relative to either another side
effect on the same scalar object or a value computation
using the value of the same scalar object, the behavior is undefined."
I think the examples presented here have undefined behavior as a result.
It's not completely clear to me whether examples can be constructed
that exhibit this problem, and don't have undefined behavior.</p></li>

<li><p>This comment seems to be using a different meaning of "evaluation"
from what is used elsewhere in the standard. The sequence of evaluations
here doesn't have to consist of full expression evaluations.  They
can be evaluations of operations like lvalue to rvalue conversion,
or individual assignments. In particular, the reads and writes
executed by <tt>e1</tt> and <tt>e2</tt> in the example could be treated as separate
evaluations for purposes of producing the sequence.
The definition of "sequenced before" in 1.9 [intro.execution] makes
little sense if the term "evaluation" is restricted to any notion
of complete expression. Perhaps we should add yet another note
to clarify this?  29.3 [atomics.order] p10 probably leads to 
the wrong impression here.
<p/>
An alternative resolution would be to simply delete our flakey
attempt at preventing out-of-thin-air reads, by removing 29.3 [atomics.order] p9-11,
possibly adding a note that explains that we technically allow,
but strongly discourage them. If we were starting this from scratch
now, that would probably be my preference.  But it seems like too drastic
a resolution at this stage.
</p></li>
</ol>

<p><i>[2011-03-24 Madrid]</i></p>

<p>
Moved to NAD Future
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1484" href="#1484">1484.</a> Need a way to join a thread with a timeout</h3>
<p><b>Section:</b> 30.3.1 [thread.thread.class] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-183</b></p>

<p>
There is no way to join a thread with a timeout.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Add <tt>join_for</tt> and <tt>join_until</tt>. Or decide one should
never join a thread with a timeout since <tt>pthread_join</tt> doesn't have a 
timeout version.
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The concurrency working group deemed this an extension beyond the scope of C++0x.
</p>
<p><b>Rationale:</b></p><p>The LWG does not wish to make a change at this time.</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1488" href="#1488">1488.</a> Improve interoperability between the C++0x and C1x threads APIs</h3>
<p><b>Section:</b> 30.4 [thread.mutex] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex">issues</a> in [thread.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-185</b></p>

<p>
Cooperate with WG14 to improve interoperability between
the <tt>C++0x</tt> and <tt>C1x</tt> threads APIs. In particular, <tt>C1x</tt>
mutexes should be conveniently usable with a <tt>C++0x</tt>
<tt>lock_guard</tt>. Performance overheads for this combination
should be considered.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Remove <tt>C++0x</tt> <tt>timed_mutex</tt> and
<tt>timed_recursive_mutex</tt> if that facilitates
development of more compatible APIs.
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The concurrency sub-group reviewed the options, and decided that closer harmony should wait until both standards are published.
</p>

<p><b>Rationale:</b></p>
<p>
The LWG does not wish to make any change at this time.
</p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1493" href="#1493">1493.</a> Add <tt>mutex</tt>, <tt>recursive_mutex</tt>, <tt>is_locked</tt> function</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.mutex.requirements">active issues</a> in [thread.mutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-189</b></p>

<p>
<tt>mutex</tt> and <tt>recursive_mutex</tt> should have an <tt>is_locked()</tt>
member function. <tt>is_locked</tt> allows a user to test a lock
without acquiring it and can be used to implement a lightweight
<tt>try_try_lock</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Add a member function:
</p>
<pre>
bool is_locked() const;
</pre>
<p>
to <tt>std::mutex</tt> and <tt>std::recursive_mutex</tt>. These
functions return true if the current thread would
not be able to obtain a mutex. These functions do
not synchronize with anything (and, thus, can
avoid a memory fence).
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed this issue and deemed it to be an extension to be handled after publishing C++0x.
</p>

<p><b>Rationale:</b></p><p>The LWG does not wish to make a change at this time.</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1499" href="#1499">1499.</a> Condition variables preclude wakeup optimization</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-193</b></p>

<p>
Condition variables preclude a wakeup optimization.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>


<blockquote><p>
Change condition_variable to allow such
optimization. See Appendix 1 - Additional Details
</p></blockquote>

<p><i>[
2010 Batavia
]</i></p>

<p>
The Concurrency subgroup reviewed the issue, and deemed it an extension to be handled after C++0x.
</p>

<p><b>Rationale:</b></p><p>The LWG does not wish to make the change at this time.</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1521" href="#1521">1521.</a> Requirements on internal pointer representations in containers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2010-10-16 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>

<p>
The standard doesn't say that containers should use abstract pointer 
types internally. Both Howard and Pablo agree that this is the intent. 
Further, it is necessary for containers to be stored, for example, in 
shared memory with an interprocess allocator (the type of scenario that 
allocators are intended to support).
</p>
<p>
In spite of the (possible) agreement on intent, it is necessary to make 
this explicit:
</p>
<p>
An implementations may like to store the result of dereferencing the 
pointer (which is a raw reference) as an optimization, but that prevents 
the data structure from being put in shared memory, etc. In fact, a 
container could store raw references to the allocator, which would be a 
little weird but conforming as long as it has one by-value copy. 
Furthermore, pointers to locales, ctypes, etc. may be there, which also 
prevents the data structure from being put in shared memory, so we 
should make explicit that a container does not store raw pointers or 
references at all.
</p>

<p><i>[
Pre-batavia
]</i></p>

<p>
This issue is being opened as part of the response to NB comments US-104/141. 
See paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing. 
</p>

<p><i>[2011-03-23 Madrid meeting]</i></p>


<p>Deferred</p>

<p><i>[
2011 Batavia
]</i></p>


<p>
This may be an issue, but it is not clear.  We want to gain a few years experience
with the C++11 allocator model to see if this is already implied by the existing
specification.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to the end of 23.2.1 [container.requirements.general] p. 8:
</p>
<blockquote><p>
[..] In all container types defined in this Clause, the member <tt>get_allocator()</tt> returns 
a copy of the allocator used to construct the container or, if that allocator has been replaced, 
a copy of the most recent replacement. <ins>The container may not store internal objects whose 
types are of the form  <tt>T *</tt> or <tt>T &amp;</tt> except insofar as they are part of the 
item type or members.</ins>
</p></blockquote>





<hr>
<h3><a name="2035" href="#2035">2035.</a> Output iterator requirements are broken</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>During the Pittsburgh meeting the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
became accepted because it fixed several severe issues related to the iterator specification. But the current working draft (N3225)
does not reflect all these changes. Since I'm unaware whether every correction can be done editorial, this issue is submitted to take
care of that. To give one example: All expressions of Table 108 &mdash; &quot;Output iterator requirements&quot; have a post-condition
that the iterator is incrementable. This is impossible, because it would exclude any finite sequence that is accessed by an output 
iterator, such as a pointer to a C array. The N3066 wording changes did not have these effects.
</p>

<p><i>[2011-03-01: Daniel comments:]</i></p>


<p>This issue has some overlap with the issue <a href="lwg-active.html#2038">2038</a> and I would prefer if we
could solve both at one location. I suggest the following approach:
</p>
<ol>
<li><p>The terms <tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> could be defined in a more
general way not restricted to iterators (similar to the concepts <tt>HasDereference</tt> and 
<tt>HasPreincrement</tt> from working draft N2914). But on the other hand, all current usages of 
<tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> are involved with types that satisfy 
iterator requirements. Thus, I believe that it is sufficient for C++0x to add corresponding definitions to 
24.2.1 [iterator.requirements.general] and to let all previous usages of these terms refer to this 
sub-clause. Since the same problem occurs with the past-the-end iterator, this proposal suggest providing 
similar references to usages that precede its definition as well.
</p></li>
<li><p>We also need to ensure that all iterator expressions get either an operational semantics in
terms of others or we need to add missing pre- and post-conditions. E.g. we have the following
ones without semantics:
</p><blockquote><pre>
*r++ = o // output iterator
*r--     // bidirectional iterator
</pre></blockquote><p>
According to the <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a>
these correspond to
</p><blockquote><pre>
{ *r = o; ++r; }                         // output iterator
{ reference tmp = *r; --r; return tmp; } // bidirectional iterator
</pre></blockquote><p>
respectively. Please note especially the latter expression for bidirectional iterator. It fixes a problem
that we have for forward iterator as well: Both these iterator categories provide stronger guarantees
than input iterator, because the result of the dereference operation is <tt>reference</tt>, and <strong>not</strong>
only convertible to the value type (The exact form from the SGI documentation does not correctly refer to
<tt>reference</tt>).
</p></li>
</ol>

<p><i>[2011-03-14: Daniel comments and updates the suggested wording]</i></p>


<p>In addition to the before mentioned necessary changes there is another one need, which
became obvious due to issue <a href="lwg-defects.html#2042">2042</a>: <tt>forward_list&lt;&gt;::before_begin()</tt> returns
an iterator value which is not dereferencable, but obviously the intention is that it should
be incrementable. This leads to the conclusion that imposing dereferencable as a requirement
for the expressions <tt>++r</tt> is wrong: We only need the iterator to be incrementable. A
similar conclusion applies to the expression <tt>--r</tt> of bidirectional iterators.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Consensus this is the correct direction, but there are (potentially) missing <i>incrementable</i>
preconditions on some table rows, and the Remarks on when an output iterator becomes dereferencable
are probably better handled outside the table, in a manner similar to the way we word for input
iterators.
</p>

<p>
There was some concern about redundant pre-conditions when the operational semantic is defined in
terms of operations that have preconditions, and a similar level of concern over dropping such
redundancies vs. applying a consistent level of redundant specification in all the iterator tables.
Wording clean-up in either direction would be welcome.
</p>

<p><i>[2011-08-18: Daniel adapts the proposed resolution to honor the Bloomington request]</i></p>


<p>
There is only a small number of further changes suggested to get rid of superfluous 
requirements and essentially non-normative assertions. Operations should not have extra 
pre-conditions, if defined by "in-terms-of" semantics, see e.g. <tt>a != b</tt> or <tt>a-&gt;m</tt> 
for Table 107. Further, some remarks, that do not impose anything or say nothing new have been removed, 
because I could not find anything helpful they provide.
E.g. consider the remarks for Table 108 for the operations dereference-assignment and
preincrement: They don't provide additional information say nothing surprising. With the
new pre-conditions <em>and</em> post-conditions it is implied what the remarks intend to say.
</p>

<p><i>[
2011-11-03: Some observations from Alexander Stepanov via c++std-lib-31405
]</i></p>


<p>
The following sentence is dropped from the standard section on OutputIterators:
<p/>
"In particular, the following two conditions should hold: first, any
iterator value should be assigned through before it is incremented
(this is, for an output iterator <tt>i, i++; i++;</tt> is not a valid code
sequence); second, any value of an output iterator may have at most
one active copy at any given time (for example, <tt>i = j; *++i = a; *j = b;</tt> 
is not a valid code sequence)."
</p>

<p><i>[
2011-11-04: Daniel comments and improves the wording
]</i></p>


<p>
In regard to the first part of the comment, the intention of the newly proposed wording 
was to make clear that for the expression
</p>
<blockquote><pre>
*r = o
</pre></blockquote>
<p>
we have the precondition dereferenceable and the post-condition
incrementable. And for the expression
</p>
<blockquote><pre>
++r
</pre></blockquote>
<p>
we have the precondition incrementable and the post-condition dereferenceable 
or past-the-end. This <em>should not</em>  allow for a sequence like <tt>i++; i++;</tt> 
but I agree that it doesn't exactly say that.
<p/>
In regard to the second point: To make this point clearer, I suggest to
add a similar additional wording as we already have for input iterator to the 
"Assertion&#47;note" column of the expression <tt>++r</tt>:
<p/>
"Post: any copies of the previous value of <tt>r</tt> are no longer 
required to be dereferenceable or incrementable."
<p/>
The proposed has been updated to honor the observations of Alexander Stepanov.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
The matter is complicated, Daniel volunteers to write a paper.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Add a reference to 24.2.1 [iterator.requirements.general] to the following parts of the
library preceding Clause 24 Iterators library: (I stopped from 23.2.5 [unord.req] on, because
the remaining references are the concrete containers)</p>
<ol>
<li><p>17.6.3.2 [swappable.requirements] p5:</p>

<blockquote><p>
-5- A type <tt>X</tt> satisfying any of the iterator requirements (24.2) is <tt><i>ValueSwappable</i></tt> if, 
for any dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> object <tt>x</tt> of type 
<tt>X</tt>, <tt>*x</tt> is swappable.
</p></blockquote>
</li>

<li><p>17.6.3.5 [allocator.requirements], Table 27 &mdash; &quot;Descriptive variable definitions&quot;, 
row with the expression <tt>c</tt>:</p>

<blockquote><p>
a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> pointer of type <tt>C*</tt>
</p></blockquote>

</li>

<li><p>20.10.3.2 [pointer.traits.functions]:</p>
<blockquote><p>
<i>Returns</i>: The first template function returns a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
pointer to <tt>r</tt> obtained by calling <tt>Ptr::pointer_to(r)</tt>;  [&hellip;]
</p></blockquote>
</li>

<li><p>21.3.1.3 [string.iterators] p. 2:</p>
<blockquote><p>
<i>Returns</i>: An iterator which is the past-the-end value <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote>
</li>

<li><p>22.4.5.1.2 [locale.time.get.virtuals] p. 11:</p>
<blockquote><pre>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
  ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
</pre><blockquote><p>
<i>Requires</i>: <tt>t</tt> shall be dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote></blockquote>
</li>

<li><p>23.2.1 [container.requirements.general] p. 6:</p>

<blockquote><p>
[&hellip;]  <tt>end()</tt> returns an iterator which is the past-the-end <ins>(24.2.1 [iterator.requirements.general])</ins> 
value for the container.  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.3 [sequence.reqmts] p. 3:</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.4 [associative.reqmts] p. 8 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.5 [unord.req] p. 10 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> and <tt>q1</tt> are valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterators to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>
</ol>

</li>
<li><p>Edit 24.2.1 [iterator.requirements.general] p. 5 as indicated (The intent is to properly define
<i>incrementable</i> and to ensure some further library guarantee related to past-the-end iterator values):</p>

<blockquote><p>
-5- Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence. These values are called <i>past-the-end values</i>. Values of an iterator <tt>i</tt> for which the
expression <tt>*i</tt> is defined are called <i>dereferenceable</i>. <ins>Values of an iterator <tt>i</tt> for which the
expression <tt>++i</tt> is defined are called <i>incrementable</i>. </ins> The library never assumes that 
past-the-end values are dereferenceable <ins>or incrementable</ins>. Iterators can also have singular values 
that are not associated with any sequence. [&hellip;]
</p></blockquote>
</li>

<li><p>Modify the column contents of Table 106 &mdash; &quot;Iterator requirements&quot;, 
24.2.2 [iterator.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 106 &mdash; Iterator requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r</tt></td>
<td><tt>reference</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is dereferenceable.</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins></td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 107 &mdash; &quot;Input iterator requirements&quot;, 
24.2.3 [input.iterators], as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <tt>*a</tt> and <tt>++r</tt>, and 
to specify the semantics of the remaining ones. This approach seems to be in agreement with the 
original <a href="http://www.sgi.com/tech/stl/InputIterator.html">SGI specification</a> 
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>a != b</tt></td>
<td>contextually<br/>
convertible to <tt>bool</tt></td>
<td><tt>!(a == b)</tt></td>
<td><del>pre: <tt>(a, b)</tt> is in the domain<br/>
of <tt>==</tt>.</del>
</td>
</tr>

<tr>
<td><tt>*a</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>a</tt> is dereferenceable.<br/>
The expression<br/>
<tt>(void)*a, *a</tt> is equivalent<br/>
to <tt>*a</tt>.<br/>
If <tt>a == b</tt> and <tt>(a,b)</tt> is in<br/>
the domain of <tt>==</tt> then <tt>*a</tt> is<br/>
equivalent to <tt>*b</tt>.
</td>
</tr>

<tr>
<td><tt>a-&gt;m</tt></td>
<td><tt>&nbsp;</tt></td>
<td><tt>(*a).m</tt></td>
<td><del>pre: <tt>a</tt> is dereferenceable.</del></td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
post: <tt>r</tt> is dereferenceable or<br/>
<tt>r</tt> is past-the-end.<br/>
post: any copies of the<br/>
previous value of <tt>r</tt> are no<br/>
longer required either to be<br/>
dereferenceable<ins>, incrementable,</ins><br/>
or to be in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td><tt>(void)r++</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins><tt>(void)++r</tt></ins></td>
<td><del>equivalent to <tt>(void)++r</tt></del></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</tt></td>
<td><tt>&nbsp;</tt></td>
</tr>

</table>
</blockquote>
</li>

<li>
<p>Modify the column contents of Table 108 &mdash; &quot;Output iterator requirements&quot;, 
24.2.4 [output.iterators], as indicated [<i>Rationale</i>: The wording changes attempt
to define a minimal "independent" set of operations, namely <tt>*r = o</tt> and <tt>++r</tt>,
and to specify the semantics of the remaining ones. This approach seems to be in agreement with
the original <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a> 
&mdash; <i>end rationale</i>]:</p>

<blockquote>
<table border="1">
<caption>Table 108 &mdash; Output iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>*r = o</tt></td>
<td>result is not used</td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is dereferenceable.</ins><br/>
<i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>and any copies of<br/>
the previous value of <tt>r</tt> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <tt>r</tt> is incrementable.
</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins><br/>
<tt>&amp;r == &amp;++r</tt>.<br/>
<del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/></del>
<ins><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
incrementable and any copies of<br/>
the previous value of <tt>r</tt> are no<br/>
longer required to be dereferenceable<br/>
or incrementable.</ins><br/>
post: <tt>r</tt> is <ins>dereferenceable<br/>
or <tt>r</tt> is past-the-end</ins><del>incrementable</del>.<br/>
</td>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.</del>
</td>
</tr>

<tr>
<td><tt>*r++ = o</tt></td>
<td>result is not used</td>
<td><ins><tt>{ *r = o; ++r; }</tt></ins></td>
<td><del><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.</del>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 109 &mdash; &quot;Forward iterator requirements&quot;, 
24.2.5 [forward.iterators], as indicated [<i>Rationale</i>: Since the return type of the
expression <tt>*r++</tt> is now guaranteed to be type <tt>reference</tt>, the implied operational
semantics from input iterator based on value copies is wrong &mdash; <i>end rationale</i>]</p>

<blockquote>
<table border="1">
<caption>Table 109 &mdash; Forward iterator requirements (in addition to input iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 ++r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify the column contents of Table 110 &mdash; &quot;Bidirectional iterator requirements&quot;, 
24.2.6 [bidirectional.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 110 &mdash; Bidirectional iterator requirements (in addition to forward iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td><tt>--r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: there exists <tt>s</tt> such that<br/>
<tt>r == ++s</tt>.<br/>
post: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
<tt>--(++r) == r</tt>.<br/>
<tt>--r == --s</tt> implies <tt>r == s</tt>.<br/>
<tt>&amp;r == &amp;--r</tt>.
</td>
</tr>

<tr>
<td><tt>r--</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  --r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r--</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 --r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2038" href="#2038">2038.</a> Missing definition for <tt>incrementable</tt> iterator</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>In comp.lang.c++, Vicente Botet raises the following questions:</p>

<blockquote><p>
&quot;In "24.2.4 Output iterators" there are 3 uses of incrementable. I've
not found the definition. Could some one point me where it is defined?
<p/>
Something similar occurs with dereferenceable. While the definition is
given in "24.2.1 In general" it is used several times before.
<p/>
Shouldn't these definitions be moved to some previous section?&quot;
</p></blockquote>

<p>He's right: both terms are used without being properly defined.
<p/>
There is no definition of "incrementable".
<p/>
While there is a definition of "dereferenceable", it is, in fact, a definition of 
"dereferenceable iterator". "dereferenceable" is used throughout Clause 23 (Containers) 
before its definition in Clause 24. In almost all cases it's referring to iterators, 
but in 17.6.3.2 [swappable.requirements] there is a mention of "dereferenceable object"; in 
17.6.3.5 [allocator.requirements] the table of Descriptive variable definitions refers to a 
"dereferenceable pointer"; 20.10.3.2 [pointer.traits.functions] refers to a 
"dereferenceable pointer"; in 22.4.5.1.2 [locale.time.get.virtuals]&#47;11 (<tt>do_get</tt>) 
there is a requirement that a pointer "shall be dereferenceable". In those specific cases 
it is not defined.
</p>

<p><i>[2011-03-02: Daniel comments:]</i></p>


<p>I believe that the currently proposed resolution of issue <a href="lwg-active.html#2035">2035</a> solves this
issue as well.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Agree with Daniel, this will be handled by the resolution of <a href="lwg-active.html#2035">2035</a>.
</p>



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2040" href="#2040">2040.</a> Missing type traits related to <tt>is_convertible</tt></h3>
<p><b>Section:</b> 20.15 [meta] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-03-03 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>
was suggested, it concentrated on constructions, assignments, and destructions, but overlooked 
to complement the single remaining compiler-support trait</p>

<blockquote><pre>
template &lt;class From, class To&gt; struct is_convertible;
</pre></blockquote>

<p>with the no-throw and triviality related aspects as it had been done with the other
expression-based traits. Specifically, the current specification misses to add the
following traits:
</p>

<blockquote><pre>
template &lt;class From, class To&gt; struct is_nothrow_convertible;
template &lt;class From, class To&gt; struct is_trivially_convertible;
</pre></blockquote>

<p>In particular the lack of <tt>is_nothrow_convertible</tt> is severly restricting. This
was recently recognized when the proposal for <tt>decay_copy</tt> was prepared by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3255.html">n3255</a>.
There does not exist a portable means to define the correct conditional <tt>noexcept</tt>
specification for the <tt>decay_copy</tt> function template, which is declared as:</p>

<blockquote><pre>
template &lt;class T&gt; 
typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v) noexcept(<i>???</i>);
</pre></blockquote>

<p>The semantics of <tt>decay_copy</tt> bases on an implicit conversion which again
influences the overload set of functions that are viable here. In most circumstances
this will have the same effect as comparing against the trait 
<tt>std::is_nothrow_move_constructible</tt>, but there is no guarantee for that being
the right answer. It is possible to construct examples, where this would lead
to the false result, e.g.</p>

<blockquote><pre>
struct S {
  S(const S&amp;) noexcept(false);
 
  template&lt;class T&gt;
  explicit S(T&amp;&amp;) noexcept(true);
};
</pre></blockquote>

<p><tt>std::is_nothrow_move_constructible</tt> will properly honor the explicit template
constructor because of the direct-initialization context which is part of the
<tt>std::is_constructible</tt> definition and will in this case select it, such that
<tt>std::is_nothrow_move_constructible&lt;S&gt;::value == true</tt>, but if we had
the traits <tt>is_nothrow_convertible</tt>, <tt>is_nothrow_convertible&lt;S, S&gt;::value</tt>
would evaluate to <tt>false</tt>, because it would use the copy-initialization context
that is part of the <tt>is_convertible</tt> definition, excluding any explicit
constructors and giving the opposite result.</p>

<p>The <tt>decay_copy</tt> example is surely not one of the most convincing examples, but
<tt>is_nothrow_convertible</tt> has several use-cases, and can e.g. be used to express
whether calling the following implicit conversion function could throw an exception or not:</p>

<blockquote><pre>
template&lt;class T, class U&gt;
T implicit_cast(U&amp;&amp; u) noexcept(is_nothrow_convertible&lt;U, T&gt;::value) 
{
  return std::forward&lt;U&gt;(u);
}
</pre></blockquote>

<p>Therefore I suggest to add the missing trait <tt>is_nothrow_convertible</tt> and for
completeness also the missing trait <tt>is_trivially_convertible</tt> to 20.15 [meta].</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Daniel K: This is a new feature so out of scope.
<p/>
Pablo: Any objections to moving 2040 to Open?
<p/>
No objections. 
</p>

<p><i>[Bloomington, 2011]</i></p>

<p>
Move to NAD Future, this would be an extension to existing functionality.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Ammend the following declarations to the header <tt>&lt;type_traits&gt;</tt> synopsis
in 20.15.2 [meta.type.synop]:</p>

<blockquote><pre>
namespace std {
  &hellip;
  // 20.9.6, type relations:
  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;
  <ins>template &lt;class From, class To&gt; struct is_trivially_convertible;</ins>
  <ins>template &lt;class From, class To&gt; struct is_nothrow_convertible;</ins>

  &hellip;
}
</pre></blockquote>
</li>

<li><p>Modify Table 51 &mdash; &quot;Type relationship predicates&quot; as indicated. The removal of the
remaining traces of the trait <tt>is_explicitly_convertible</tt> is an editorial
step, it was removed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3047.html">n3047</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 51 &mdash; Type relationship predicates</caption>

<tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>

<tr>
<td colspan="3" style="text-align:center;">&hellip;</td> 
</tr>

<tr>
<td><tt>template &lt;class From, class To&gt;<br/>
struct is_convertible;</tt></td>
<td><i>see below</i></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound, or<br/>
(possibly cv-qualified) <tt>void</tt><br/>
types.</td>
</tr>

<tr>
<td><del><tt>template &lt;class From, class To&gt;<br/>
struct is_explicitly_convertible;</tt></del></td>
<td><del><tt>is_constructible&lt;To, From&gt;::value</tt></del></td>
<td><del>a synonym for a two-argument<br/>
version of <tt>is_constructible</tt>.<br/>
An implementation may define it<br/>
as an alias template.</del></td>
</tr>

<tr>
<td><ins><tt>template &lt;class From, class To&gt;<br/>
struct is_trivially_convertible;</tt></ins></td>
<td><ins><tt>is_convertible&lt;From,<br/>
 To&gt;::value</tt> is <tt>true</tt> and the<br/>
conversion, as defined by<br/>
<tt>is_convertible</tt>, is known<br/>
to call no operation that is<br/>
not trivial ([basic.types], [special]).</ins></td>
<td><ins><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly cv-qualified) <tt>void</tt><br/>
types.</ins></td>
</tr>

<tr>
<td><ins><tt>template &lt;class From, class To&gt;<br/>
struct is_nothrow_convertible;</tt></ins></td>
<td><ins><tt>is_convertible&lt;From,<br/>
 To&gt;::value</tt> is <tt>true</tt> and the<br/>
conversion, as defined by<br/>
<tt>is_convertible</tt>, is known<br/>
not to throw any<br/>
exceptions ([expr.unary.noexcept]).</ins></td>
<td><ins><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly cv-qualified) <tt>void</tt><br/>
types.</ins></td>
</tr>

<tr>
<td colspan="3" style="text-align:center;">&hellip;</td> 
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2055" href="#2055">2055.</a> <tt>std::move</tt> in <tt>std::accumulate</tt> and other algorithms</h3>
<p><b>Section:</b> 26.8 [numeric.ops] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Chris Jefferson <b>Opened:</b> 2011-01-01 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#numeric.ops">issues</a> in [numeric.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++0x draft says <tt>std::accumulate</tt> uses: <tt>acc = binary_op(acc, *i)</tt>.
<p/>
Eelis van der Weegen has pointed out, on the libstdc++ mailing list, that using 
<tt>acc = binary_op(std::move(acc), *i)</tt> can lead to massive improvements (particularly, 
it means accumulating strings is linear rather than quadratic).
<p/>
Consider the simple case, accumulating a bunch of strings of length 1 (the same argument holds for other length buffers).
For strings <tt>s</tt> and <tt>t</tt>, <tt>s+t</tt> takes time <tt>length(s)+length(t)</tt>, as you have to copy 
both <tt>s</tt> and <tt>t</tt> into a new buffer.
<p/>
So in accumulating <tt>n</tt> strings, step <tt>i</tt> adds a string of length <tt>i-1</tt> to a string of length 
1, so takes time <tt>i</tt>.
<p/>
Therefore the total time taken is: <tt>1+2+3+...+n</tt> = O(<tt>n<sup>2</sup></tt>)
<p/>
<tt>std::move(s)+t</tt>, for a "good" implementation, is amortized time <tt>length(t)</tt>, like <tt>vector</tt>, 
just copy <tt>t</tt> onto the end of the buffer. So the total time taken is:
<p/>
<tt>1+1+1+...+1</tt> (<tt>n</tt> times) = O(<tt>n</tt>). This is the same as <tt>push_back</tt> on a <tt>vector</tt>.
<p/>
I'm trying to decide if this implementation might already be allowed. I suspect it might not 
be (although I can't imagine any sensible code it would break). There are other algorithms 
which could benefit similarly (<tt>inner_product</tt>, <tt>partial_sum</tt> and 
<tt>adjacent_difference</tt> are the most obvious).
<p/>
Is there any general wording for "you can use rvalues of temporaries"?
<p/>
The reflector discussion starting with message c++std-lib-29763 came to the conclusion
that above example is not covered by the "as-if" rules and that enabling this behaviour
would seem quite useful.
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Moved to NAD Future.  This would be a larger change than we would consider for a simple TC.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2062" href="#2062">2062.</a> Effect contradictions w&#47;o no-throw guarantee of <tt>std::function</tt> swaps</h3>
<p><b>Section:</b> 20.14.12.2 [func.wrap.func], 20.14.12.2.2 [func.wrap.func.mod] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-05-28 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Howard Hinnant observed in reflector message c++std-lib-30841 that 20.14.12.2 [func.wrap.func] 
makes the member swap <tt>noexcept</tt>, even though the non-member swap is not <tt>noexcept</tt>. 
<p/>
The latter was an outcome of the discussions during the Batavia meeting and the Madrid meeting 
involving LWG <a href="lwg-defects.html#1349">1349</a>, which seems to indicate that the remaining <tt>noexcept</tt> 
specifier at the member swap is incorrect and should be removed.
<p/>
But if we allow for a potentially throwing member swap of <tt>std::function</tt>, this causes 
another conflict with the exception specification for the following member function:
</p>
<blockquote><pre>
template&lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt; f) <span style="color:#C80000;font-weight:bolder">noexcept</span>;
</pre><blockquote><p>
<i>Effects</i>: <tt>function(f).<span style="color:#C80000;font-weight:bolder">swap</span>(*this);</tt>
</p>
</blockquote></blockquote>
<p>
Note that in this example the sub-expression <tt>function(f)</tt> does not cause any problems,
because of the nothrow-guarantee given in 20.14.12.2.1 [func.wrap.func.con] p. 10. The problem
is located in the usage of the swap which could potentially throw given the general latitude. 
<p/>
So, either the Madrid meeting decision need to be revised (and both member and free swap of 
<tt>std::function</tt> should be noexcept), or this function needs to be adapted as well,
e.g. by taking the exception-specification away or by changing the semantics.
<p/>
One argument for "swap-may-throw" would be to allow for small-object optimization techniques
where the copy of the target may throw. But given the fact that the swap function has been guaranteed 
to be "Throws: Nothing" from TR1 on, it seems to me that that there would still be opportunities to 
perform small-object optimizations just restricted to the set of target copies that cannot throw. 
<p/>
In my opinion member swap of <tt>std::function</tt> has always been intended to be no-throw, because
otherwise there would be no good technical reason to specify the effects of several member 
functions in terms of the "construct-swap" idiom (There are three functions that are defined
this way), which provides the strong exception safety in this case. I suggest to enforce that both 
member swap and non-member swap of <tt>std::function</tt> are nothrow functions as it had been guaranteed 
since TR1 on.
</p>

<p><i>[
2011 Bloomington
]</i></p>

<p>
Dietmar: May not be swappable in the first place.
</p>
<p>
Alisdair: This is wide contact. Then we should be taking noexcept off instead of putting it on. This is preferred resolution.
</p>
<p>
Pablo: This is bigger issue. Specification of assignment in terms of swap is suspect to begin with. It is over specification.
How this was applied to string is a better example to work from.
</p>
<p>
Pablo: Two problems: inconsistency that should be fixed (neither should have noexcept), the other issues is that assignment
should not be specified in terms of swap. There are cases where assignment should succeed where swap would fail. This is easier
with string as it should follow container rules.
</p>
<p>
<b>Action Item</b> (Alisdair): There are a few more issues found to file.
</p>
<p>
Dave: This is because of allocators? The allocator makes this not work.
</p>
<p>
Howard: There is a type erased allocator in shared_ptr. There is a noexcept allocator in shared_ptr.
</p>
<p>
Pablo: shared_ptr is a different case. There are shared semantics and the allocator does move around.
A function does not have shared semantics.
</p>
<p>
Alisdair: Function objects think they have unique ownership.
</p>
<p>
Howard: In function we specify semantics with copy construction and swap.
</p>
<p>
<b>Action Item</b> (Pablo): Write this up better (why assignment should not be defined in terms of swap)
</p>
<p>
Howard: Not having trouble making function constructor no throw.
</p>
<p>
Dietmar: Function must allocate memory.
</p>
<p>
Howard: Does not put stuff that will throw on copy or swap in small object optimization. Put those on heap.
Storing allocator, but has to be no throw copy constructable.
</p>
<p>
Pablo: Are you allowed to or required to swap or move allocators in case or swap or move.
</p>
<p>
Dave: An allocator that is type erased should be different...
</p>
<p>
Pablo: it is
</p>
<p>
Dave: Do you need to know something about allocator types? But only at construction time.
</p>
<p>
Pablo: You could have allocators that are different types.
</p>
<p>
Dave: Swap is two ended operation.
</p>
<p>
Pablo: Opinion is that both have to say propagate on swap for them to swap.
</p>
<p>
John: It is not arbitrary. If one person says no. No is no.
</p>
<p>
Howard: Find noexcept swap to be very useful. Would like to move in that direction and bring container design along.
</p>
<p>
Dave: If you have something were allocator must not propagate you can detect that at construction time.
</p>
<p>
...
</p>
<p>
Pablo: Need to leave this open and discuss in smaller group.
</p>
<p>
Alisdair: Tried to add boost::any as TR2 proposal and ran into this issue. Only the first place where we run into
issues with type erased allocators. Suggest we move it to open.
</p>
<p>
<b>Action Item</b>: Move to open.
</p>
<p>
<b>Action Item</b> (Pablo works with Howard and Daniel): Address the more fundamental issue
(which may be multiple issues) and write up findings.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>

<blockquote class="note">
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Modify the header <tt>&lt;functional&gt;</tt> synopsis in 20.14 [function.objects] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>function</tt> synopsis in 20.14.12.2 [func.wrap.func] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  <i>// [func.wrap.func.alg], specialized algorithms:</i>
  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 20.14.12.2.7 [func.wrap.func.alg] as indicated:</p>
<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2) <ins>noexcept</ins>;
</pre><blockquote><p>
-1- <i>Effects</i>: <tt>f1.swap(f2);</tt>
</p></blockquote></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2014-02-28 (Post Issaquah), Pablo provides more information]</i></p>


<p>
For cross-referencing purposes: The resolution of this issue should be
harmonized with any resolution to LWG <a href="lwg-active.html#2370">2370</a>, which addresses
inappropriate <tt>noexcept</tt>s in some function constructors.
</p>

<p>We have the following choices:</p>

<ol>
<li>
<p><tt>swap()</tt> does not throw</p>

<blockquote><p>
<i>Discussion</i>: This definition is desirable, and allows assignment
   to be implemented with the strong exception guarantee, but it does have
   consequences: The implementation cannot use the small-object optimization
   for a function-object <tt>F</tt> unless <tt>F</tt> is <tt>NothrowMovable</tt> 
   (nothrow-swappable is unimportant because <tt>F</tt> is not swapped with another <tt>F</tt>). 
   Note that many functors written before C++11 will not have move constructors decorated
   with <tt>noexcept</tt>, so this limitation could affect a lot of code.
</p>
<p>
It is not clear what other implementation restrictions might be
   needed. Allocators are required not to throw on move or copy. Is that
   sufficient?
</p>
</blockquote>
</li>

<li>
<p><tt>swap()</tt> can throw</p>

<blockquote>
<p>
<i>Discussion</i>: This definition gives maximum latitude to implementation to
   use small-object optimization. However, the strong guarantee on assignment
   is difficult to achieve.  Should we consider giving up on the strong
   guarantee? How much are we willing to pessimize code for exceptions?
</p>
</blockquote>
</li>
<li>
<p><tt>swap()</tt> will not throw if both functions have <tt>NoThrowMoveable</tt> functors</p>

<blockquote>
<p>
<i>Discussion</i>: This definition is similar to option 2, but gives slightly
  stronger guarantees.  Here, <tt>swap()</tt> can throw, but the programmer can
  theoretically prevent that from happening. This should be straight-forward
  to implement and gives the implementation a lot of latitude for
  optimization. However, because this is a dynamic decision, the program is
  not as easy to reason about. Also, the strong guarantee for assignment is
  compromized as in option 2.
</p>
</blockquote>
</li>
</ol>

<p><i>[2016-08-02, Ville, Billy, and Billy comment and reinstantiate the original P/R]</i></p>

<p>
We (Ville, Billy, and Billy) propose to require that <tt>function</tt>'s <tt>swap</tt> is <tt>noexcept</tt> 
in all cases.
</p>
<ul>
<li><p>libstdc++ does not throw in their <tt>swap</tt>. It is not <tt>noexcept</tt> today, but the small functor 
optimization only engages for trivially copyable types.</p></li>
<li><p>msvc++ checks <tt>is_nothrow_move_constructible</tt> before engaging the small functor optimization and marks 
its <tt>swap</tt> <tt>noexcept</tt></p></li>
<li><p>libc++ marks <tt>swap</tt> <tt>noexcept</tt> (though I have not looked at its implementation)</p></li>
</ul>
<p>
Moreover, many of the concerns that were raised by providing this guarantee are no longer applicable now that 
<a href="http://wg21.link/p0302r1">P0302</a> has been accepted, which removes allocator support from <tt>std::function</tt>.
<p/>
Therefore we are re-proposing the original resolution above.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: Move to Tentatively Ready</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Modify the header <tt>&lt;functional&gt;</tt> synopsis in 20.14 [function.objects] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify the class template <tt>function</tt> synopsis in 20.14.12.2 [func.wrap.func] as indicated:</p>
<blockquote><pre>
namespace std {
  [&hellip;]

  <i>// [func.wrap.func.alg], specialized algorithms:</i>
  template&lt;class R, class... ArgTypes&gt;
  void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) <ins>noexcept</ins>;

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 20.14.12.2.7 [func.wrap.func.alg] as indicated:</p>
<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
void swap(function&lt;R(ArgTypes...)&gt;&amp; f1, function&lt;R(ArgTypes...)&gt;&amp; f2) <ins>noexcept</ins>;
</pre><blockquote><p>
-1- <i>Effects</i>: As if by: <tt>f1.swap(f2);</tt>
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2070" href="#2070">2070.</a> <tt>allocate_shared</tt> should use <tt>allocator_traits&lt;A&gt;::construct</tt></h3>
<p><b>Section:</b> 20.11.2.2.6 [util.smartptr.shared.create] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-07-11 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.create">active issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.2.2.6 [util.smartptr.shared.create] says:
</p>
<blockquote><p>
-2- <i>Effects</i>: Allocates memory suitable for an object of type <tt>T</tt> and constructs an object in that memory
via the placement new expression <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template
<tt>allocate_shared</tt> uses a copy of a to allocate memory. If an exception is thrown, the functions have
no effect.
</p></blockquote>
<p>
This explicitly requires placement new rather than using
<tt>allocator_traits&lt;A&gt;::construct(a, (T*)pv, std::forward&lt;Args&gt;(args)...)</tt>
In most cases that would result in the same placement new expression,
but would allow more control over how the object is constructed e.g.
using <tt>scoped_allocator_adaptor</tt> to do uses-allocator construction, or
using an allocator declared as a friend to construct objects with no
public constructors.
</p>

<p><i>[2011-08-16 Bloomington:]</i></p>

<p>
Agreed to fix in principle, but believe that <tt>make_shared</tt> and
<tt>allocate_shared</tt> have now diverged enough that their descriptions
should be separated.  Pablo and Stefanus to provide revised wording.
</p>

<p><strong>Daniel's (old) proposed resolution:</strong></p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the following paragraphs of 20.11.2.2.6 [util.smartptr.shared.create] as indicated (The suggested
removal of the last sentence of p1 is not strictly required to resolve this issue, but is still recommended,
because it does not say anything new but may give the impression that it says something new):
</p><blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre><blockquote>
<p>
-1- <i>Requires</i>: <ins>For the template <tt>make_shared</tt>, t</ins><del>T</del>he expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>T</tt>, shall be well 
formed. <ins>For the template <tt>allocate_shared</tt>, the expression 
<tt>allocator_traits&lt;A&gt;::construct(a, pt, std::forward&lt;Args&gt;(args)...)</tt>,
where <tt>pt</tt> has type <tt>T*</tt> and points to storage suitable to hold an object
of type <tt>T</tt>, shall be well formed.</ins> <tt>A</tt> shall be an allocator ([allocator.requirements]). 
<del>The copy constructor and destructor of  <tt>A</tt> shall not throw exceptions.</del>
<p/>
-2- <i>Effects</i>: Allocates memory suitable for an object of type <tt>T</tt> and constructs an object in 
that memory<ins>. The template <tt>make_shared</tt> constructs the object</ins> via the placement new expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template <tt>allocate_shared</tt> uses a copy 
of <tt>a</tt> to allocate memory<ins> and constructs the object by calling <tt>allocator_traits&lt;A&gt;::construct(a, pt,
std::forward&lt;Args&gt;(args)...)</tt></ins>. If an exception is thrown, the functions have no effect.
<p/>
-3- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>.
<p/>
-4- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt>
<p/>
-5- <i>Throws</i>: <tt>bad_alloc</tt>, or<ins>, for the template <tt>make_shared</tt>, an exception thrown from
the constructor of <tt>T</tt>, or, for the template <tt>allocate_shared</tt>,</ins> an exception thrown from 
<tt>A::allocate</tt> or <ins>from <tt>allocator_traits&lt;A&gt;::construct</tt></ins><del>from the constructor of 
<tt>T</tt></del>.
<p/>
-6- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [ <i>Note</i>: This provides efficiency equivalent to an intrusive smart pointer. &mdash; <i>end note</i> ]
<p/>
-7- [ <i>Note</i>: These functions will typically allocate more memory than <tt>sizeof(T)</tt> to allow for internal
bookkeeping structures such as the reference counts. &mdash; <i>end note</i> ]
</p>
</blockquote></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2011-12-04: Jonathan and Daniel improve wording]</i></p>


<p>See also c++std-lib-31796</p>




<p><i>[2013-10-13, Ville]</i></p>

<p>
This issue is related to <a href="lwg-active.html#2089">2089</a>.
</p>


<p><i>[2014-02-15 post-Issaquah session : move to Tentatively NAD]</i></p>

<p>STL: This takes an allocator, but then ignores its construct. That's squirrely.</p>
<p>Alisdair: The convention is when you take an allocator, you use its construct.</p>
<p>STL: 23.2.1 [container.requirements.general]/3, argh! This fills me with despair, but I understand it now.</p>
<p>STL: Ok, this is some cleanup.</p>
<p>STL: You're requiring <tt>b</tt> to be of type <tt>A</tt> and not being rebound, is that an overspecification?</p>
<p>Pablo: Good point. Hmm, that's only a requirement on what must be well-formed.</p>
<p>STL: If it's just a well-formed requirement, then why not just use a directly?</p>
<p>Pablo: Yeah, the well-formed requirement is overly complex. It's not a real call, we could just use a directly. It makes it harder to read.</p>
<p>Alisdair: <tt>b</tt> should be an allocator in the same family as <tt>a</tt>.</p>
<p>Pablo: This is a well-formed requirement, I wonder if it's the capital A that's the problem here. It doesn't matter here, this is way too much wording.</p>
<p>Alisdair: It's trying to tie the constructor arguments into the allocator requirements.</p>
<p>Pablo: <tt>b</tt> could be struck, that's a runtime quality. The construct will work with anything that's in the family of <tt>A</tt>.</p>
<p>Alisdair: The important part is the <tt>forward</tt> of <tt>Args</tt>.</p>
<p>Pablo: <tt>A</tt> must be an allocator, and <tt>forward</tt> <tt>Args</tt> must work with that.</p>
<p>Alisdair: First let's nail down <tt>A</tt>.</p>
<p>Pablo: Then replace <tt>b</tt> with <tt>a</tt>, and strike the rest.</p>
<p>STL: You need <tt>pt</tt>'s type, at least.</p>
<p>Pablo: There's nothing to be said about runtime constraints here, this function doesn't even take a <tt>pt</tt>.</p>
<p>STL: Looking at the Effects, I believe <tt>b</tt> is similarly messed up, we can use <tt>a2</tt> to construct an object.</p>
<p>Alisdair: Or any allocator in the family of <tt>a</tt>.</p>
<p>STL: We say this stuff for the deallocate too, it should be lifted up.</p>
<p>STL: "owns the address" is weird.</p>
<p>Alisdair: shared_ptr owns pointers, although it does sound funky.</p>
<p>Walter: "to destruct" is ungrammatical.</p>
<p>STL: "When ownership is given up" is not what we usually say.</p>
<p>Alisdair: I think the Returns clause is the right place to say this.</p>
<p>STL: The right place to say this is <tt>shared_ptr</tt>'s dtor, we don't want to use Core's "come from" convention.</p>
<p>Alisdair: I'm on the hook to draft cleaner wording.</p>


<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>
AM: I was going to clean up the wording, but haven't done it yet.<br/>
Defer until we have new wording.<br/>
</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>
Alisdair: we need to figure out whether we should call construct or not; major implementation divergence<br/>
STL: this does not grant friendship, does it?<br/>
Jonathan: some people want it.<br/>
Thomas: scoped allocator adapter should be supported, so placement new doesn't work<br/>
Alisdair: this makes the make_ functions impossible<br/>
Thomas: you don't want to use those though.<br/>
Alisdair: but people use that today, at Bloomberg<br/>
Alisdair: and what do we do about fancy pointers?<br/>
Jonathan: we constrain it to only non-fancy pointers.<br/>
STL: shared_ptr has never attempted to support fancy pointers; seems like a paper is needed.<br/>
Poll: call construct:6 operator new: 0 don't care: 4<br/>
Poll: should we support fancy pointers? Yes: 1 No: 4 don't care: 4<br/>
STL: 20.8.2.2.6p2: 'and pv->~T()' is bogus for void<br/>
STL: 20.8.2.2.6p4: is this true even if we're going to allocate a bit more?<br/>
Alisdair: yes<br/>
Alisdair: coming up with new wording<br/>
</p>

<p><i>[2016-08, Chicago Monday PM]</i></p>

<p>Alisdair to provide new wording this week</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the following paragraphs of 20.11.2.2.6 [util.smartptr.shared.create] as indicated:
</p>
<blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
<del>template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);</del>
</pre></blockquote>
<p>
<del>-1- <i>Requires</i>: The expression <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>, where <tt>pv</tt> 
has type <tt>void*</tt> and points to storage suitable to hold an object of type <tt>T</tt>, shall be well 
formed. <tt>A</tt> shall be an allocator (17.6.3.5 [allocator.requirements]). The copy constructor 
and destructor of <tt>A</tt> shall not throw exceptions.</del>
<p/>
-2- <i>Effects</i>: <ins>Equivalent to</ins>
</p>
<blockquote><pre> 
<ins>return allocate_shared&lt;T&gt;(allocator&lt;T&gt;(), std::forward&lt;Args&gt;(args)...);</ins>
</pre></blockquote>
<p>
<del>Allocates memory suitable for an object of type <tt>T</tt> 
and constructs an object in that memory via the placement new expression 
<tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt>. The template <tt>allocate_shared</tt> uses a copy 
of <tt>a</tt> to allocate memory. If an exception is thrown, the functions have no effect.</del>
<p/>
<ins>-?- <i>Remarks</i>: An implementation may meet the effects (and the implied guarantees) without 
creating the allocator object [<i>Note</i>: That is, user-provided specializations of <tt>std::allocator</tt>
may not be instantiated, the expressions <tt>::new (pv) T(std::forward&lt;Args&gt;(args)...)</tt> and 
<tt>pv-&gt;~T()</tt> may be evaluated directly &mdash; <i>end note</i>].</ins>
<p/>
<del>-3- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>.</del>
<p/>
<del>-4- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt></del>
<p/>
<del>-5- <i>Throws</i>: <tt>bad_alloc</tt>, or an exception thrown from <tt>A::allocate</tt> or from the 
constructor of <tt>T</tt>.</del>
<p/>
<del>-6- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [<i>Note</i>: This provides efficiency equivalent to an intrusive smart pointer. &mdash; <i>end note</i>]</del>
<p/>
<del>-7- [<i>Note</i>: These functions will typically allocate more memory than <tt>sizeof(T)</tt> to allow 
for internal bookkeeping structures such as the reference counts. &mdash; <i>end note</i>]</del>
</p>
</li>
<li><p>
Add the following set of <ins>new paragraphs</ins> immediately following the previous paragraph 7 of
20.11.2.2.6 [util.smartptr.shared.create]:
</p>
<blockquote><pre>
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre></blockquote>
<p>
-?- <i>Requires</i>: The expressions 
<tt>allocator_traits&lt;A&gt;::construct(b, pt, std::forward&lt;Args&gt;(args)...)</tt> and
<tt>allocator_traits&lt;A&gt;::destroy(b, pt)</tt> shall be well-formed and well-defined, 
where <tt>b</tt> has type <tt>A</tt> and is a copy of <tt>a</tt> and where <tt>pt</tt> 
has type <tt>T*</tt> and points to storage suitable to hold an object of type <tt>T</tt>. 
<tt>A</tt> shall meet the allocator requirements (17.6.3.5 [allocator.requirements]). 
<p/>
-?- <i>Effects</i>: Uses an object <tt>a2</tt> 
of type <tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;<i>unspecified</i>&gt;</tt> that compares equal to 
<tt>a</tt> to allocate memory suitable for an object of type <tt>T</tt>. 
Uses a copy <tt>b</tt> of type <tt>A</tt> from <tt>a</tt> to construct an object of type <tt>T</tt> in 
that memory by calling <tt>allocator_traits&lt;A&gt;::construct(b, pt, std::forward&lt;Args&gt;(args)...)</tt>. 
If an exception is thrown, the function has no effect.
<p/>
-?- <i>Returns</i>: A <tt>shared_ptr</tt> instance that stores and owns the address of the newly constructed 
object of type <tt>T</tt>. When ownership is given up, the effects are as follows: Uses a copy <tt>b2</tt> 
of type <tt>A</tt> from <tt>a</tt> to destruct an object of type <tt>T</tt> by calling 
<tt>allocator_traits&lt;A&gt;::destroy(b2, pt2)</tt> where <tt>pt2</tt> has type <tt>T*</tt> 
and refers to the newly constructed object. Then uses an object of type
<tt>allocator_traits&lt;A&gt;::rebind_alloc&lt;<i>unspecified</i>&gt;</tt> that compares equal to 
<tt>a</tt> to deallocate the allocated memory.
<p/>
-?- <i>Postconditions</i>: <tt>get() != 0 &amp;&amp; use_count() == 1</tt>
<p/>
-?- <i>Throws</i>: Nothing unless memory allocation or <tt>allocator_traits&lt;A&gt;::construct</tt> 
throws an exception.
<p/>
-?- <i>Remarks</i>: Implementations are encouraged, but not required, to perform no more than one memory 
allocation. [<i>Note</i>: Such an implementation provides efficiency equivalent to an intrusive smart 
pointer. &mdash; <i>end note</i>]
<p/>
-?- [<i>Note</i>: This function will typically allocate more memory than <tt>sizeof(T)</tt> to allow for internal
bookkeeping structures such as the reference counts. &mdash; <i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3><a name="2077" href="#2077">2077.</a> Further incomplete constraints for type traits</h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-08-20 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The currently agreed on proposed wording for <a href="lwg-defects.html#2015">2015</a> using 
<tt>remove_all_extents&lt;T&gt;::type</tt> instead of the "an array of 
unknown bound" terminology in the precondition should be extended to 
some further entries especially in Table 49, notably the 
<tt>is_*constructible</tt>, <tt>is_*assignable</tt>, and 
<tt>is_*destructible</tt> entries. To prevent ODR violations, incomplete
element types of arrays must be excluded for value-initialization and
destruction for example. Construction and assignment has to be honored, 
when we have array-to-pointer conversions or pointer conversions of
incomplete pointees in effect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
The issue is that in three type traits, we are accidentally saying that in certain
circumstances the type must give a specified answer when given an incomplete type.
(Specifically: an array of unknown bound of incomplete type.)  The issue asserts
that there's an ODR violation, since the trait returns false in that case but might
return a different version when the trait is completed.
</p>
<p>
Howard argues: no, there is no risk of an ODR violation.
<tt>is_constructible&lt;A[]></tt> must return <tt>false</tt> regardless of whether
<tt>A</tt> is complete, so there's no reason to forbid an array of unknown bound of
incomplete types. Same argument applies to <tt>is_assignable</tt>. General agreement
with Howard's reasoning.
</p>
<p>
There may be a real issue for <tt>is_destructible</tt>. None of us are sure what
<tt>is_destructible</tt> is supposed to mean for an array of unknown bound
(regardless of whether its type is complete), and the standard doesn't make it clear.
The middle column doesn't say what it's supposed to do for incomplete types.
</p>
<p>
In at least one implementation, <tt>is_destructible&lt;A[]></tt> does return <tt>true</tt>
if <tt>A</tt> is complete, which would result in ODR violation unless we forbid it for
incomplete types.
</p>
<p>
Move to open. We believe there is no issue for <tt>is_constructible</tt> or
<tt>is_assignable</tt>, but that there is a real issue for <tt>is_destructible</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2088" href="#2088">2088.</a> <tt>std::terminate</tt> problem</h3>
<p><b>Section:</b> 18.8.4 [exception.terminate] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-09-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Andrzej Krzemienski reported the following on comp.std.c++:
</p>
<blockquote>
<p>
In N3290, which is to become the official standard, in 18.8.4.4 [terminate],
paragraph 1 reads
</p>
<blockquote><p>
<i>Remarks</i>: Called by the implementation when exception handling must
be abandoned for any of several reasons (15.5.1), in effect immediately after 
evaluating the <em>throw-expression</em> (18.8.3.1). May also be called directly by the 
program.
</p></blockquote>
<p>It is not clear what is "in effect". It was clear in previous drafts where paragraphs 
1 and 2 read:
</p>
<blockquote><p>
Called by the implementation when exception handling must be
abandoned for any of several reasons (15.5.1). May also be called directly
by the program.
<p/>
<i>Effects</i>: Calls the <tt>terminate_handler</tt> function in effect
immediately after evaluating the <em>throw-expression</em> (18.8.3.1), if called by the
implementation, or calls the current <tt>terminate_handler</tt> function,
if called by the program.
</p>
</blockquote>
<p>
It was changed by N3189. The same applies to function unexpected (D. 11.4, paragraph 1).
<p/>
Assuming the previous wording is still intended, the wording can be read
"unless <tt>std::terminate</tt> is called by the program, we will use the handler
that was in effect immediately after evaluating the throw-expression".
<p/>
  This assumes that there is some throw-expression connected to every
  situation that triggers the call to <tt>std::terminate</tt>. But this is not
  the case:
</p>
<ul>
<li>
  In case <tt>std::thread</tt> is assigned to or destroyed while being joinable
  there is no throw-expression involved.
</li>
<li>
  In case <tt>std::unexpected</tt> is called by the program, <tt>std::terminate</tt> is
  triggered by the implementation - no throw-expression involved.
</li>
<li>
  In case a destructor throws during stack unwinding we have two throw-expressions 
  involved.
 </li>
 </ul>
<p>
Which one is referred to?
<p/>
In case <tt>std::nested_exception::rethrow_nested</tt> is called for an object that has 
captured no exception, there is no throw-expression involved directly (and may no throw 
be involved even indirectly).
<p/>
Next, 18.8.4.1 [terminate.handler], paragraph 2 says 
</p>
<blockquote><p>
<i>Required behavior</i>: A <tt>terminate_handler</tt> shall terminate execution
of the program without returning to the caller.
</p></blockquote>
<p>
This seems to allow that the function may exit by throwing an
exception (because word "return" implies a normal return).
<p/>
One could argue that words "terminate execution of the program" are sufficient,
but then why "without returning to the caller" would be mentioned. In
case such handler throws, noexcept specification in function <tt>std::terminate</tt> 
is violated, and <tt>std::terminate</tt> would be called recursively - should 
<tt>std::abort</tt> not be called in case of recursive <tt>std::terminate</tt> 
call? On the other hand some controlled recursion could be useful, like in the 
<a href="http://cplusplus.co.il/2010/03/21/catching-uncaught-exceptions-within-terminate/">following technique</a>.
</p>
</blockquote>

<p>
The here mentioned wording changes by N3189 in regard to 18.8.4.4 [terminate] p1 
were done for a better separation of effects (Effects element) and additional normative 
wording explanations (Remarks element), there was no meaning change intended. Further,
there was already a defect existing in the previous wording, which was not updated when 
further situations where defined, when <tt>std::terminate</tt> where supposed to be 
called by the implementation. 
<p/>
The part
<p/>
"in effect immediately after evaluating the throw-expression"
<p/>
should be removed and the quoted reference to 18.8.4.1 [terminate.handler] 
need to be part of the effects element where it refers to the current <tt>terminate_handler</tt> 
function, so should be moved just after
<p/>
"Effects: Calls the current <tt>terminate_handler</tt> function."
<p/>
It seems ok to allow a termination handler to exit via an exception, but the 
suggested idiom should better be replaced by a more simpler one based on
evaluating the current exception pointer in the terminate handler, e.g.
</p>
<blockquote><pre>
void our_terminate (void) {
  std::exception_ptr p = std::current_exception();
  if (p) {
    ... // OK to rethrow and to determine it's nature
  } else {
    ... // Do something else
  }
}
</pre></blockquote>

<p><i>[2011-12-09: Daniel comments]</i></p>


<p>
A related issue is <a href="lwg-defects.html#2111">2111</a>.
</p>


<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
There is an interaction with Core issues in this area that Jens is already supplying wording
for.  Review this issue again once Jens wording is available.
</p>
<p>
Alisdair to review clause 15.5 (per Jens suggestion) and recommend any changes, then integrate
Jens wording into this issue.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2089" href="#2089">2089.</a> <tt>std::allocator::construct</tt> should use uniform initialization</h3>
<p><b>Section:</b> 20.10.9.1 [allocator.members] <b>Status:</b> <a href="lwg-active.html#EWG">EWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2011-10-07 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.members">issues</a> in [allocator.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
When the <tt>EmplaceConstructible</tt> (23.2.1 [container.requirements.general]&#47;13) requirement is used 
to initialize an object, direct-initialization occurs. Initializing an aggregate or using a <tt>std::initializer_list</tt> 
constructor with emplace requires naming the initialized type and moving a temporary. This is a result of 
<tt>std::allocator::construct</tt> using direct-initialization, not list-initialization (sometimes called "uniform 
initialization") syntax.
<p/>
Altering <tt>std::allocator&lt;T&gt;::construct</tt> to use list-initialization would, among other things, give 
preference to <tt>std::initializer_list</tt> constructor overloads, breaking valid code in an unintuitive and 
unfixable way &mdash; there would be no way for <tt>emplace_back</tt> to access a constructor preempted by 
<tt>std::initializer_list</tt> without essentially reimplementing <tt>push_back</tt>.
</p>
<blockquote><pre>
std::vector&lt;std::vector&lt;int&gt;&gt; v;
v.emplace_back(3, 4); // v[0] == {4, 4, 4}, not {3, 4} as in list-initialization
</pre></blockquote>
<p>
The proposed compromise is to use SFINAE with <tt>std::is_constructible</tt>, which tests whether direct-initialization 
is well formed. If <tt>is_constructible</tt> is false, then an alternative <tt>std::allocator::construct</tt> overload 
is chosen which uses list-initialization. Since list-initialization always falls back on direct-initialization, the 
user will see diagnostic messages as if list-initialization (uniform-initialization) were always being used, because 
the direct-initialization overload cannot fail.
<p/>
I can see two corner cases that expose gaps in this scheme. One occurs when arguments intended for 
<tt>std::initializer_list</tt> satisfy a constructor, such as trying to emplace-insert a value of <tt>{3, 4}</tt> in 
the above example. The workaround is to explicitly specify the <tt>std::initializer_list</tt> type, as in 
<tt>v.emplace_back(std::initializer_list&lt;int&gt;(3, 4))</tt>. Since this matches the semantics as if 
<tt>std::initializer_list</tt> were deduced, there seems to be no real problem here.
<p/>
The other case is when arguments intended for aggregate initialization satisfy a constructor. Since aggregates cannot 
have user-defined constructors, this requires that the first nonstatic data member of the aggregate be implicitly 
convertible from the aggregate type, and that the initializer list have one element. The workaround is to supply an 
initializer for the second member. It remains impossible to in-place construct an aggregate with only one nonstatic 
data member by conversion from a type convertible to the aggregate's own type. This seems like an acceptably small 
hole.
<p/>
The change is quite small because <tt>EmplaceConstructible</tt> is defined in terms of whatever allocator is specified, 
and there is no need to explicitly mention SFINAE in the normative text.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
There appears to be a real concern with initializing aggregates, that can be performed only
using brace-initialization.  There is little interest in the rest of the issue, given the existence
of 'emplace' methods in C++11.
</p>
<p>
Move to Open, to find an acceptable solution for intializing aggregates.  There is the potential
that EWG may have an interest in this area of language consistency as well.
</p>

<p><i>[2013-10-13, Ville]</i></p>

<p>
This issue is related to <a href="lwg-active.html#2070">2070</a>.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Move to EWG, Ville to write a paper. 
</p>

<p><i>[2015-09, Telecom]</i></p>

<p>
Ville: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html">N4462</a> reviewed in Lenexa. EWG discussion to continue in Kona.<br/>
</p>
<p><i>[2016-08 Chicago]</i></p>

<p>See <a href="http://wg21.link/N4462">N4462</a></p>
<p>The notes in Lenexa say that Marshall &amp; Jonathan volunteered to write a paper on this</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 20.10.9.1 [allocator.members] p12 as indicated:</p>

<blockquote><pre>
template &lt;class U, class... Args&gt;
  void construct(U* p, Args&amp;&amp;... args);
</pre><blockquote>
<p>
12 <i>Effects</i>: <tt>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</tt> <ins>if <tt>is_constructible&lt;U, Args...&gt;::value</tt> 
is <tt>true</tt>, else <tt>::new((void *)p) U{std::forward&lt;Args&gt;(args)...}</tt></ins>
</p>
</blockquote></blockquote>






<hr>
<h3><a name="2095" href="#2095">2095.</a> <tt>promise</tt> and <tt>packaged_task</tt> missing constructors needed for uses-allocator construction</h3>
<p><b>Section:</b> 30.6.5 [futures.promise], 30.6.9 [futures.task] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-11-01 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This example is ill-formed according to C++11 because <tt>uses_allocator&lt;promise&lt;R&gt;, A&gt;::value</tt> is true, but
<tt>is_constructible&lt;promise&lt;R&gt;, A, promise&lt;R&gt;&amp;&amp;&gt;::value</tt> is false. Similarly for <tt>packaged_task</tt>.
</p>
<blockquote><pre>
#include &lt;future&gt;
#include &lt;memory&gt;
#include &lt;tuple&gt;

using namespace std;

typedef packaged_task&lt;void()&gt; task;
typedef promise&lt;void&gt; prom;
allocator&lt;task&gt; a;

tuple&lt;task, prom&gt; t1{ allocator_arg, a };
tuple&lt;task, prom&gt; t2{ allocator_arg, a, task{}, prom{} };
</pre></blockquote>

<p><i>[2012, Portland]</i></p>

<p>
This is an allocator issue, and should be dealt with directly by LWG.
</p>

<p><i>[2013-03-06]</i></p>


<p>
Jonathan suggests to make the new constructors non-explicit and makes some representational improvements.
</p>


<p><i>[2013-09 Chicago]</i></p>

<p>
Move to deferred.
</p>
<p>
This issue has much in common with similar problems with <tt>std::function</tt> that are being addressed
by the polymorphic allocators proposal currently under evaluation in LEWG.  Defer further discussion on
this topic until the final outcome of that paper and its proposed resolution is known.
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2016-08 Chicago]</i></p>

<p>Fri PM: Send to LEWG  - and this also applies to <tt>function</tt> in LFTS.</p>


<p><b>Proposed resolution:</b></p>
<p><i>[This wording is relative to the FDIS.]</i></p>


<ol>
<li><p>Add to 30.6.5 [futures.promise], class template <tt>promise</tt> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class promise {
  public:
    promise();
    template &lt;class Allocator&gt;
    promise(allocator_arg_t, const Allocator&amp; a);
    <ins>template &lt;class Allocator&gt;
    promise(allocator_arg_t, const Allocator&amp; a, promise&amp;&amp; rhs) noexcept;</ins>
    promise(promise&amp;&amp; rhs) noexcept;
    promise(const promise&amp; rhs) = delete;
    ~promise();	
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 30.6.5 [futures.promise] as indicated:</p>

<blockquote><pre>
promise(promise&amp;&amp; rhs) noexcept;
<ins>template &lt;class Allocator&gt;
promise(allocator_arg_t, const Allocator&amp; a, promise&amp;&amp; rhs) noexcept;</ins>
</pre><blockquote>
<p>
-5- <i>Effects</i>: constructs a new <tt>promise</tt> object and transfers ownership of 
the shared state of <tt>rhs</tt> (if any) to the newly-constructed object.
<p/>
-6- <i>Postcondition</i>: <tt>rhs</tt> has no shared state.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>

<li><p>Add to 30.6.9 [futures.task], class template <tt>packaged_task</tt> synopsis, 
as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class&gt; class packaged_task; // <i>undefined</i>

  template&lt;class R, class... ArgTypes&gt;
  class packaged_task&lt;R(ArgTypes...)&gt; {
  public:
    // construction and destruction
    packaged_task() noexcept;
    <ins>template &lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a) noexcept;</ins>
    template &lt;class F&gt;
      explicit packaged_task(F&amp;&amp; f);
    template &lt;class F, class Allocator&gt;
      explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
    ~packaged_task();
	
    // no copy
    packaged_task(const packaged_task&amp;) = delete;
    <ins>template&lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a, const packaged_task&amp;) = delete;</ins>
    packaged_task&amp; operator=(const packaged_task&amp;) = delete;
    
    // move support
    packaged_task(packaged_task&amp;&amp; rhs) noexcept;
    <ins>template &lt;class Allocator&gt;
      packaged_task(allocator_arg_t, const Allocator&amp; a, packaged_task&amp;&amp; rhs) noexcept;</ins>
    packaged_task&amp; operator=(packaged_task&amp;&amp; rhs) noexcept;
    void swap(packaged_task&amp; other) noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 30.6.9.1 [futures.task.members] as indicated:</p>

<blockquote><pre>
packaged_task() noexcept;
<ins>template &lt;class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a) noexcept;</ins>
</pre><blockquote>
<p>
-1- <i>Effects</i>: constructs a <tt>packaged_task</tt> object with no shared state and no stored task.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>
<p>[&hellip;]</p>
<blockquote><pre>
packaged_task(packaged_task&amp;&amp; rhs) noexcept;
<ins>template &lt;class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a, packaged_task&amp;&amp; rhs) noexcept;</ins>
</pre><blockquote>
<p>
-5- <i>Effects</i>: constructs a new <tt>packaged_task</tt> object and transfers ownership of <tt>rhs</tt>'s 
shared state to <tt>*this</tt>, leaving <tt>rhs</tt> with no shared state. Moves the stored task from <tt>rhs</tt> 
to <tt>*this</tt>.
<p/>
-6- <i>Postcondition</i>: <tt>rhs</tt> has no shared state.
<p/>
<ins>-?- [<i>Note</i>: <tt>a</tt> is not used &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>
</ol>

<blockquote><pre>
</pre><blockquote>
<p>
</p></blockquote></blockquote>






<hr>
<h3><a name="2114" href="#2114">2114.</a> Incorrect "<em>contextually</em> convertible to <tt>bool</tt>" requirements</h3>
<p><b>Section:</b> 17.6.3.3 [nullablepointer.requirements], 24.2.3 [input.iterators], 24.2.7 [random.access.iterators], 25.1 [algorithms.general], 25.5 [alg.sorting], 30.2.1 [thread.req.paramname] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
As of 17.6.3.1 [utility.arg.requirements] Table 17&#47;18, the return types of the expressions
</p>
<blockquote><pre>
a == b
</pre></blockquote>
<p>
or
</p>
<blockquote><pre>
a &lt; b
</pre></blockquote>
<p>
for types satisfying the <tt>EqualityComparable</tt> or <tt>LessThanComparable</tt>
types, respectively, are required to be "convertible to <tt>bool</tt>" which corresponds to
a copy-initialization context. But several newer parts of the library that refer to 
such contexts have lowered the requirements taking  advantage of the new terminology of 
"<em>contextually</em> convertible to <tt>bool</tt>" instead, which corresponds to a 
direct-initialization context (In addition to "normal" direct-initialization constructions, 
operands of logical operations as well as <tt>if</tt> or <tt>switch</tt> conditions also 
belong to this special context).
<p/>
One example for these new requirements are input iterators which satisfy <tt>EqualityComparable</tt> 
but also specify that the expression
</p>
<blockquote><pre>
a != b
</pre></blockquote>
<p>
shall be just "<strong>contextually</strong> convertible to <tt>bool</tt>". The same discrepancy 
exists for requirement set <tt>NullablePointer</tt> in regard to several equality-related expressions.
<p/>
For random access iterators we have
</p>
<blockquote><p>
<tt>a &lt; b</tt>      contextually convertible to <tt>bool</tt>
</p></blockquote>
<p>
as well as for all derived comparison functions, so strictly speaking we could have a random access 
iterator that does not satisfy the <tt>LessThanComparable</tt> requirements, which looks like an
artifact to me.
<p/>
Even if we keep with the existing requirements based on <tt>LessThanComparable</tt> or
<tt>EqualityComparable</tt> we still would have the problem that some current specifications 
are actually  based on the assumption of implicit convertibility instead of "explicit convertibility", e.g. 
20.11.1.5 [unique.ptr.special] p3:
</p>
<blockquote><pre>
template &lt;class T1, class D1, class T2, class D2&gt;
bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>
<blockquote>
<p>
-3- <i>Returns</i>: <tt>x.get() != y.get()</tt>.
</p>
</blockquote></blockquote>
<p>
Similar examples exist in 20.11.1.2.2 [unique.ptr.single.dtor] p2, 20.11.1.2.3 [unique.ptr.single.asgn] p9,
20.11.1.2.4 [unique.ptr.single.observers] p1+3+8, etc.
<p/>
In all these places the expressions involving comparison functions (but <em>not</em> those of the conversion 
of a <tt>NullablePointer</tt> to <tt>bool</tt>!) assume to be "convertible to <tt>bool</tt>". I think this
is a very natural assumption and all delegations of the comparison functions of some type <tt>X</tt> to some
other API type <tt>Y</tt> in third-party code does so assuming that copy-initialization semantics will
just work.
<p/>
The actual reason for using the newer terminology can be rooted back to LWG <a href="lwg-defects.html#556">556</a>. My hypotheses 
is that the resolution of that issue also needs a slight correction. Why so?
<p/>
The reason for opening that issue were worries based on the previous "convertible to <tt>bool</tt>"
wording. An expressions like "<tt>!pred(a, b)</tt>" might not be well-formed in those situations, because
<tt>operator!</tt> might not be accessible or might have an unusual semantics (and similarly for other logical
operations). This can indeed happen with unusual proxy return types, so the idea was that the evaluation of 
<tt>Predicate</tt>, <tt>BinaryPredicate</tt> (25.1 [algorithms.general] p8+9), and <tt>Compare</tt> 
(25.5 [alg.sorting] p2) should be defined based on contextual conversion to <tt>bool</tt>. 
Unfortunately this <em>alone</em> is not sufficient: In addition, I think, we <em>also</em> want the predicates 
to be (implicitly) convertible to <tt>bool</tt>! Without this wording, several conditions are plain wrong, 
e.g. 25.3.5 [alg.find] p2, which talks about "<tt>pred(*i) != false</tt>" (<tt>find_if</tt>) and 
"<tt>pred(*i) == false</tt>" (<tt>find_if_not</tt>). These expressions are not within a boolean context! 
<p/>
While we could simply fix all these places by proper wording to be considered in a "contextual conversion to
<tt>bool</tt>", I think that this is not the correct solution: Many third-party libraries already refer to
the previous C++03 <tt>Predicate</tt> definition &mdash; it actually predates C++98 and is as old as the 
<a href="http://www.sgi.com/tech/stl/Predicate.html">SGI specification</a>. It seems to be a high price to
pay to switch to direct initialization here instead of fixing a completely different specification problem.
<p/>
A final observation is that we have another definition for a <tt>Predicate</tt> in 30.2.1 [thread.req.paramname] p2:
</p>
<blockquote><p>
If a parameter is <tt>Predicate</tt>, <tt>operator()</tt> applied to the actual template argument shall return a value that
is convertible to <tt>bool</tt>.
</p></blockquote>
<p>
The problem here is not that we have two different definitions of <tt>Predicate</tt> in the standard &mdash; this 
is confusing, but this fact alone is not a defect. The first (minor) problem is that this definition does not properly 
apply to function objects that are function pointers, because <tt>operator()</tt> is not defined in a strict sense. 
But the actually worse second problem is that this wording has the very <tt>same</tt> problem that has originally lead to
LWG <a href="lwg-defects.html#556">556</a>! We only need to look at 30.5.1 [thread.condition.condvar] p15 to recognice this:
</p>
<blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
<p>
The negation expression here looks very familiar to the example provided in LWG <a href="lwg-defects.html#556">556</a> and is sensitive
to the same "unusual proxy" problem. Changing the 30.2.1 [thread.req.paramname] wording to a corresponding
"contextual conversion to <tt>bool</tt>" wouldn't work either, because existing specifications rely on "convertible
to <tt>bool</tt>", e.g. 30.5.1 [thread.condition.condvar] p32+33+42 or 30.5.2 [thread.condition.condvarany] 
p25+26+32+33.
<p/>
To summarize: I believe that LWG <a href="lwg-defects.html#556">556</a> was not completely resolved. A pessimistic interpretation is,
that even with the current wording based on "contextually convertible to <tt>bool</tt>" the actual problem of that 
issue has <em>not</em> been fixed. What actually needs to be required here is some normative wording that basically
expresses something along the lines of:
</p>
<blockquote><p>
The semantics of <em>any</em> contextual conversion to <tt>bool</tt> shall be equivalent to the semantics of 
any implicit conversion to <tt>bool</tt>.
</p></blockquote>
<p>
This is still not complete without having concepts, but it seems to be a better approximation. Another way of solving
this issue would be to define a minimum requirements table with equivalent semantics. The proposed wording is a bit
simpler but attempts to express the same thing.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Agree with Daniel that we potentially broke some C++03 user code, accept the changes striking
"contextually" from tables.  Stefan to provide revised wording for section 25, and figure out
changes to section 30.
</p>
<p>
Move to open, and then to Review when updated wording from Stefan is available.
</p>

<p><i>[2012-10-12, STL comments]</i></p>


<ol>
<li>
<p>
The current proposed resolution still isn't completely satisfying. It would certainly be possible for the Standard to 
require these various expressions to be implicitly and contextually convertible to <tt>bool</tt>, but that would have 
a subtle consequence (which, I will argue, is undesirable - regardless of the fact that it dates all the way back to 
C++98/03). It would allow users to provide really wacky types to the Standard Library, with one of two effects:
</p>
<ol style="list-style-type:upper-alpha">
<li>
<p>Standard Library implementations would have to go to great lengths to respect such wacky types, essentially using 
<tt>static_cast&lt;bool&gt;</tt> when invoking any predicates or comparators.
</p>
</li>

<li>
<p>
Otherwise, such wacky types would be de facto nonportable, because they would make Standard Library implementations 
explode.
</p>
</li>
</ol>

<p>
Effect B is the status quo we're living with today. What Standard Library implementations want to do with <tt>pred(args)</tt> 
goes beyond "<tt>if (pred(args))</tt>" (C++03), contextually converting <tt>pred(args)</tt> to <tt>bool</tt> (C++11), or 
implicitly and contextually converting <tt>pred(args)</tt> to <tt>bool</tt> (the current proposed resolution). 
Implementations want to say things like:
</p>

<blockquote><pre>
if (pred(args))
if (!pred(args))
if (cond &amp;&amp; pred(args))
if (cond &amp;&amp; !pred(args))
</pre></blockquote>

<p>
These are real examples taken from Dinkumware's implementation. There are others that would be realistic 
("<tt>pred(args) &amp;&amp; cond</tt>", "<tt>cond || pred(args)</tt>", etc.)
<p/>
Although negation was mentioned in this issue's Discussion section, and in LWG <a href="lwg-defects.html#556">556</a>'s, the current proposed 
resolution doesn't fix this problem. Requiring <tt>pred(args)</tt> to be implicitly and contextually convertible to <tt>bool</tt> 
doesn't prevent <tt>operator!()</tt> from being overloaded and returning <tt>std::string</tt> (as a wacky example). More 
ominously, it doesn't prevent <tt>operator&amp;&amp;()</tt> and <tt>operator||()</tt> from being overloaded and destroying 
short-circuiting.
</p>

</li>

<li>
<p>
I would like LWG input before working on Standardese for a new proposed resolution. Here's an outline of what I'd like to 
do:
</p>
<ol style="list-style-type:upper-alpha">
<li>
<p>
Introduce a new "concept" in 17.6.3 [utility.requirements], which I would call <tt>BooleanTestable</tt> in the 
absence of better ideas.
</p>
</li>

<li>
<p>
Centralize things and reduce verbosity by having everything simply refer to <tt>BooleanTestable</tt> when necessary. 
I believe that the tables could say "Return type: <tt>BooleanTestable</tt>", while Predicate/BinaryPredicate/Compare 
would need the incantation "shall satisfy the requirements of BooleanTestable".
</p>
</li>

<li>
<p>
Resolve the tug-of-war between users (who occasionally want to do weird things) and implementers (who don't want to have 
to contort their code) by requiring that:
</p>
<ol style="list-style-type:upper-roman">
<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>x</tt> is both implicitly and contextually convertible to <tt>bool</tt>.
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>!x</tt> is <tt>BooleanTestable</tt>. (This is intentionally "recursive".)
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt>, <tt>bool t = x, t2(x), f = !x;</tt> has the postcondition <tt>t == t2 &amp;&amp; t != f</tt>.
</p>
</li>

<li>
<p>
Given a <tt>BooleanTestable x</tt> and a <tt>BooleanTestable y</tt> of possibly different types, "<tt>x &amp;&amp; y</tt>" 
and "<tt>x || y</tt>" invoke the built-in <tt>operator&amp;&amp;()</tt> and <tt>operator||()</tt>, triggering short-circuiting.
</p>
</li>

<li>
<p>
<tt>bool</tt> is <tt>BooleanTestable</tt>.
</p>
</li>
</ol>

</li>

</ol>

<p>
 I believe that this simultaneously gives users great latitude to use types other than <tt>bool</tt>, while allowing 
 implementers to write reasonable code in order to get their jobs done. (If I'm forgetting anything that implementers 
 would want to say, please let me know.)
</p>

</li>

<li>
<p>
About requirement (I): As Daniel patiently explained to me, we need to talk about both implicit conversions and 
contextual conversions, because it's possible for a devious type to have both "<tt>explicit operator bool()</tt>" 
and "<tt>operator int()</tt>", which might behave differently (or be deleted, etc.).
</p>
</li>

<li>
<p>
About requirement (IV): This is kind of tricky. What we'd like to say is, "<tt>BooleanTestable</tt> can't ever trigger 
an overloaded logical operator". However, given a perfectly reasonable type <tt>Nice</tt> - perhaps even <tt>bool</tt> itself! - 
other code (perhaps a third-party library) could overload <tt>operator&amp;&amp;(Nice, Evil)</tt>. Therefore, I believe 
that the requirement should be "no first use" - the Standard Library will ask for various <tt>BooleanTestable</tt> types 
from users (for example, the result of "<tt>first != last</tt>" and the result of "<tt>pred(args)</tt>"), and as long 
as they don't trigger overloaded logical operators with each other, everything is awesome.
</p>
</li>


<li>
<p>
About requirement (V): This is possibly redundant, but it's trivial to specify, makes it easier for users to understand 
what they need to do ("oh, I can always achieve this with <tt>bool</tt>"), and provides a "base case" for requirement 
(IV) that may or may not be necessary.  Since <tt>bool</tt> is <tt>BooleanTestable</tt>, overloading 
<tt>operator&amp;&amp;(bool, Other)</tt> (etc.) clearly makes the <tt>Other</tt> type non-<tt>BooleanTestable</tt>.
</p>
</li>
</ol>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<p/>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change Table 25 &mdash; "<tt>NullablePointer</tt> requirements" in 17.6.3.3 [nullablepointer.requirements]
as indicated:</p>

<table border="1">
<caption>Table 25 &mdash; <tt>NullablePointer</tt> requirements</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
</tr> 

<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == b)</tt>
</td>
</tr>

<tr>
<td>
<tt>a == np<br/>
np == a</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>a == P()</tt>
</td>
</tr>

<tr>
<td>
<tt>a != np<br/>
np != a</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == np)</tt>
</td>
</tr>

</table>
 
</li>

<li><p>Change Table 107 &mdash; "Input iterator requirements" in 24.2.3 [input.iterators]
as indicated:</p>

<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a == b)</tt>
</td>
<td>
pre: <tt>(a, b)</tt> is in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

</table>
 
</li>

<li><p>Change Table 111 &mdash; "Random access iterator requirements" in 24.2.7 [random.access.iterators]
as indicated:</p>

<table border="1">
<caption>Table 111 &mdash; Random access iterator requirements (in addition to bidirectional iterator)</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr> 

<tr>
<td colspan="4" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>b - a &gt; 0</tt>
</td>
<td>
<tt>&lt;</tt> is a total ordering relation
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>b &lt; a</tt>
</td>
<td>
<tt>&gt;</tt> is a total ordering relation opposite to <tt>&lt;</tt>.
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a &lt; b)</tt>
</td>
<td>
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>contextually</del> convertible to <tt>bool</tt>
</td>
<td>
<tt>!(a &gt; b)</tt>
</td>
<td>
</td>
</tr>

</table>
 
</li>

<li><p>Change 25.1 [algorithms.general] p8+9 as indicated:</p>

<blockquote>
<p>
-8- The <tt>Predicate</tt> parameter is used whenever an algorithm expects a function object 
(20.14 [function.objects]) that, when applied to the result of dereferencing the corresponding iterator, 
returns a value testable as <tt>true</tt>. In other words, if an algorithm takes <tt>Predicate pred</tt> 
as its argument and first as its iterator argument, it should work correctly in the construct 
<tt>pred(*first)</tt> <ins>implicitly or</ins> contextually converted to <tt>bool</tt> (Clause 4 [conv]). 
The function object <tt>pred</tt> shall not apply any non-constant function through the dereferenced iterator.
<p/>
-9- The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a function object that when applied
to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type
<tt>T</tt> when <tt>T</tt> is part of the signature returns a value testable as <tt>true</tt>. In other words, if an algorithm takes
<tt>BinaryPredicate binary_pred</tt> as its argument and <tt>first1</tt> and <tt>first2</tt> as its iterator arguments, it should
work correctly in the construct <tt>binary_pred(*first1, *first2)</tt> <ins>implicitly or</ins> contextually converted to 
<tt>bool</tt> (Clause 4 [conv]).
<tt>BinaryPredicate</tt> always takes the first iterator's <tt>value_type</tt> as its first argument, that is, in those cases
when <tt>T</tt> value is part of the signature, it should work correctly in the construct <tt>binary_pred(*first1, value)</tt> 
<ins>implicitly or</ins> contextually converted to <tt>bool</tt> (Clause 4 [conv]). <tt>binary_pred</tt> shall 
not apply any non-constant function through the dereferenced iterators.
</p>
</blockquote>
</li>

<li><p>Change 25.5 [alg.sorting] p2 as indicated:</p>

<blockquote>
<p>
-2- <tt>Compare</tt> is a function object type (20.14 [function.objects]). The return value of the function 
call operation applied to an object of type <tt>Compare</tt>, when <ins>implicitly or</ins> contextually converted 
to <tt>bool</tt> (4 [conv]), yields <tt>true</tt> if the first argument of the call is less than the second, and 
<tt>false</tt> otherwise. <tt>Compare comp</tt> is used throughout for algorithms assuming an ordering relation. It is assumed 
that <tt>comp</tt> will not apply any non-constant function through the dereferenced iterator.
</p>
</blockquote>
</li>

<li><p>Change 30.2.1 [thread.req.paramname] p2 as indicated:</p>

<blockquote>
<p>
-2- <del>If a parameter is <tt>Predicate</tt>, operator() applied to the actual template argument shall return a value that
is convertible to <tt>bool</tt></del><ins><tt>Predicate</tt> is a function object type (20.14 [function.objects]).
The return value of the function call operation applied to an object of type <tt>Predicate</tt>, when implicitly or 
contextually converted to <tt>bool</tt> (4 [conv]), yields <tt>true</tt> if the corresponding test condition is
satisfied, and <tt>false</tt> otherwise</ins>.
</p>
</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2014-05-20, Daniel suggests concrete wording based on STL's proposal]</i></p>

<p>
The presented wording follows relatively closely STL's outline with the following notable exceptions:
</p>
<ol style="list-style-type:upper-alpha">
<li><p>
A reference to <tt>BooleanTestable</tt> in table "Return Type" specifications seemed very unusual to me and
I found no "prior art" for this in the Standard. Instead I decided to follow the usual style to add a symbol
with a specific meaning to a specific paragraph that specifies symbols and their meanings.
</p></li>
<li><p>
STL's requirement IV suggested to directly refer to built-in operators <tt>&amp;&amp;</tt> and <tt>||</tt>. In my
opinion this concrete requirement isn't needed if we simply require that two <tt>BooleanTestable</tt> operands behave 
equivalently to two those operands after conversion to <tt>bool</tt> (each of them).
</p></li>
<li><p>
I couldn't find a good reason to require normatively that type <tt>bool</tt> meets the requirements of <tt>BooleanTestable</tt>: My
assertion is that after having defined them, the result simply falls out of this. But to make this a bit clearer, I added
also a non-normative note to these effects.
</p></li>
</ol>

<p><i>[2014-06-10, STL comments]</i></p>

<p>
In the current wording I would like to see changed the suggested changes described by bullet #6:
</p>
<ol style="list-style-type:upper-alpha">
<li><p>In 23.2.1 [container.requirements.general] p4 undo the suggested change</p></li>
<li><p>Then change the 7 occurrences of "convertible to <tt>bool</tt>" in the denoted tables to "<tt>bool</tt>".</p></li>
</ol>

<p><i>[2015-05-05 Lenexa]</i></p>

<p>STL: Alisdair wanted to do something here, but Daniel gave us updated wording.</p>

<p><i>[2015-07 Telecom]</i></p>
<p>
Alisdair: Should specify we don't break short circuiting.<br/>
Ville: Looks already specified because that's the way it works for bool. <br/>
Geoffrey: Maybe add a note about the short circuiting.<br/>
B2/P2 is somewhat ambiguous. It implies that B has to be both implicitly convertible to bool and contextually convertible to bool.<br/>
We like this, just have nits.<br/>
Status stays Open.<br/>
Marshall to ping Daniel with feedback.<br/>
</p>

<p><i>[2016-02-27, Daniel updates wording]</i></p>

<ol>
<li>
<p>
The revised wording has been updated from N3936 to N4567. 
</p>
</li>
<li>
<p>
To satisfy the Kona 2015 committee comments, the wording in 
[booleantestable.requirements] has been improved to better separate the two different requirements of "can be 
contextually converted to <tt>bool</tt>" and "can be implicitly converted to <tt>bool</tt>. Both are necessary because 
it is possible to define a type that has the latter property but not the former, such as the following one:
</p>
<blockquote class="note">
<p>
2016-08-07, Daniel: The below example has been corrected to reduce confusion about the performed conversions as indicated
by the delta markers:
</p>
</blockquote>
<blockquote><pre>
using Bool = int;

struct OddBoolean 
{
  explicit <ins>operator bool() const = delete;
  operator Bool() const;</ins>
  <del>OddBoolean(bool) = delete;
  OddBoolean(Bool){}</del>
} <ins>ob</ins>;

<ins>bool b2 = ob; // OK
bool b1(ob);  // Error</ins>
<del>OddBoolean b2 = true; // OK
OddBoolean b1(true);  // Error</del>
<ins></ins>
</pre></blockquote>
</li>
<li>
<p>
In [booleantestable.requirements] a note has been added to ensure that an implementation is not allowed to 
break any short-circuiting semantics.
</p>
</li>
<li>
<p>
I decided to separate LWG <a href="lwg-active.html#2587">2587</a>/<a href="lwg-active.html#2588">2588</a> from this issue. Both these issues aren't exactly the
same but depending on the committee's position, their resolution might benefit from the new vocabulary introduced
here.
</p>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 17.6.3.1 [utility.arg.requirements] p1, Table 17 &mdash; "EqualityComparable requirements", and
Table 18 &mdash; "LessThanComparable requirements" as indicated:</p>

<blockquote>
<p>
-1- [&hellip;] In these tables, <tt>T</tt> is an object or reference type to be supplied by a C++ program
instantiating a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are values of type (possibly <tt>const</tt>) <tt>T</tt>; 
<tt>s</tt> and <tt>t</tt> are modifiable lvalues of type <tt>T</tt>; <tt>u</tt> denotes an identifier; <tt>rv</tt> 
is an rvalue of type <tt>T</tt>; <del>and</del> <tt>v</tt> is an lvalue of type (possibly <tt>const</tt>) <tt>T</tt> or an
rvalue of type <tt>const T</tt><ins>; and <tt>BT</tt> denotes a type that meets the <tt>BooleanTestable</tt> 
requirements ([booleantestable.requirements])</ins>.
<p/>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 17 &mdash; <tt>EqualityComparable</tt> requirements [equalitycomparable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<tt>a == b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
<tt>==</tt> is an equivalence relation, that is, it has the
following properties: [&hellip;]
</td>
</tr>

</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 18 &mdash; <tt>LessThanComparable</tt> requirements [lessthancomparable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Requirement</th>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
<tt>&lt;</tt> is a strict weak ordering relation (25.5 [alg.sorting])
</td>
</tr>

</table>
</blockquote>

</blockquote>

</li>

<li><p>Between 17.6.3.2 [swappable.requirements] and 17.6.3.3 [nullablepointer.requirements] insert a new sub-clause 
as indicated:</p>

<blockquote>
?.?.?.? <b><tt>BooleanTestable</tt> requirements [booleantestable.requirements]</b>  
<blockquote>
<p>
-?- A <tt>BooleanTestable</tt> type is a boolean-like type that also supports conversions to <tt>bool</tt>.
A type <tt>B</tt> meets the <tt>BooleanTestable</tt> requirements if the expressions described in Table ?? are valid 
and have the indicated semantics, and if <tt>B</tt> also satisfies all the other requirements of this sub-clause 
[booleantestable.requirements].
<p/>
An object <tt>b</tt> of type <tt>B</tt> can be implicitly converted to <tt>bool</tt> and in addition can be 
contextually converted to <tt>bool</tt> (Clause 4). The result values of both kinds of conversions shall be equivalent. 
<p/>
[<i>Example</i>: The types <tt>bool</tt>, <tt>std::true_type</tt>, and <tt>std::bitset&lt;&gt;::reference</tt> are 
<tt>BooleanTestable</tt> types. &mdash; <i>end example</i>]
<p/>
For the purpose of Table ??, let <tt>B2</tt> and <tt>Bn</tt> denote types (possibly both equal to <tt>B</tt> or to each other) 
that meet the <tt>BooleanTestable</tt> requirements, let <tt>b1</tt> denote a (possibly <tt>const</tt>) value of <tt>B</tt>, 
let <tt>b2</tt> denote a (possibly <tt>const</tt>) value of <tt>B2</tt>, and let <tt>t1</tt> denote a value of type 
<tt>bool</tt>.
<p/>
[<i>Note</i>: These rules ensure what an implementation can rely on but doesn't grant it
license to break short-circuiting behavior of a <tt>BooleanTestable</tt> type. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Somewhere within the new sub-clause [booleantestable.requirements] insert the following new Table (?? denotes
the assigned table number):</p>

<blockquote>
<table border="1">
<caption>Table ?? &mdash; <tt>BooleanTestable</tt> requirements [booleantestable]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational semantics</th>
</tr>

<tr>
<td>
<tt>bool(b1)</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<i>Remarks</i>: <tt>bool(b1) == t1</tt> for every value<br/>
<tt>b1</tt> implicitly converted to <tt>t1</tt>.
</td>
</tr>

<tr>
<td>
<tt>!b1</tt>
</td>
<td>
<tt>Bn</tt>
</td>
<td>
<i>Remarks</i>: <tt>bool(b1) == !bool(!b1)</tt> for<br/>
every value <tt>b1</tt>.
</td>
</tr>

<tr>
<td>
<tt>b1 &amp;&amp; b2</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<tt>bool(b1) &amp;&amp; bool(b2)</tt>
</td>
</tr>

<tr>
<td>
<tt>b1 || b2</tt>
</td>
<td>
<tt>bool</tt>
</td>
<td>
<tt>bool(b1) || bool(b2)</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 17.6.3.3 [nullablepointer.requirements] p5 and Table 25 &mdash; "NullablePointer requirements" as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-5- In Table 25, <tt>u</tt> denotes an identifier, <tt>t</tt> denotes a non-<tt>const</tt> lvalue of type <tt>P</tt>, <tt>a</tt> 
and <tt>b</tt> denote values of type (possibly <tt>const</tt>) <tt>P</tt>, <del>and</del> <tt>np</tt> denotes a value of type 
(possibly <tt>const</tt>) <tt>std::nullptr_t</tt><ins>, and <tt>BT</tt> denotes a type that meets the <tt>BooleanTestable</tt> 
requirements ([booleantestable.requirements])</ins>.
<p/>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 25 &mdash; <tt>NullablePointer</tt> requirements [nullablepointer]</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational semantics</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a == np</tt><br/>
<tt>np == a</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a != np</tt><br/>
<tt>np != a</tt>
</td>
<td>
<del>contextually convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.5.2.8 [tuple.rel] as indicated;</p>

<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: For all <tt>i</tt>, where <tt>0 &lt;= i</tt> and <tt>i &lt; sizeof...(TTypes)</tt>, 
<tt>get&lt;i&gt;(t) == get&lt;i&gt;(u)</tt> is a valid expression returning a type that <del>is convertible to 
<tt>bool</tt></del><ins>meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>. 
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-4- <i>Requires</i>: For all <tt>i</tt>, where <tt>0 &lt;= i</tt> and <tt>i &lt; sizeof...(TTypes)</tt>, 
<tt>get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</tt> and <tt>get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</tt> are valid 
expressions returning types that <del>are convertible to 
<tt>bool</tt></del><ins>meet the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>. 
<tt>sizeof...(TTypes) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.2.1 [container.requirements.general], Table 95 &mdash; "Container requirements", and
Table 97 &mdash; "Optional container operations" as indicated:</p>

<blockquote>
<p>
-4- In Tables 95, 96, and 97 <tt>X</tt> denotes a container class containing objects of type <tt>T</tt>, <tt>a</tt> and 
<tt>b</tt> denote values of type <tt>X</tt>, <tt>u</tt> denotes an identifier, <tt>r</tt> denotes a non-<tt>const</tt> value 
of type <tt>X</tt>, <del>and</del> <tt>rv</tt> denotes a non-<tt>const</tt> rvalue of type <tt>X</tt><ins>, and <tt>BT</tt> 
denotes a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>.
</p>
<blockquote>
<table border="1">
<caption>Table 95 &mdash; Container requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a == b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.empty()</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 97 &mdash; Optional container requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 24.2.1 [iterator.requirements.general], Table 106 &mdash; "Input iterator requirements", and
Table 110 &mdash; "Random access iterator requirements" as indicated:</p>

<blockquote>
<p>
-12- In the following sections, <tt>a</tt> and <tt>b</tt> denote values of type <tt>X</tt> or <tt>const X</tt>, 
<tt>difference_type</tt> and <tt>reference</tt> refer to the types <tt>iterator_traits&lt;X&gt;::difference_type</tt> and 
<tt>iterator_traits&lt;X&gt;::reference</tt>, respectively, <tt>n</tt> denotes a value of <tt>difference_type</tt>, <tt>u</tt>, 
<tt>tmp</tt>, and <tt>m</tt> denote identifiers, <tt>r</tt> denotes a value of <tt>X&amp;</tt>, <tt>t</tt> denotes
a value of value type <tt>T</tt>, <tt>o</tt> denotes a value of some type that is writable to the output iterator<ins>, and <tt>BT</tt> 
denotes a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements])</ins>.
</p>
<blockquote>
<table border="1">
<caption>Table 106 &mdash; Input iterator requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td>
<tt>a != b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>
</table>
</blockquote>
<p>
[&hellip;]
</p>
<blockquote>
<table border="1">
<caption>Table 110 &mdash; Random access iterator requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a &lt; b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt; b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &gt;= b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>a &lt;= b</tt>
</td>
<td>
<del>contextually convertible to<br/>
<tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
</li>

<li><p>Change 25.1 [algorithms.general] p8+p9 as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording changes below also fix
(a) unusual wording forms used ("should work") which are unclear in which sense they are imposing normative requirements and
(b) the problem, that the current wording seems to allow that the predicate may mutate a call argument, if that is not a 
dereferenced iterator.
Upon applying the new wording it became obvious that the both the previous and the new wording has the effect that currently 
algorithms such as <tt>adjacent_find</tt>, <tt>search_n</tt>, <tt>unique</tt>, and <tt>unique_copy</tt> are not correctly 
described (because they have no iterator argument named <tt>first1</tt>), which could give raise to a new library issue. 
&mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<p>
-8- The <tt>Predicate</tt> parameter is used whenever an algorithm expects a function object (20.9) that, when applied
to the result of dereferencing the corresponding iterator, returns a value testable as <tt>true</tt>. <del>In other words,
i</del><ins>I</ins>f an algorithm takes <tt>Predicate pred</tt> as its argument and <tt>first</tt> as its iterator argument, 
<del>it should work correctly in the construct <tt>pred(*first)</tt> contextually converted to 
<tt>bool</tt> (Clause 4)</del><ins>the expression <tt>pred(*first)</tt> shall have a type that meets the <tt>BooleanTestable</tt> 
requirements ( [booleantestable.requirements])</ins>. 
The function object <tt>pred</tt> shall not apply any non-constant function through <del>the dereferenced 
iterator</del><ins>its argument</ins>.
<p/>
-9- The <tt>BinaryPredicate</tt> parameter is used whenever an algorithm expects a function object that when applied
to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type
<tt>T</tt> when <tt>T</tt> is part of the signature returns a value testable as <tt>true</tt>. <del>In other words, 
i</del><ins>I</ins>f an algorithm takes <tt>BinaryPredicate binary_pred</tt> as its argument and <tt>first1</tt> and 
<tt>first2</tt> as its iterator arguments, <del>it should work correctly in the construct <tt>binary_pred(*first1, *first2)</tt> 
contextually converted to <tt>bool</tt> (Clause 4)</del><ins>the expression <tt>binary_pred(*first1, *first2)</tt> shall 
have a type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements])</ins>. 
<tt>BinaryPredicate</tt> always takes the first iterator's <tt>value_type</tt> as its first argument, that is, in those cases 
when <tt>T</tt> value is part of the signature, <del>it should work correctly in the construct <tt>binary_pred(*first1, value)</tt> 
contextually converted to <tt>bool</tt> (Clause 4)</del><ins>the expression <tt>binary_pred(*first1, value)</tt> shall have a 
type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements])</ins>. <tt>binary_pred</tt> 
shall not apply any non-constant function through <del>the dereferenced iterators</del><ins>any of its arguments</ins>.
</p>
</blockquote>
</li>

<li><p>Change 25.5 [alg.sorting] p2 as indicated:</p>

<blockquote>
<p>
[&hellip;]
<p/>
-2- <tt>Compare</tt> is a function object type (20.9). <del>The return value of the function call 
operation applied to an object of type <tt>Compare</tt>, when contextually converted 
to <tt>bool</tt>(Clause 4), yields <tt>true</tt> if the first argument of the call is less than the second, 
and <tt>false</tt> otherwise.</del> <tt>Compare comp</tt> is used throughout for algorithms assuming an ordering relation. 
<ins>Let <tt>a</tt> and <tt>b</tt> denote two argument values whose types depend on the corresponding algorithm. Then the expression 
<tt>comp(a, b)</tt> shall have a type that meets the <tt>BooleanTestable</tt> requirements ( [booleantestable.requirements]).
The return value of <tt>comp(a, b)</tt>, converted to <tt>bool</tt>, yields <tt>true</tt> if the 
first argument <tt>a</tt> is less than the second argument <tt>b</tt>, and <tt>false</tt> otherwise.</ins> It is assumed that 
<tt>comp</tt> will not apply any non-constant function through <del>the dereferenced iterator</del><ins>any of its arguments</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
</li>

<li><p>Change 27.5.4.2 [fpos.operations] and Table 126 &mdash; "Position type requirements" as indicated:</p>

<blockquote>
<p>
-1- Operations specified in Table 126 are permitted. In that table,
</p>
<ul>
<li><p><tt>P</tt> refers to an instance of <tt>fpos</tt>,</p></li>
<li><p>[&hellip;]</p></li>
<li><p><tt>o</tt> refers to a value of type <tt>streamoff</tt>,</p></li>
<li><p><ins><tt>BT</tt> refers to a type that meets the <tt>BooleanTestable</tt> requirements ([booleantestable.requirements]),</ins></p></li>
<li><p>[&hellip;]</p></li>
</ul>
<blockquote>
<table border="1">
<caption>Table 126 &mdash; Position type requirements</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">[&hellip;]</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>p == q</tt>
</td>
<td>
<del>convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>p != q</tt>
</td>
<td>
<del>convertible to <tt>bool</tt></del><ins><tt>BT</tt></ins>
</td>
<td>
[&hellip;]
</td>
</tr>

</table>
</blockquote>
</blockquote>
<blockquote>
</blockquote>
</li>

<li><p>Change 30.2.1 [thread.req.paramname] p1 as indicated:</p>

<blockquote>
<p>
-1- Throughout this Clause, the names of template parameters are used to express type requirements. <del>If a template
parameter is named <tt>Predicate</tt>, <tt>operator()</tt> applied to the template argument shall return a value that
is convertible to <tt>bool</tt></del><ins><tt>Predicate</tt> is a function object type (20.14 [function.objects]).
Let <tt>pred</tt> denote an lvalue of type <tt>Predicate</tt>. Then the expression <tt>pred()</tt> shall have a type that meets the 
<tt>BooleanTestable</tt> requirements ( [booleantestable.requirements]). The return value of <tt>pred()</tt>, 
converted to <tt>bool</tt>, yields <tt>true</tt> if the corresponding test condition is satisfied, and <tt>false</tt> otherwise</ins>.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2115" href="#2115">2115.</a> Undefined behaviour for <tt>valarray</tt> assignments with <tt>mask_array</tt> index?</h3>
<p><b>Section:</b> 26.7.8 [template.mask.array] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2011-12-10 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Recently I received a Service Request (SR) alleging that one of our testcases causes an 
undefined behavior. The complaint is that 26.7.8 [template.mask.array] in C++11 
(and the corresponding subclause in C++03) are interpreted by some people to require that 
in an assignment "<tt>a[mask] = b</tt>", the subscript <tt>mask</tt> and the rhs <tt>b</tt> 
must have the same number of elements.
<p/>
IMHO, if that is the intended requirement, it should be stated explicitly.
<p/>
In any event, there is a tiny editorial cleanup that could be made:
<p/>
In C++11, 26.7.8.1 [template.mask.array.overview] para 2 mentions
</p>
<blockquote><p>
"the expression <tt>a[mask] = b;</tt>"
</p></blockquote>
<p>
but the semicolon cannot be part of an expression. The correction could omit the 
semicolon, or change the word "expression" to "assignment" or "statement".
<p/>
Here is the text of the SR, slightly modified for publication:
</p>
<blockquote>
<p>
Subject:  SR01174 LVS _26322Y31 has undefined behavior [open]
<p/>
[Client:]<br/>
The test case t263.dir&#47;_26322Y31.cpp seems to be illegal as it has an undefined 
behaviour. I searched into the SRs but found SRs were not related to the topic 
explained in this mail (SR00324, SR00595, SR00838).
</p>
<blockquote><pre>
const char vl[] = {"abcdefghijklmnopqrstuvwxyz"};
const char vu[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
const std::valarray&lt;char&gt; v0(vl, 27), vm5(vu, 5), vm6(vu, 6);
std::valarray&lt;char&gt; x = v0;
[&hellip;]
const bool vb[] = {false, false, true, true, false, true};
const std::valarray&lt;bool&gt; vmask(vb, 6);
x = v0;
x[vmask] = vm5;      // ***** HERE....
steq(&amp;x[0], "abABeCghijklmnopqrstuvwxyz");
x2 = x[vmask];       // ***** ....AND HERE
[&hellip;]
</pre></blockquote>
<p>
This problem has already been discussed between [experts]:
See thread <a href="http://gcc.gnu.org/ml/libstdc++/2009-11/threads.html#00051">http:&#47;&#47;gcc.gnu.org&#47;ml&#47;libstdc++&#47;2009-11&#47;threads.html#00051</a> 
Conclusion <a href="http://gcc.gnu.org/ml/libstdc++/2009-11/msg00099.html">http:&#47;&#47;gcc.gnu.org&#47;ml&#47;libstdc++&#47;2009-11&#47;msg00099.html</a>
<p/>
[Plum Hall:]<br/>
Before I log this as an SR, I need to check one detail with you.
<p/>
I did read the email thread you mentioned, and I did find a citation (see INCITS ISO&#47;IEC 14882-2003 
Section 26.3.2.6 on valarray computed assignments):
<p/>
Quote: "If the array and the argument array do not have the same length, the behavior is undefined",
<p/>
But this applies to computed assignment (<tt>*=</tt>, <tt>+=</tt>, etc), not to simple assignment. Here is the C++03 citation 
re simple assignment:
<p/>
26.3.2.2 valarray assignment [lib.valarray.assign]
</p>
<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp;);
</pre><blockquote>
<p>
1 Each element of the <tt>*this</tt> array is assigned the value of the corresponding element of the argument array.
The resulting behavior is undefined if the length of the argument array is not equal to the length of the
<tt>*this</tt> array.
</p>
</blockquote></blockquote>
<p>
In the new C++11 (N3291), we find ...
<p/>
26.6.2.3 valarray assignment [valarray.assign]
</p>
<blockquote><pre>
valarray&lt;T&gt;&amp; operator=(const valarray&lt;T&gt;&amp; v);
</pre><blockquote>
<p>
1 Each element of the <tt>*this</tt> array is assigned the value of the corresponding element of the argument
array. If the length of <tt>v</tt> is not equal to the length of <tt>*this</tt>, resizes <tt>*this</tt> to make 
the two arrays the same length, as if by calling <tt>resize(v.size())</tt>, before performing the assignment.
</p>
</blockquote></blockquote>
<p>
So it looks like the testcase might be valid for C++11 but not for C++03; what do you think?
<p/>
[Client:]<br/>
I quite agree with you but the two problems I mentioned:
</p>
<blockquote><pre>
x[vmask] = vm5;      // ***** HERE....
[&hellip;]
x2 = x[vmask];       // ***** ....AND HERE
</pre></blockquote>
<p>
refer to <tt>mask_array</tt> assignment hence target the C++03 26.3.8 paragraph. Correct?
<p/>
[Plum Hall:]<br/>
I mentioned the contrast between C++03 26.3.2.2 para 1 versus C++11 26.6.2.3 para 1.
<p/>
But in C++03 26.3.8, I don't find any corresponding restriction. Could you quote the specific 
requirement you're writing about?
<p/>
[Client:]<br/>
I do notice the difference between c++03 26.3.2.2 and c++11 26.6.2.3 about assignments between 
different sized <tt>valarray</tt> and I perfectly agree with you.
<p/>
But, as already stated, this is not a simple <tt>valarray</tt> assignment but a
<tt>mask_array</tt> assignment (c++03 26.3.8 &#47; c++11 26.6.8). See c++11 quote below:
<p/>
26.6.8 Class template mask_array<br/>
26.6.8.1 Class template mask_array overview<br/>
[....]
</p>
<ol>
<li><p>This template is a helper template used by the mask subscript operator:
<tt>mask_array&lt;T&gt; valarray&lt;T&gt;::operator[](const valarray&lt;bool&gt;&amp;)</tt>.
</p></li>
<li><p>It has reference semantics to a subset of an array specified by a boolean mask. Thus, 
the expression <tt>a[mask] = b;</tt> has the effect of assigning <em>the elements of <tt>b</tt></em> 
to the masked elements in <tt>a</tt> (those for which the corresponding element in <tt>mask</tt> is true.)
</p></li>
</ol>
<p>
26.6.8.2 mask_array assignment
</p>
<blockquote><pre>
void operator=(const valarray&lt;T&gt;&amp;) const;
const mask_array&amp; operator=(const mask_array&amp;) const;
</pre><blockquote>
<p>
1 These assignment operators have reference semantics, assigning the values of the argument array 
elements to selected elements of the <tt>valarray&lt;T&gt;</tt> object to which it refers.
</p>
</blockquote></blockquote>
<p>
In particular, [one of the WG21 experts] insisted on the piece "the elements of <tt>b</tt>".
<p/>
That is why I reported the test t263.dir&#47;_26322Y31.cpp having an undefined behaviour.
<p/>
[Plum Hall:]<br/>
OK, I can see that I will have to ask WG21; I will file an appropriate issue 
with the Library subgroup. In the meantime, I will mark this testcase as "DISPUTED" 
so that it is not required for conformance testing, until we get a definitive opinion.
</p>
</blockquote>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Open.
</p>
<p>
There appears to be a real need for clarification in the standard, and
implementations differ in their current interpretation.  This will need
some research by implementers and a proposed resolution before further
discussion is likely to be fruitful.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2116" href="#2116">2116.</a> <tt>std::swap noexcept(what?)</tt></h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Dave Abrahams <b>Opened:</b> 2011-12-09 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
IMO if we specified <tt>is_[nothrow_]constructible</tt> in terms of a variable
declaration whose validity requires destructibility, it is clearly a bug
in our specification and a failure to realize the actual original
intent. The specification should have been in terms of placement-new.
<p/>
Daniel:<br/>
At the time of the specification this was intended and the solution is
<em>not</em> done by removing the destruction semantics of <tt>is_constructible</tt>.
<p/>
The design of <tt>is_constructible</tt> was also impacted by the previous
<tt>Constructible</tt> concept that <em>explicitly</em> contained destruction semantics,
because during conceptification of the library it turned out to simplify
the constraints  in the library because you did not need to add
<tt>Destructible</tt> all the time. It often was implied but never spoken out
in C++03.
<p/>
Pure construction semantics was considered as useful as well, so <tt>HasConstructor</tt> 
did also exist and would surely be useful as trait as well.
<p/>
Another example that is often overlooked: This also affects wrapper types like <tt>pair</tt>, 
<tt>tuple</tt>, <tt>array</tt> that contain potentially more than one type:
This is easy to understand if you think of <tt>T1</tt> having a deleted destructor
and <tt>T2</tt> having a constructor that may throw: Obviously the compiler has
potentially need to use the <tt>destructor</tt> of <tt>T1</tt> in the <em>constructor</em>
of <tt>std::pair&lt;T1, T2&gt;</tt> to ensure that the core language requirements
are satisfied (All previous fully constructed sub-objects must be destructed).
<p/>
The core language also honors this fact in 12.8 [class.copy] p11:
</p>
<blockquote><p>
A defaulted copy&#47;move constructor for a class <tt>X</tt> is defined as deleted (8.4.3 [dcl.fct.def.delete]) 
if <tt>X</tt> has:<br/>
[&hellip;]<br/>
&mdash; any direct or virtual base class or non-static data member of a type with a destructor that is deleted
or inaccessible from the defaulted constructor,<br/>
[&hellip;]
</p></blockquote>
<p>
Dave:<br/>
This is about <tt>is_nothrow_constructible</tt> in particular. The fact that it is 
foiled by not having a <tt>noexcept</tt> dtor is a defect.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
<tt>is_nothrow_constructible</tt> is defined in terms of <tt>is_constructible</tt>, which is defined
by looking at a hypothetical variable and asking whether the variable definition is known not to
throw exceptions. The issue claims that this also examines the type's destructor, given the context,
and thus will return <tt>false</tt> if the destructor can potentially throw. At least one
implementation (Howard's) does return <tt>false</tt> if the constructor is <tt>noexcept(true)</tt>
and the destructor is <tt>noexcept(false)</tt>. So that's not a strained interpretation.
The issue is asking for this to be defined in terms of placement <tt>new</tt>, instead of in terms
of a temporary object, to make it clearer that <tt>is_nothrow_constructible</tt> looks at the
<tt>noexcept</tt> status of only the constructor, and not the destructor.
</p>
<p>
Sketch of what the wording would look like:
</p>
<p>
require <tt>is_constructible</tt>, and then also require that a placement <tt>new</tt> operation
does not throw. (Remembering the title of this issue... What does this imply for <tt>swap</tt>?
</p>
<p>
If we accept this resolution, do we need any changes to <tt>swap</tt>?
</p>
<p> STL argues: no, because you are already forbidden from passing anything with a throwing
desturctor to <tt>swap</tt>.
</p>
<p>
Dietmar argues: no, not true. Maybe statically the destructor can conceivably throw for some
values, but maybe there are some values known not to throw. In that case, it's correct to
pass those values to <tt>swap</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2117" href="#2117">2117.</a> <tt>ios_base</tt> manipulators should have <tt>showgrouping&#47;noshowgrouping</tt></h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals], 27.5.3.1.2 [ios::fmtflags], 27.5.6.1 [fmtflags.manip] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Benjamin Kosnik <b>Opened:</b> 2011-12-15 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Iostreams should include a manipulator to toggle grouping on&#47;off for
locales that support grouped digits. This has come up repeatedly and
been deferred. See LWG <a href="lwg-closed.html#826">826</a> for the previous attempt.
<p/>
If one is using a locale that supports grouped digits, then output
will always include the generated grouping characters. However, very
plausible scenarios exist where one might want to output the number,
un-grouped. This is similar to existing manipulators that toggle
on&#47;off the decimal point, numeric base, or positive sign.
<p/>
See some user commentary <a href="http://www.tablix.org/~avian/blog/archives/2008/01/c_streams_suck/">here</a>.
</p>


<p><i>[21012, Kona]</i></p>

<p>
Move to Open.
</p>
<p>
This is a feature request.
</p>
<p>
Walter is slightly uncomfortable with processing feature requests through the issues lists.
</p>
<p>
Alisdair says this is far from the first feature request that has come in from the issues list.
</p>
<p>
STL: The fact that you can turn off grouping on hex output is compelling.
</p>
<p>
Marshall: if we add this flag, we'll need to update tables 87-91 as well.
</p>
<p>
STL: If it has been implemented somewhere, and it works, we'd be glad to add it.
</p>
<p>
Howard: We need to say what the default is.
</p>
<p>
Alisdair sumarizes:
</p>
<p>
(1) We want clear wording that says what the effect is of turning the flag off;
</p>
<p>
(2) what the default values are, and
</p>
<p>
(3) how this fits into tables 87-90. (and 128)
</p>

<p><i>[Issaquah 2014-02-10-12: Move to LEWG]</i></p>

<p>
Since this issue was filed, we have grown a new working group that is better placed to handle feature requests.
</p>
<p>
We will track such issues with an LEWG status until we get feedback from the Library Evolution Working Group.
</p>

<p><i>[Issaquah 2014-02-12: LEWG discussion]</i></p>


<table>
  <caption>Do we think this feature should exist?</caption>
  <tr><td>SF</td><td>F</td><td>N</td><td>A</td><td>SA</td></tr>
  <tr><td>2</td> <td>4</td><td>1</td><td>0</td><td>0</td></tr>
</table>

<p>Think about the ABI break for adding a flag. But this could be
mitigated by putting the data into an iword instead of a flag.</p>

<p>This needs to change Stage 2 in [facet.num.put.virtuals].</p>

<p>Previous resolution, which needs the above corrections:</p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Insert in 22.4.2.2.2 [facet.num.put.virtuals] paragraph 5:</p>

<blockquote><p>
<strong>Stage 1</strong>: The first action of stage 1 is to determine a conversion specifier. The tables that describe
this determination use the following local variables
</p>
<pre>
fmtflags flags = str.flags() ;
fmtflags basefield = (flags &amp; (ios_base::basefield));
fmtflags uppercase = (flags &amp; (ios_base::uppercase));
fmtflags floatfield = (flags &amp; (ios_base::floatfield));
fmtflags showpos = (flags &amp; (ios_base::showpos));
fmtflags showbase = (flags &amp; (ios_base::showbase));
<ins>fmtflags showgrouping = (flags &amp; (ios_base::showgrouping));</ins>
</pre>
</blockquote>
</li>

<li><p>Change header <tt>&lt;ios&gt;</tt> synopsis, 27.5.1 [iostreams.base.overview] as indicated:</p>

<blockquote><pre>
#include &lt;iosfwd&gt;

namespace std {
  [&hellip;]
  <i>// 27.5.6, manipulators:</i>
  [&hellip;]
  ios_base&amp; showpoint     (ios_base&amp; str);
  ios_base&amp; noshowpoint   (ios_base&amp; str);
  <ins>ios_base&amp; showgrouping  (ios_base&amp; str);</ins>
  <ins>ios_base&amp; noshowgrouping(ios_base&amp; str);</ins>
  ios_base&amp; showpos       (ios_base&amp; str);
  ios_base&amp; noshowpos     (ios_base&amp; str);
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change class <tt>ios_base</tt> synopsis, 27.5.3 [ios.base] as indicated:</p>

<blockquote><pre>
namespace std {
  class ios_base {
  public:
  class failure;
    <i>// 27.5.3.1.2 fmtflags</i>
    typedef <i>T1</i> fmtflags;
    [&hellip;]
    static constexpr fmtflags showpoint = <i>unspecified</i> ;
    <ins>static constexpr fmtflags showgrouping = <i>unspecified</i> ;</ins>
    static constexpr fmtflags showpos = <i>unspecified</i> ;
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Add a new entry to Table 122 &mdash; "<tt>fmtflags</tt> effects" as indicated:</p>

<table border="1">
<caption>Table 122 &mdash; <tt>fmtflags</tt> effects</caption>
<tr align="center">
<th>Element</th>
<th>Effect(s) if set</th>
</tr> 

<tr>
<td colspan="2" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

<tr>
<td>
<tt>showpoint</tt>
</td>
<td>
generates a decimal-point character unconditionally in generated floatingpoint output
</td>
</tr>

<tr>
<td>
<ins><tt>showgrouping</tt></ins>
</td>
<td>
<ins>generates grouping characters unconditionally in generated output</ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>

</table>
 
</li>

<li><p>After 27.5.3.1.2 [ios::fmtflags] p12 insert the following:</p>
<blockquote><pre>
<ins>ios_base&amp; showgrouping(ios_base&amp; str);</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Effects</i>: Calls <tt>str.setf(ios_base::showgrouping)</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>str</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>ios_base&amp; noshowgrouping(ios_base&amp; str);</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Effects</i>: Calls <tt>str.unsetf(ios_base::showgrouping)</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>str</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

</ol>

</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2121" href="#2121">2121.</a> <tt>app</tt> for string streams</h3>
<p><b>Section:</b> 27.8.5.1 [stringstream.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2012-01-15 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This issue was raised while discussing issue <a href="lwg-defects.html#1448">1448</a>.
<p/>
Note the following program:
</p>
<blockquote><pre>
string s("s1: 123456789");
ostringstream s1(s, ios_base::out|ios_base::app);
s1 &lt;&lt; "hello";
cout &lt;&lt; s1.str() &lt;&lt; endl;
</pre></blockquote>
<p>
With g++4.x it prints:
</p>
<blockquote><pre>
s1: 123456789hello
</pre></blockquote>
<p>
With VisualC++10 it prints:
</p>
<blockquote><pre>
hello23456789
</pre></blockquote>
<p>
From my intuitive understanding the flag "app" should result in the output of g++4.x.
I also would read that from 27.5.3.1.4 [ios::openmode] claiming:
</p>
<blockquote><p>
<tt>app</tt>&nbsp;&nbsp;&nbsp;seek to end before each write
</p></blockquote>
<p>
However in issue <a href="lwg-defects.html#1448">1448</a> P.J.Plauger comments:
</p>
<blockquote><p>
I think we should say nothing special about <tt>app</tt> at construction time (thus leaving the write pointer at the beginning of the buffer).
Leave implementers wiggle room to ensure subsequent append writes as they see fit, but don't change existing rules for initial seek
position.
</p></blockquote>
<p>
Note that the flag <tt>ate</tt> on both platforms appends "hello" to <tt>s</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2136" href="#2136">2136.</a> Postconditions vs. exceptions</h3>
<p><b>Section:</b> 17.5.1 [structure] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The front matter in clause 17 should clarify that postconditions will not hold if a 
standard library function exits via an exception. Postconditions or guarantees that 
apply when an exception is thrown (beyond the basic guarantee) are described in an 
"Exception safety" section.
</p>

<p><i>[
2012-10 Portland: Move to Open
]</i></p>


<p>
Consensus that we do not clearly say this, and that we probably should.  A likely
location to describe the guarantees of <i>postconditions</i> could well be a new
sub-clause following 17.6.4.11 [res.on.required] which serves the same purpose
for <i>requires</i> clauses.  However, we need such wording before we can make
progress.
</p>

<p>
Also, see <a href="lwg-active.html#2137">2137</a> for a suggestion that we want to see a paper resolving
both issues together.
</p>

<p><i>[2015-05-06 Lenexa: EirkWF to write paper addressing 2136 and 2137]</i></p>

<p>MC: Idea is to replace all such "If no exception" postconditions with "Exception safety" sections.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2137" href="#2137">2137.</a> Misleadingly constrained post-condition in the presence of exceptions</h3>
<p><b>Section:</b> 28.8.3 [re.regex.assign] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex.assign">issues</a> in [re.regex.assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The post-conditions of <tt>basic_regex&lt;&gt;::assign</tt> 28.8.3 [re.regex.assign] p16 say:
</p>
<blockquote><p>
<span style="color:#C80000;font-weight:bold">If no exception is thrown,</span> <tt>flags()</tt> returns 
<tt>f</tt> and <tt>mark_count()</tt> returns the number of marked sub-expressions within the expression.
</p></blockquote>
<p>
The default expectation in the library is that post-conditions only hold, if there is no failure 
(see also <a href="lwg-active.html#2136">2136</a>), therefore the initial condition should be removed to prevent any
misunderstanding.
</p>

<p><i>[
2012-10 Portland: Move to Open
]</i></p>


<p>
A favorable resolution clearly depends on a favorable resolution to <a href="lwg-active.html#2136">2136</a>.
There is also a concern that this is just one example of where we would want to apply
such a wording clean-up, and which is really needed to resolve both this issue and
<a href="lwg-active.html#2136">2136</a> is a paper providing the clause 17 wording that gives the guarantee
for <i>postcondition</i> paragaraphs, and then reviews clauses 18-30 to apply that
guarantee consistently.  We do not want to pick up these issues piecemeal, as we risk
openning many issues in an ongoing process.
</p>

<p><i>[2015-05-06 Lenexa: EirkWF to write paper addressing 2136 and 2137]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<blockquote><pre>
template &lt;class string_traits, class A&gt;
  basic_regex&amp; assign(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
    flag_type f = regex_constants::ECMAScript);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-15- <i>Effects</i>: Assigns the regular expression contained in the string <tt>s</tt>, interpreted according 
the flags specified in <tt>f</tt>. If an exception is thrown, <tt>*this</tt> is unchanged.
<p/>
-16- <i>Postconditions</i>: <del>If no exception is thrown,</del> <tt>flags()</tt> returns <tt>f</tt> and 
<tt>mark_count()</tt> returns the number of marked sub-expressions within the expression.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="2139" href="#2139">2139.</a> What is a <em>user-defined</em> type?</h3>
<p><b>Section:</b> 17.6.4.2.1 [namespace.std], 19.5 [syserr], 20.10.7.1 [allocator.uses.trait], 20.14.10.1 [func.bind.isbind], 20.14.10.2 [func.bind.isplace], 20.14.14 [unord.hash], 20.15.7.6 [meta.trans.other], 22.3.1 [locale], 22.4.1.4 [locale.codecvt], 28.12.1.4 [re.regiter.incr] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Lo&iuml;c Joly <b>Opened:</b> 2012-03-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#namespace.std">issues</a> in [namespace.std].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The expression "user-defined type" is used in several places in the standard, but I'm not sure what 
it means. More specifically, is a type defined in the standard library a user-defined type?
<p/>
From my understanding of English, it is not. From most of the uses of this term in the standard, it 
seem to be considered as user defined. In some places, I'm hesitant, e.g. 17.6.4.2.1 [namespace.std] p1:
</p>
<blockquote><p>
A program may add a template specialization for any standard library template to namespace <tt>std</tt> 
only if the declaration depends on a user-defined type and the specialization meets the standard library 
requirements for the original template and is not explicitly prohibited.
</p></blockquote>
<p>
Does it mean we are allowed to add in the namespace <tt>std</tt> a specialization for 
<tt>std::vector&lt;std::pair&lt;T, U&gt;&gt;</tt>, for instance?
<p/>
Additional remarks from the reflector discussion: The traditional meaning of user-defined types refers
to class types and enum types, but the library actually means here user-defined types that are not
(purely) library-provided. Presumably a new term - like <em>user-provided type</em> - should be introduced
and properly defined.
</p>

<p><i>[
2012-10 Portland: Move to Deferred 
]</i></p>


<p>
The issue is real, in that we never define this term and rely on a "know it when I see it"
intuition.  However, there is a fear that any attempt to pin down a definition is more
likely to introduce bugs than solve them - getting the wording for this precisely correct
is likely far more work than we are able to give it.
</p>

<p>
There is unease at simple closing as NAD, but not real enthusiasm to provide wording either.
Move to Deferred as we are not opposed to some motivated individual coming back with full
wording to review, but do not want to go out of our way to encourage someone to work on this
in preference to other issues.
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2015-03-05 Jonathan suggests wording]</i></p>

<p>
I dislike the suggestion to change to "user-provided" type because I already find the 
difference between user-declared / user-provided confusing for special member functions, 
so I think it would be better to use a completely different term. The core language
uses "user-defined conversion sequence" and "user-defined literal" and
similar terms for things which the library provides, so I think we
should not refer to "user" at all to distinguish entities defined
outside the implementation from things provided by the implementation.
<p/>
I propose "program-defined type" (and "program-defined specialization"), defined below. 
The P/R below demonstrates the scope of the changes required, even if this name isn't adopted. 
I haven't proposed a change for "User-defined facets" in [locale].
</p>

<p><i>[Lenexa 2015-05-06]</i></p>

<p>RS, HT: The core language uses "user-defined" in a specific way, including library things but excluding core language things, let's use a different term.</p>
<p>MC: Agree.</p>
<p>RS: "which" should be "that", x2</p>
<p>RS: Is std::vector&lt;MyType&gt; a "program-defined type"?</p>
<p>MC: I think it should be.</p>
<p>TK: std::vector&lt;int&gt; seems to take the same path.</p>
<p>JW: std::vector&lt;MyType&gt; isn't program-defined, we don't need it to be, anything that depends on that also depends on =MyType.</p>
<p>TK: The type defined by an "explicit template specialization" should be a program-defined type.</p>
<p>RS: An implicit instantiation of a "program-defined partial specialization" should also be a program-defined type.</p>
<p>JY: This definition formatting is horrible and ugly, can we do better?</p>
<p>RS: Checking ISO directives.</p>
<p>RS: Define "program-defined type" and "program-defined specialization" instead, to get rid of the angle brackets.</p>
<p>JW redrafting.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li><p>Add a new sub-clause to 17.3 [definitions]:</p>

<p><ins><b>17.3.? [defns.program.defined]</b></ins></p>
<p>
<ins><b>program-defined</b></ins>
<p/>
<ins>&lt;type&gt; a class type or enumeration type which is not part of the C++
standard library and not defined by the implementation. [<i>Note</i>: Types
defined by the implementation include extensions (1.4 [intro.compliance])
and internal types used by the library. &mdash; <i>end note</i>]</ins>
</p>
<p>
<ins><b>program-defined</b></ins>
<p/>
<ins>&lt;specialization&gt; an explicit template specialization or partial
specialization which is not part of the C++ standard library and not
defined by the implementation.</ins>
</p>
</li>

<li><p>Change 17.6.4.2.1 [namespace.std] paragraph 1+2:</p>

<p>
-1- The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <tt>std</tt> or to a
namespace within namespace <tt>std</tt> unless otherwise specified. A program may add a template specialization
for any standard library template to namespace <tt>std</tt> only if the declaration depends on a 
<del>user</del><ins>program</ins>-defined type and the specialization meets the standard library requirements for the 
original template and is not explicitly prohibited.
<p/>
-2- The behavior of a C++ program is undefined if it declares
<p/>
[&hellip;]
<p/>
A program may explicitly instantiate a template defined in the standard library only if the declaration
depends on the name of a <del>user</del><ins>program</ins>-defined type and the instantiation meets the standard 
library requirements for the original template.
</p>
</li>

<li><p>Change 19.5 [syserr] paragraph 4:</p>

<p>
-4- The <tt>is_error_code_enum</tt> and <tt>is_error_condition_enum</tt> may be specialized for 
<del>user</del><ins>program</ins>-defined types to indicate that such types are eligible for class <tt>error_code</tt> 
and class <tt>error_condition</tt> automatic conversions, respectively.
</p>
</li>

<li><p>Change 20.10.7.1 [allocator.uses.trait] paragraph 1:</p>

<p>
-1- <i>Remarks</i>: automatically detects [&hellip;]. A program may specialize this template to derive from 
<tt>true_type</tt> for a <del>user</del><ins>program</ins>-defined type <tt>T</tt> that does not have a nested 
<tt>allocator_type</tt> but nonetheless can be constructed with an allocator where either: [&hellip;]
</p>
</li>

<li><p>Change 20.14.10.1 [func.bind.isbind] paragraph 2:</p>

<p>
-2- Instantiations of the <tt>is_bind_expression</tt> template [&hellip;]. A program may specialize
this template for a <del>user</del><ins>program</ins>-defined type <tt>T</tt> to have a <tt>BaseCharacteristic</tt> 
of <tt>true_type</tt> to indicate that <tt>T</tt> should be treated as a subexpression in a <tt>bind</tt> call.
</p>
</li>

<li><p>Change 20.14.10.2 [func.bind.isplace] paragraph 2:</p>

<p>
-2- Instantiations of the <tt>is_placeholder</tt> template [&hellip;]. A program may specialize this template for a 
<del>user</del><ins>program</ins>-defined type <tt>T</tt> to have a <tt>BaseCharacteristic</tt> of 
<tt>integral_constant&lt;int, <i>N</i>&gt;</tt> with <tt><i>N</i> &gt; 0</tt> to indicate that <tt>T</tt> should be 
treated as a placeholder type.
</p>
</li>

<li><p>Change 20.14.14 [unord.hash] paragraph 1:</p>

<p>
The unordered associative containers defined in 23.5 use specializations of the class template <tt>hash</tt> [&hellip;], 
the instantiation <tt>hash&lt;Key&gt;</tt> shall:
</p>
<ul>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>[&hellip;]</p></li>
<li><p>satisfy the requirement that the expression <tt>h(k)</tt>, where <tt>h</tt> is an object of type 
<tt>hash&lt;Key&gt;</tt> and <tt>k</tt> is an object of type <tt>Key</tt>, shall not throw an exception unless 
<tt>hash&lt;Key&gt;</tt> is a <del>user</del><ins>program</ins>-defined specialization that depends on at least one 
<del>user</del><ins>program</ins>-defined type.</p></li>
</ul>
</li>

<li><p>Change 20.15.7.5 [meta.trans.ptr] Table 57 (<tt>common_type</tt> row):</p>

<blockquote>
<table border="1">
<caption>Table 57 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class... T&gt;<br/>
struct common_type;</tt>
</td>

<td align="center">
&nbsp;
</td>

<td>
The member typedef <tt>type</tt> shall be<br/>
defined or omitted as specified below.<br/>
[&hellip;]. A program may<br/>
specialize this trait if at least one<br/>
template parameter in the<br/>
specialization is a <del>user</del><ins>program</ins>-defined type.<br/>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 22.4.1.4 [locale.codecvt] paragraph 3:</p>

<p>
-3- The specializations required in Table 81 (22.3.1.1.1) [&hellip;]. Other encodings can be converted 
by specializing on a <del>user</del><ins>program</ins>-defined <tt>stateT</tt> type.[&hellip;]
</p>
</li>

<li><p>Change 28.12.1.4 [re.regiter.incr] paragraph 8:</p>

<p>
-8- [<i>Note</i>: This means that a compiler may call an implementation-specific search function, in which case
a <del>user</del><ins>program</ins>-defined specialization of <tt>regex_search</tt> will not be called. &mdash; 
<i>end note</i>]
</p>
</li>
</ol>





<hr>
<h3><a name="2146" href="#2146">2146.</a> Are reference types <tt>Copy</tt>&#47;<tt>Move-Constructible</tt>&#47;<tt>Assignable</tt> or <tt>Destructible</tt>?</h3>
<p><b>Section:</b> 17.6.3.1 [utility.arg.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-03-23 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 17.6.3.1 [utility.arg.requirements] p1
</p>
<blockquote><p>
The template definitions in the C++ standard library refer to various named requirements whose details are set out in 
tables 17-24. In these tables, <tt>T</tt> is an object or reference type to be supplied by a C++ program instantiating 
a template; <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are values of type (possibly <tt>const</tt>) <tt>T</tt>; <tt>s</tt> 
and <tt>t</tt> are modifiable lvalues of type <tt>T</tt>; <tt>u</tt> denotes an identifier; <tt>rv</tt> is an rvalue of 
type <tt>T</tt>; and <tt>v</tt> is an lvalue of type (possibly <tt>const</tt>) <tt>T</tt> or an rvalue of type <tt>const T</tt>.
</p></blockquote>
<p>
Is it really intended that <tt>T</tt> may be a reference type? If so, what should <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, 
<tt>s</tt>, <tt>t</tt>, <tt>u</tt>, <tt>rv</tt>, and <tt>v</tt> mean? For example, are "<tt>int &amp;</tt>" and 
"<tt>int &amp;&amp;</tt>" <tt>MoveConstructible</tt>?
<p/>
As far as I understand, we can explicitly specify template arguments for <tt>std::swap</tt> and <tt>std::for_each</tt>. 
Can we use reference types there?
</p>
<ol>
<li>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;utility&gt;

int main()
{
  int x = 1;
  int y = 2;
  std::swap&lt;<span style="color:#C80000;font-weight:bold">int &amp;&amp;</span>&gt;(x, y); // <em>undefined?</em>
  std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;
}
</pre></blockquote>
</li>
<li>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;

struct F
{
  void operator()(int n)
  {
    std::cout &lt;&lt; n &lt;&lt; std::endl;
    ++count;
  }
  int count;
} f;

int main()
{
  int arr[] = { 1, 2, 3 };
  auto&amp;&amp; result = std::for_each&lt;int *, <span style="color:#C80000;font-weight:bold">F &amp;&amp;</span>&gt;( // <em>undefined?</em>
    std::begin(arr),
    std::end(arr),
    std::move(f));
  std::cout &lt;&lt; "count: " &lt;&lt; result.count &lt;&lt; std::endl;
}
</pre></blockquote>
</li>
</ol>
<p>
Are these forms of usage well-defined?
<p/>
Let's also consider the following constructor of <tt>std::thread</tt>:
</p>
<blockquote><pre>
template &lt;class F, class ...Args&gt;
explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre><blockquote>
<p>
<i>Requires</i>: <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall satisfy the <tt>MoveConstructible</tt> requirements.
</p>
</blockquote></blockquote>
<p>
When the first argument of this constructor is an lvalue (e.g. a name of a global function), template argument for <tt>F</tt> 
is deduced to be lvalue reference type. What should "<tt>MoveConstructible</tt>" mean with regard to an lvalue reference 
type? Maybe the wording should say that <tt>std::decay&lt;F&gt;::type</tt> and each <tt>std::decay&lt;Ti&gt;::type</tt> (where 
<tt>Ti</tt> is an arbitrary item in <tt>Args</tt>) shall satisfy the <tt>MoveConstructible</tt> requirements?
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>Moved to Open.</p>
<p>The questions raised by the issue are real, and should have a clear answer.</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: std::thread needs to be fixed, and anything behaving like it needs to be fixed, rather than reference types. std::bind gets this right. We need to survey this. GR: That doesn't sound small to me. STL: Seach for CopyConstructible etc. It may be a long change, but not a hard one.</p>
<p>MC: It seems that we don't have a PR. Does anyone have one? Is anyone interested in doing a survey?</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>Casey volunteers to make a survey</p>

<p><i>[2016-06, Oulu]</i></p>

<p>
During an independent survey performed by Daniel as part of the analysis of LWG <a href="lwg-defects.html#2716">2716</a>,
some overlap was found between these two issues. Daniel suggested to take responsibility for surveying
LWG <a href="lwg-active.html#2146">2146</a> and opined that the P/R of LWG <a href="lwg-defects.html#2716">2716</a> should restrict to forwarding 
references, where the deduction to lvalue references can happen without providing an explicit template
argument just by providing an lvalue function argument.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2151" href="#2151">2151.</a> <tt>basic_string&lt;&gt;::swap</tt> semantics ignore allocators</h3>
<p><b>Section:</b> 21.3.1.1 [string.require] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.require">active issues</a> in [string.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++11, <tt>basic_string</tt> is not described as a "container", and is not governed by the allocator-aware 
container semantics described in sub-clause 23.2 [container.requirements]; as a result, and 
requirements or contracts for the <tt>basic_string</tt> interface must be documented in Clause 
21 [strings].
<p/>
Sub-clause 21.3.1.6.8 [string::swap] defines the <tt>swap</tt> member function with no requirements, and
with guarantees to execute in constant time without throwing. Fulfilling such a contract is not reasonable 
in the presence of unequal non-propagating allocators.
<p/>
In contrast, 23.2.1 [container.requirements.general] p7 declares the behavior of member <tt>swap</tt> 
for containers with unequal non-propagating allocators to be undefined.
<p/>
Resolution proposal:
<p/>
Additional language from Clause 23 [containers] should probably be copied to Clause 
21 [strings]. I will refrain from an exactly recommendation, however, as I am raising further
issues related to the language in Clause 23 [containers].
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair has offered to provide wording.
</p>
<p>
Telecon notes that 23.2.1 [container.requirements.general]p13 says that <tt>string</tt> is an
allocator-aware container.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2152" href="#2152">2152.</a> Instances of standard container types are not swappable</h3>
<p><b>Section:</b> 17.6.3.2 [swappable.requirements], 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#swappable.requirements">issues</a> in [swappable.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sub-clause 17.6.3.2 [swappable.requirements] defines two notions of swappability: a binary version defining
when two objects are <em>swappable with</em> one another, and a unary notion defining whether an object is 
<em>swappable</em> (without qualification), with the latter definition requiring that the object satisfy the 
former with respect to all values of the same type.
<p/>
Let <tt>T</tt> be a container type based on a non-propagating allocator whose instances do not necessarily 
compare equal. Then sub-clause 23.2.1 [container.requirements.general] p7 implies that no object <tt>t</tt> 
of type <tt>T</tt> is swappable (by the unary definition).
<p/>
Throughout the standard it is the unary definition of "swappable" that is listed as a requirement (with the 
exceptions of 20.2.2 [utility.swap] p4, 20.4.2 [pairs.pair] p31, 20.5.2.3 [tuple.swap] p2, 
25.4.3 [alg.swap] p2, and 25.4.3 [alg.swap] p6, which use the binary definition). This renders 
many of the mutating sequence algorithms of sub-clause 25.4 [alg.modifying.operations], for example, 
inapplicable to sequences of standard container types, even where every element of the sequence is swappable 
with every other.
<p/>
Note that this concern extends beyond standard containers to all future allocator-based types.
<p/>
Resolution proposal:
<p/>
I see two distinct straightforward solutions:
</p>
<ol style="list-style-type:lower-roman">
<li>Modify the requirements of algorithms from sub-clause 25.4 [alg.modifying.operations], and all other
places that reference the unary "swappable" definition, to instead use the binary "swappable with" definition 
(over a domain appropriate to the context). The unary definition of "swappable" could then be removed from the 
standard.
</li>
<li>Modify sub-clause 23.2.1 [container.requirements.general] such that objects of standard container types 
are "swappable" by the unary definition.
</li>
</ol>
<p>
I favor the latter solution, for reasons detailed in the following issue.
</p>

<p><i>[
2012-10 Portland: Move to Open 
]</i></p>


<p>
The issue is broader than containers with stateful allocotors, although they are the most obvious
example contained within the standard itself.  The basic problem is that once you have a stateful
allocator, that does not <tt>propagate_on_swap</tt>, then whether two objects of this type can be
swapped with well defined behavior is a run-time property (the allocators compare equal) rather
than a simple compile-time property that can be deduced from the type.  Strictly speaking, any
type where the nature of swap is a runtime property does not meet the <tt>swappable</tt>
requirements of C++11, although typical sequences of such types are going to have elements that
are all <tt>swappable with</tt> any other element in the sequence (using our other term of art
for specifying requirements) as the common case is a container of elements who all share the
same allocator.
</p>

<p>
The heart of the problem is that the <tt>swappable</tt> requirments demand that any two objects
of the same type be <tt>swappable with</tt> each other, so if any two such objects would not
be <tt>swappable with</tt> each other, then the whole type is never <tt>swappable</tt>.  Many
algorithms in clause 25 are specified in terms of <tt>swappable</tt> which is essentially an
overspecification as all they actually need is that any element in the sequence is <tt>swappable
with</tt> any other element in the sequence.
</p>

<p>
At this point Howard joins the discussion and points out that the intent of introducing the
two swap-related terms was to support <tt>vector&lt;bool&gt;::reference</tt> types, and we are
reading something into the wording that was never intended.  Consuses is that regardless of
the intent, that is what the words today say.
</p>

<p>
There is some support to see a paper reviewing the whole of clause 25 for this issue, and
other select clauses as may be necessary.
</p>

<p>
There was some consideration to introducing a note into the front of clause 25 to indicate
<tt>swappable</tt> requirements in the clause should be interpreted to allow such awkward
types, but ultimately no real enthusiasm for introducing a <tt>swappable for clause 25</tt>
requirement term, especially if it confusingly had the same name as a term used with a
subtly different meaning through the rest of the standard.
</p>

<p>
There was no enthusiasm for the alternate resolution of requiring containers with unequal
allocators that do not propagate provide a well-defined swap behavior, as it is not
believed to be possible without giving <tt>swap</tt> linear complexity for such values,
and even then would require adding the constraint that the container element types are
CopyConstructible.
</p>

<p>
Final conclusion: move to open pending a paper from a party with a strong interest in
stateful allocators.
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Alisdair says that his paper <a href="http://wg21.link/P0178">P0178</a> addresses this.
</p>

<p><i>[2016-06 Oulu]</i></p>

<p>
<a href="http://wg21.link/P0178">P0178</a> reviewed, and sent back to LEWG for confirmation.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Apply <a href="http://wg21.link/P0178">P0178</a>.
</p>





<hr>
<h3><a name="2153" href="#2153">2153.</a> Narrowing of the non-member <tt>swap</tt> contract</h3>
<p><b>Section:</b> 20.2.2 [utility.swap], 17.6.3.2 [swappable.requirements], 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Robert Shearer <b>Opened:</b> 2012-04-13 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.swap">issues</a> in [utility.swap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Sub-clause 20.2.2 [utility.swap] defines a non-member 'swap' function with defined behavior for
all <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> types. It does not guarantee
constant-time complexity or <tt>noexcept</tt> in general, however this definition does
render all objects of <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> type swappable
(by the unary definition of sub-clause 17.6.3.2 [swappable.requirements]) in the absence of 
specializations or overloads.
<p/>
The overload of the non-member <tt>swap</tt> function defined in Table 96, however,
defines semantics incompatible with the generic non-member <tt>swap</tt> function,
since it is defined to call a member <tt>swap</tt> function whose semantics are
undefined for some values of <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> types.
<p/>
The obvious (perhaps naive) interpretation of sub-clause 17.6.3.2 [swappable.requirements] is as a guide to
the "right" semantics to provide for a non-member <tt>swap</tt> function (called in
the context defined by 17.6.3.2 [swappable.requirements] p3) in order to provide interoperable
user-defined types for generic programming. The standard container types don't follow these guidelines.
<p/>
More generally, the design in the standard represents a classic example of "contract narrowing". It 
is entirely reasonable for the contract of a particular <tt>swap</tt> overload to provide <em>more</em> 
guarantees, such as constant-time execution and <tt>noexcept</tt>, than are provided by the <tt>swap</tt> 
that is provided for any <tt>MoveConstructible</tt> and <tt>MoveAssignable</tt> types, but it is <em>not</em> 
reasonable for such an overload to fail to live up to the guarantees it provides for general types when 
it is applied to more specific types. Such an overload or specialization in generic programming is akin 
to an override of an inherited virtual function in OO programming: violating a superclass contract in a
subclass may be legal from the point of view of the language, but it is poor design and can easily lead 
to errors. While we cannot prevent user code from providing overloads that violate the more general 
<tt>swap</tt> contract, we can avoid doing so within the library itself.
<p/>
My proposed resolution is to draw a sharp distinction between member <tt>swap</tt> functions, which provide 
optimal performance but idiosyncratic contracts, and non-member <tt>swap</tt> functions, which should always 
fulfill at least the contract of 20.2.2 [utility.swap] and thus render objects swappable. The member 
<tt>swap</tt> for containers with non-propagating allocators, for example, would offer constant-time
guarantees and <tt>noexcept</tt> but would only offer defined behavior for values with allocators that compare 
equal; non-member <tt>swap</tt> would test allocator equality and then dispatch to either member <tt>swap</tt> or 
<tt>std::swap</tt> depending on the result, providing defined behavior for all values (and rendering the type
"swappable"), but offering neither the constant-time nor the <tt>noexcept</tt> guarantees.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This topic deserves more attention than can be given in the telocon, and there is no proposed resolution.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This topic deserves more attention than can be given in the telocon, and there is no proposed resolution.
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Alisdair says that his paper <a href="http://wg21.link/P0178">P0178</a> addresses this.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Send to LEWG</p>

<p><i>[2016-06 Oulu]</i></p>

<p>
<a href="http://wg21.link/P0178">P0178</a> reviewed, and sent back to LEWG for confirmation.
</p>


<p><b>Proposed resolution:</b></p>
Apply <a href="http://wg21.link/P0178">P0178</a>.





<hr>
<h3><a name="2154" href="#2154">2154.</a> What exactly does compile-time complexity imply?</h3>
<p><b>Section:</b> 26.6.1.3 [rand.req.urng] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> John Salmon <b>Opened:</b> 2012-04-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.req.urng">issues</a> in [rand.req.urng].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The expressions <tt>G::min()</tt> and <tt>G::max()</tt> in Table 116 in 26.6.1.3 [rand.req.urng] are specified 
as having "compile-time" complexity.
<p/>
It is not clear what, exactly, this requirement implies.  If a URNG has a method:
</p>
<blockquote><pre>
static int min();
</pre></blockquote>
<p>
then is the method required to have a <tt>constexpr</tt> qualifier?  I believe the standard would benefit from 
clarification of this point.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2155" href="#2155">2155.</a> Macro <tt>__bool_true_false_are_defined</tt> should be removed</h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2012-04-30 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.runtime">active issues</a> in [support.runtime].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Since C99, the C standard describes a macro named  <tt>__bool_true_false_are_defined</tt>.
<p/>
In the process of harmonizing C++11 with C99, this name became part of the C++ standard.
<p/>
I propose that all mention of this name should be removed from the C and C++ standards.
<p/>
Here's the problem: The name was originally proposed as a transition tool, so that the headers for a 
project could contain lines like the following.
</p>
<blockquote><pre>
#if !defined(__bool_true_false_are_defined)
#define bool int /* or whatever */
#define true 1
#define false 0
#endif
</pre></blockquote>
<p>
Then when the project was compiled by a "new" compiler that implemented <tt>bool</tt> as defined by the 
evolving C++98 or C99 standards, those lines would be skipped; but when compiled by an "old" compiler that 
didn't yet provide <tt>bool</tt>, <tt>true</tt>, and <tt>false</tt>, then the <tt>#define</tt>'s would provide a
simulation that worked for most purposes.
<p/>
It turns out that there is an unfortunate ambiguity in the name.  One interpretation is as shown above, but 
a different reading says "bool, true, and false are #define'd", i.e. that the meaning of the macro is to
assert that these names are macros (not built-in) ... which is true in C, but not in C++.
<p/>
In C++11, the name appears in parentheses followed by a stray period, so
some editorial change is needed in any event:
<p/>
18.10 [support.runtime] para 1:
</p>
<blockquote><p>
Headers <tt>&lt;csetjmp&gt;</tt> (nonlocal jumps), <tt>&lt;csignal&gt;</tt> (signal handling), <tt>&lt;cstdalign&gt;</tt> 
(alignment), <tt>&lt;cstdarg&gt;</tt> (variable arguments), <tt>&lt;cstdbool&gt;</tt> (<tt>__bool_true_false_are_defined</tt>). 
<tt>&lt;cstdlib&gt;</tt> (runtime environment <tt>getenv()</tt>, <tt>system()</tt>), and <tt>&lt;ctime&gt;</tt> 
(system clock <tt>clock()</tt>, <tt>time()</tt>) provide further compatibility with C code.
</p></blockquote>
<p>
However, para 2 says
</p>
<blockquote><p>
"The contents of these headers are the same as the Standard C library headers <tt>&lt;setjmp.h&gt;</tt>, 
<tt>&lt;signal.h&gt;</tt>, <tt>&lt;stdalign.h&gt;</tt>, <tt>&lt;stdarg.h&gt;</tt>, <tt>&lt;stdbool.h&gt;</tt>, 
<tt>&lt;stdlib.h&gt;</tt>, and <tt>&lt;time.h&gt;</tt>, respectively, with the following 
changes:",
</p></blockquote>
<p>
and para 8 says 
</p>
<blockquote><p>
"The header <tt>&lt;cstdbool&gt;</tt> and the header <tt>&lt;stdbool.h&gt;</tt> shall 
not define macros named <tt>bool</tt>, <tt>true</tt>, or <tt>false</tt>."
</p></blockquote>
<p>
Thus para 8 doesn't exempt the C++ implementation from the arguably clear requirement of the C standard, to 
provide a macro named <tt>__bool_true_false_are_defined</tt> defined to be 1.
<p/>
Real implementations of the C++ library differ, so the user cannot count upon any consistency; furthermore, the 
usefulness of the transition tool has faded long ago.
<p/>
That's why my suggestion is that both C and C++ standards should eliminate any mention of 
<tt>__bool_true_false_are_defined</tt>.  In that case, the name belongs to implementers to provide, or not, as 
they choose.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
While not strictly necessary, the clean-up look good.
</p>
<p>
We would like to hear from our C liaison before moving on this issue though.
</p>

<p><i>[2015-05 Lenexa]</i></p>

<p>
LWG agrees. Jonathan provides wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li>
<p>Edit the footnote on 17.6.1.2 [headers] p7:</p>
<blockquote>
<p>
176) In particular, including <ins>any of</ins> the standard header<ins>s <tt>&lt;stdbool.h&gt;</tt>, <tt>&lt;cstdbool&gt;</tt>,</ins> <tt>&lt;iso646.h&gt;</tt> or <tt>&lt;ciso646&gt;</tt> has no effect.
</p>
</blockquote>
</li>

<li>
<p>Edit 18.10 [support.runtime] p1 as indicated (and remove the index entry for <tt>__bool_true_false_are_defined</tt>):</p>

<blockquote>
<p>
-1- Headers <tt>&lt;csetjmp&gt;</tt> (nonlocal jumps), <tt>&lt;csignal&gt;</tt> (signal handling), <tt>&lt;cstdalign&gt;</tt> (alignment), <tt>&lt;cstdarg&gt;</tt> (variable arguments), <tt>&lt;cstdbool&gt;</tt><ins>,</ins><del> (<tt>__bool_true_false_are_defined</tt>).</del> <tt>&lt;cstdlib&gt;</tt> (runtime environment <tt>getenv()</tt>, <tt>system()</tt>), and <tt>&lt;ctime&gt;</tt> (system clock <tt>clock()</tt>, <tt>time()</tt>) provide further compatibility with C code.
</p>
</blockquote>
</li>

<li>
<p>Remove Table 38 &mdash; Header <tt>&lt;cstdbool&gt;</tt> synopsis [tab:support.hdr.cstdbool] from 18.10 [support.runtime] </p>
<blockquote>
<table border="1">
<caption> Table 38 &mdash; Header <tt>&lt;cstdbool&gt;</tt> synopsis </caption>
<tr><td><b>Type</b></td><td><b>Name(s)</b></td></tr>
<tr><td><b>Macro:</b></td><td><tt>__bool_true_false_are_defined</tt></td></tr>
</table>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2157" href="#2157">2157.</a> How does <tt>std::array&lt;T,0&gt;</tt> initialization work when <tt>T</tt> is not default-constructible?</h3>
<p><b>Section:</b> 23.3.7.8 [array.zero] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daryle Walker <b>Opened:</b> 2012-05-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#array.zero">issues</a> in [array.zero].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Objects of <tt>std::array&lt;T,N&gt;</tt> are supposed to be initialized with aggregate initialization (when 
not the destination of a copy or move). This clearly works when <tt>N</tt> is positive. What happens when <tt>N</tt> 
is zero?  To continue using an (inner) set of braces for initialization, a <tt>std::array&lt;T,0&gt;</tt> implementation 
must have an array member of at least one element, and let default initialization take care of those secret elements.  
This cannot work when <tt>T</tt> has a set of constructors and the default constructor is deleted from that set.
Solution: Add a new paragraph in 23.3.7.8 [array.zero]:
</p>
<blockquote><p>
The unspecified internal structure of array for this case shall allow initializations like:
</p>
<blockquote><pre>
array&lt;T, 0&gt; a = { };
</pre></blockquote>
<p>
and said initializations must be valid even when <tt>T</tt> is not default-constructible.
</p></blockquote>

<p><i>[2012, Portland: Move to Open]</i></p>

<p>
Some discussion to understand the issue, which is that implementations currently have freedom to implement
an empty <tt>array</tt> by holding a dummy element, and so might not support value initialization, which is
surprising when trying to construct an empty container.  However, this is not mandated, it is an unspecified
implementation detail.
</p>

<p>
Jeffrey points out that the implication of 23.3.7.1 [array.overview] is that this initialization syntax
must be supported by empty <tt>array</tt> objects already.  This is a surprising inference that was not
obvious to the room, but consensus is that the reading is accurate, so the proposed resolution is not necessary,
although the increased clarity may be useful.
</p>

<p>
Further observation is that the same clause effectively implies that <tt>T</tt> must always be DefaultConstructible,
regardless of <tt>N</tt> for the same reasons - as an <i>initializer-list</i> may not supply enough values, and the
remaining elements must all be value initialized.
</p>

<p>
Concern that we are dancing angels on the head of pin, and that relying on such subtle implications in wording is
not helpful. We need a clarification of the text in this area, and await wording.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
DK: What was the outcome of Portland? AM: Initially we thought we already had the intended behaviour. 
We concluded that <tt>T</tt> must always be <tt>DefaultConstructible</tt>, but I'm not sure why. GR: It's p2 in 
<tt>std::array</tt>, "up to <tt>N</tt>". AM: That wording already implies that "<tt>{}</tt>" has to work when <tt>N</tt> 
is zero. But the wording of p2 needs to be fixed to make clear that it does <em>not</em> imply that <tt>T</tt> must be 
<tt>DefaultConstructible</tt>.
<p/>
Conclusion: Update wording, revisit later. 
</p>


<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>MC: How important is this? Can you not just use default construction for empty arrays? </p>
<p>TK: It needs to degenerate properly from a pack. STL agrees.</p> 
<p>JW: Yes, this is important, and we have to make it work.</p>
<p>MC: I hate the words "initialization like". </p>
<p>JW: I'll reword this.</p>
<p>WEB: Can I ask that once JW has reworded this we move it to Review rather than Open? </p>
<p>MC: We'll try to review it in a telecon and hopefully get it to tentatively ready.</p>
<p>STL: Double braces must also work: <tt>array&lt;T, 0&gt; a = {{}};</tt>.</p>
<p>Jonathan to reword.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<p>Add the following new paragraph between the current 23.3.7.8 [array.zero] p1 and p2:</p>

<blockquote><p>
-1- <tt>array</tt> shall provide support for the special case <tt>N == 0</tt>.
<p/>
<ins>-?- The unspecified internal structure of <tt>array</tt> for this case shall allow initializations like:</ins>
</p>
<blockquote><pre>
<ins>array&lt;T, 0&gt; a = { };</ins>
</pre></blockquote>
<p>
<ins>and said initializations must be valid even when <tt>T</tt> is not default-constructible.</ins>
<p/>
-2- In the case that <tt>N == 0</tt>, <tt>begin() == end() ==</tt> unique value. The return value of 
<tt>data()</tt> is unspecified.
<p/>
-3- The effect of calling <tt>front()</tt> or <tt>back()</tt> for a zero-sized array is undefined.
<p/>
-4- Member function <tt>swap()</tt> shall have a <em>noexcept-specification</em> which is equivalent to 
<tt>noexcept(true)</tt>.
</p></blockquote>





<hr>
<h3><a name="2158" href="#2158">2158.</a> Conditional copy&#47;move in <tt>std::vector</tt></h3>
<p><b>Section:</b> 23.3.11.3 [vector.capacity] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-05-08 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
There are various operations on <tt>std::vector</tt> that can cause elements of the vector to be 
moved from one location to another. A move operation can use either rvalue or const lvalue as 
argument; the choice depends on the value of <tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;
is_copy_constructible&lt;T&gt;::value</tt>, where <tt>T</tt> is the element type. Thus, some operations 
on <tt>std::vector</tt> (e.g. 'resize' with single parameter, 'reserve', 'emplace_back') should have 
conditional requirements. For example, let's consider the requirement for 'reserve' in N3376 &ndash; 
23.3.11.3 [vector.capacity]&#47;2:
</p>
<blockquote><p>
<i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
</p></blockquote>
<p>
This requirement is not sufficient if an implementation is free to select copy constructor when 
<tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value</tt> 
evaluates to true. Unfortunately, <tt>is_copy_constructible</tt> cannot reliably determine whether 
<tt>T</tt> is really copy-constructible. A class may contain public non-deleted copy constructor whose 
definition does not exist or cannot be instantiated successfully (e.g., 
<tt>std::vector&lt;std::unique_ptr&lt;int&gt;&gt;</tt> has copy constructor, but this type is not 
copy-constructible). Thus, the actual requirements should be:
</p>
<ul>
<li><p>
if <tt>!is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; is_copy_constructible&lt;T&gt;::value</tt> 
then <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>*this</tt>;
</p></li>
<li><p>
otherwise <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
</p></li>
</ul>
<p>
Maybe it would be useful to introduce a new name for such conditional requirement (in addition to 
"<tt>CopyInsertable</tt>" and "<tt>MoveInsertable</tt>").
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>
The problem does not appear to be as severe as described. The <tt>MoveInsertable</tt>
requirements are consistently correct, but an issue may arise on the
exception-safety guarantees when we check for
<tt>is_copy_constructible_v&lt;T&gt;</tt>.  The problem, as described, is
typically for templates that appear to have a copy constructor, but one that
fails to compile once instantiated, and so gives a misleading result for the
trait.
</p>
<p>
In general, users should not provide such types, and the standard would not
serve users well by trying to address support for such types.  However, the
standard should not be providing such types either, such as
<tt>vector&lt;unique_ptr&lt;T&gt;&gt;</tt>.  A possible resolution would be
to tighten the constraints in Table 80 &mdash; Container Requirements, so that if
the Requirements for the copy constructor/assingment operator of a container
are not satisfied, that operation shall be deleted.
</p>
<p>
A futher problem highlighted by this approach is that there are no constraints on
the copy-assignment operator, so that <tt>vector&lt;unique_ptr&lt;T&gt;&gt;</tt>
should be <tt>CopyAssignable</tt>! However, we can lift the equivalent constraints from
the Allocator-aware container requirements.
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Fri PM: Move to OPen</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<p>
<table border="1">
<caption> 23.2.1 [container.requirements.general] Table 80 &mdash; Container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><tt>X(a)</tt></td>
  <td></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into
    <tt>X</tt> (see below)<del>.</del><ins>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>a == X(a)</tt>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td><tt>X u(a)</tt><br/><tt>X u = a;</tt></td>
  <td></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into
    <tt>X</tt> (see below)<del>.</del><ins>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>u == a</tt>.
  </td>
  <td>linear</td>
</tr>
<tr>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
  <td>...</td>
</tr>
<tr>
  <td><tt>r = a</tt></td>
  <td><tt>X&amp;</tt></td>
  <td></td>
  <td>
    <ins><i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>
    and <tt>CopyAssignable</tt>, otherwise this expression shall be ill-formed.</ins><br/>
    post: <tt>r == a</tt>.</td>
  <td>linear</td>
</tr>
</table>
</p>

<p>
<table border="1">
<caption> 23.2.1 [container.requirements.general] Table 83 &mdash; Allocator-aware container requirements </caption>
<tr>
  <td><b>Expression</b></td>
  <td><b>Return type</b></td>
  <td><b>Operational semantics</b></td>
  <td><b>Assertion/note/pre-/post-condition</b></td>
  <td><b>Complexity</b></td>
</tr>
<tr>
  <td><tt>a = t</tt></td>
  <td><tt>X&amp;</tt></td>
  <td></td>
  <td>
    <i>Requires:</i> <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt> and
    <tt>CopyAssignable</tt><del>.</del><ins>, otherwise this  expression shall
    be ill-formed</ins><br/>
    post: <tt>r == a</tt>.</td>
  <td>linear</td>
</tr>
</table>
</p>






<hr>
<h3><a name="2164" href="#2164">2164.</a> What are the semantics of <tt>vector.emplace(vector.begin(), vector.back())</tt>?</h3>
<p><b>Section:</b> 23.3.11.5 [vector.modifiers], 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2012-07-07 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.modifiers">active issues</a> in [vector.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Nikolay Ivchenkov recently brought the following example on the
<a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/dhy23mDFXj4/discussion">std-discussion</a> 
newsgroup, asking whether the following program well-defined:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
  std::vector&lt;int&gt; v;
  v.reserve(4);
  v = { 1, 2, 3 };
  v.emplace(v.begin(), v.back());
  for (int x : v)
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
Nikolay Ivchenkov:
<p/>
I think that an implementation of <tt>vector</tt>'s 'emplace' should initialize an intermediate object with 
<tt>v.back()</tt> before any shifts take place, then perform all necessary shifts and finally replace the 
value pointed to by <tt>v.begin()</tt> with the value of the intermediate object. So, I would expect the 
following output:
</p>
<blockquote><pre>
3
1
2
3
</pre></blockquote>
<p>
GNU C++ 4.7.1 and GNU C++ 4.8.0 produce other results:
</p>
<blockquote><pre>
2
1
2
3
</pre></blockquote>
<p>
Howard Hinnant:
<p/>
I believe Nikolay is correct that vector should initialize an intermediate object with <tt>v.back()</tt> 
before any shifts take place. As Nikolay pointed out in another email, this appears to be the only way to 
satisfy the strong exception guarantee when an exception is not thrown by <tt>T</tt>'s copy constructor, 
move constructor, copy assignment operator, or move assignment operator as specified by 
23.3.11.5 [vector.modifiers]/p1. I.e. if the emplace construction throws, the vector must remain unaltered.
<p/>
That leads to an implementation that tolerates objects bound to the function parameter pack of the <tt>emplace</tt> 
member function may be elements or sub-objects of elements of the container.
<p/>
My position is that the standard is correct as written, but needs a clarification in this area. Self-referencing 
<tt>emplace</tt> should be legal and give the result Nikolay expects. The proposed resolution of LWG <a href="lwg-active.html#760">760</a> 
is not correct.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
LWG agrees with the analysis including the assessment of LWG <a href="lwg-active.html#760">760</a> and would appreciate a concrete wording proposal.
</p>

<p><i>[2015-04-07 dyp comments]</i></p>

<p>
The Standard currently does not require that creation of such
intermediate objects is legal. 23.2.3 [sequence.reqmts] Table 100
&mdash; "Sequence container requirements" currently specifies:
</p>

<blockquote>
<table border="1">
<caption>Table 100 &mdash; Sequence container requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.emplace(p, args);</tt>
</td>
<td>
<tt>iterator</tt>
</td>
<td>
<i>Requires</i>: <tt>T</tt> is <tt>EmplaceConstructible</tt> into
<tt>X</tt> from <tt>args</tt>. For <tt>vector</tt> and <tt>deque</tt>,
<tt>T</tt> is also <tt>MoveInsertable</tt> into <tt>X</tt> and
<tt>MoveAssignable</tt>. [&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

<p>
The <tt>EmplaceConstructible</tt> concept is defined via
<tt>allocator_traits&lt;A&gt;::construct</tt> in 23.2.1 [container.requirements.general] p15.5 That's surprising to me
since the related concepts use the suffix <tt>Insertable</tt> if they
refer to the allocator. An additional requirement such as
<tt>std::is_constructible&lt;T, Args...&gt;</tt> is necessary to allow
creation of intermediate objects.
</p>

<p>
The creation of intermediate objects also affects other functions, such
as <tt>vector.insert</tt>. Since aliasing the vector is only allowed for
the single-element forms of <tt>insert</tt> and <tt>emplace</tt> (see
<a href="lwg-closed.html#526">526</a>), the range-forms are not affected. Similarly,
aliasing is not allowed for the rvalue-reference overload. See also LWG
<a href="lwg-defects.html#2266">2266</a>.
</p>

<p>
There might be a problem with a requirement of
<tt>std::is_constructible&lt;T, Args...&gt;</tt> related to the issues
described in LWG <a href="lwg-active.html#2461">2461</a>. For example, a scoped allocator
adapter passes additional arguments to the constructor of the value
type. This is currently not done in recent implementations of libstdc++
and libc++ when creating the intermediate objects, they simply create
the intermediate object by perfectly forwarding the arguments. If such
an intermediate object is then moved to its final destination in the
vector, a change of the allocator instance might be required &mdash;
potentially leading to an expensive copy. One can also imagine worse
problems, such as run-time errors (allocators not comparing equal at
run-time) or compile-time errors (if the value type cannot be created
without the additional arguments). I have not looked in detail into this
issue, but I'd be reluctant adding a requirement such as
<tt>std::is_constructible&lt;T, Args...&gt;</tt> without further
investigation.
</p>

<p>
It should be noted that the creation of intermediate objects currently
is inconsistent in libstdc++ vs libc++. For example, libstdc++ creates
an intermediate object for <tt>vector.insert</tt>, but not
<tt>vector.emplace</tt>, whereas libc++ does the exact opposite in this
respect.
</p>

<p>
A live demo of the inconsistent creation of intermediate objects can be
found <a href="http://coliru.stacked-crooked.com/a/449253d3d329ef4c">here</a>.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>HH: If it were easy, it'd have wording. Over the decades I have flipped 180 degrees on this. My current position is that it should work even if the element is in the same container.</p>
<p>TK: What's the implentation status? JW: Broken in GCC. STL: Broken in MSVS. Users complain about this every year.</p>
<p>MC: 526 says push_back has to work.</p>
<p>HH: I think you have to make a copy of the element anyway for reasons of exception safety. [Discussion of exception guarantees] </p>
<p>STL: vector has strong exception guarantees. Could we not just provide the Basic guarantee here. </p>
<p>HH: It would terrify me to relax that guarantee. It'd be an ugly, imperceptible runtime error. </p>
<p>HH: I agree if we had a clean slate that strong exception safety is costing us here, and we shouldn't provide it if it costs us.</p>
<p>STL: I have a mail here, "how can vector provide the strong guarantee when inserting in the middle". </p>
<p>HH: The crucial point is that you only get the strong guarantee if the exception is thrown by something other than the copy and move operations that are used to make the hole. </p>
<p>STL: I think we need to clean up the wording. But it does mandate currently that the self-emplacement must work, because nothings says that you can't do it. TK clarifies that a) self-emplacement must work, and b) you get the strong guarantee only if the operations for making the hole don't throw, otherwise basic. HH agrees. STL wants this to be clear in the Standard.</p>
<p>STL: Should it work for deque, too? HH: Yes.</p>
<p>HH: I will attempt wording for this. </p>
<p>TK: Maybe mail this to the reflector, and maybe someone has a good idea? </p>
<p>JW: I will definitely not come up with anything better, but I can critique wording.</p>
<p>Moved to Open; Howard to provide wording, with feedback from Jonathan.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2166" href="#2166">2166.</a> Heap property underspecified?</h3>
<p><b>Section:</b> 25.5.6 [alg.heap.operations] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2012-07-09 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.heap.operations">issues</a> in [alg.heap.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Another similar issue to the <tt>operator&lt;</tt> vs greater in <tt>nth_element</tt> but not as direct occurs 
in 25.5.6 [alg.heap.operations]:
</p>
<blockquote><p>
-1- A <em>heap</em> is a particular organization of elements in a range between two random access iterators 
<tt>[a,b)</tt>. Its two key properties are:
</p>
<ol>
<li>There is no element greater than <tt>*a</tt> in the range and
</li>
<li><tt>*a</tt> may be removed by <tt>pop_heap()</tt>, or a new element added by <tt>push_heap()</tt>, in 
O(log(<tt>N</tt>)) time.
</li>
</ol>
</blockquote>
<p>
As noted by Richard Smith, it seems that the first bullet should read:
</p>
<blockquote><p>
<tt>*a</tt> is not less than any element in the range
</p></blockquote>
<p>
Even better the heap condition could be stated here directly, instead of leaving it unspecified, i.e.,
</p>
<blockquote><p>
Each element at <tt>(a+2*i+1)</tt> and <tt>(a+2*i+2)</tt> is less than the element at <tt>(a+i)</tt>, 
if those elements exist, for <tt>i&gt;=0</tt>.
</p></blockquote>
<p>
But may be that was may be intentional to allow other heap organizations?
<p/>
See also follow-up discussion of c++std-lib-32780.
<p/>

</p>
<p><i>[2016-08 Chicago]</i></p>

<p>Walter provided wording</p>
<p>Tues PM: Alisdair &amp; Billy(MS) to improve the wording.</p>

<p><i>[2016-08-02 Chicago LWG]</i></p>

<p>
Walter provides initial Proposed Resolution. Alisdair objects to perceived
complexity of the mathematical phrasing.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p><i>[Note to editor: As a drive-by editorial adjustment, please replace the current
enumerated list format by the numbered bullet items shown below.]</i></p>


<p>Change [alg.heap.operations]:</p>

<p>1 A heap is a particular organization of elements in a range between two
random access iterators [a, b)<del>. Its two key properties are</del><ins>such
that</ins>:</p>

<p>(1.1) -- <del>There is no element greater than <tt>*a</tt> in the range and</del><br/>
         <ins>For all <tt>i >= 0</tt>,<br/>
         <tt>comp(a[i], a[L])</tt> is false whenever L = 2*i+1 &lt; b-a,<br/>
         and<br/>
         <tt>comp(a[i], a[R])</tt> is false whenever R = 2*i+2 &lt; b-a.</ins><br/>
</p>
<p>(1.2) -- <tt>*a</tt> may be removed by <tt>pop_heap()</tt>, or a new element added by <tt>push_heap()</tt>, in O(log(N)) time.</p>
</blockquote>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>Walter and Billy O'Neal provide revised Proposed Resolution, superseding yesterday's.</p>
<p>Thurs PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 25.5.6 [alg.heap.operations] as indicated:</p>

<blockquote class="note">
<p>
Note to project editor: As a drive-by editorial adjustment, please replace the
current enumerated list format by numbered bullet items.
</p>
</blockquote>

<blockquote>
<p>
-1- A <em>heap</em> is a particular organization of elements in a range between two random access iterators 
<code>[a, b)</code><del>. Its two key properties are</del><ins>such that</ins>:
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <del>There is no element greater than <tt>*a</tt> in the range and</del>
<ins>With <math xmlns="http://www.w3.org/1998/Math/MathML">
<mi>N</mi><mo>=</mo><mi mathvariant="monospace" mathsize="small">b</mi><mo>-
</mo><mi mathvariant="monospace" mathsize="small">a</mi></math>, 
for all <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math>,
<math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>N</mi></math>,
<code>comp(a[</code><math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo rspace="0.3em" lspace="0em" stretchy="true" fence="true" form="prefix">&lfloor;</mo>
  <mrow>
	<mfrac linethickness="1">
		<mrow>
			<mi>i</mi>
			<mo>-</mo>
			<mn>1</mn>
		</mrow>
		<mn>2</mn>
	</mfrac>
  </mrow>
  <mo rspace="0em" lspace="0.3em" stretchy="true" fence="true" form="postfix">&rfloor;</mo>
</math><code>], a[<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math>])</code> is <tt>false</tt>.</ins>
</p>
<blockquote class="note">
<p>
[Note to the project editor: In LaTeX the above insertion should be expressed as follows:
<p/>
With $N = <code>b</code>-<code>a</code>$, for all $i$, $0 &lt; i &lt; N$,
<code>comp(a[$\left \lfloor{\frac{i-1}{2}}\right \rfloor$], a[$i$])</code> is <code>false</code>.]
</p>
</blockquote>
</li>
<li><p>(1.2) &mdash; <tt>*a</tt> may be removed by <tt>pop_heap()</tt>, or a new element added by <tt>push_heap()</tt>, in 
&#x1d4aa;(log(<i>N</i>)) time.
</p>
</li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2173" href="#2173">2173.</a> The meaning of <code>operator +</code> in the description of the algorithms</h3>
<p><b>Section:</b> 25 [algorithms] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2012-08-01 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#algorithms">active issues</a> in [algorithms].</p>
<p><b>View all other</b> <a href="lwg-index.html#algorithms">issues</a> in [algorithms].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to 25.1 [algorithms.general]/12,
</p>
<blockquote><p>
In the description of the algorithms operators <tt>+</tt> and <tt>-</tt> are used for some of the iterator categories 
for which they do not have to be defined. In these cases the semantics of <tt>a+n</tt> is the same as that of
</p>
<blockquote><pre>
X tmp = a;
advance(tmp, n);
return tmp;
</pre></blockquote>
</blockquote>
<p>
There are several places where such operator <tt>+</tt> is applied to an output iterator &mdash; for example, see the 
description of <tt>std::copy</tt>:
</p>
<blockquote><pre>
template&lt;class InputIterator, class OutputIterator&gt;
OutputIterator copy(InputIterator first, InputIterator last,
                    OutputIterator result);
</pre>
<blockquote><p>
-1- <i>Effects</i>: Copies elements in the range <tt>[first,last)</tt> into the range <tt>[result,result + (last -
first))</tt> starting from <tt>first</tt> and proceeding to <tt>last</tt>. For each non-negative integer 
<tt>n &lt; (last - first)</tt>, performs <tt>*(result + n) = *(first + n)</tt>.
</p></blockquote></blockquote>
<p>
<tt>std::advance</tt> is not supposed to be applicable to output iterators, so we need a different method of description.
<p/>
See also message <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32908">c++std-lib-32908</a>.
</p>

<p><i>[2014-06-07 Daniel comments and provides wording]</i></p>

<p>
The specification for output iterators is somewhat tricky, because here a sequence of increments is required to
be combined with intervening <em>assignments</em> to the dereferenced iterator. I tried to respect this
fact by using a conceptual assignment operation as part of the specification.
<p/>
Another problem in the provided as-if-code is the question which requirements are imposed on <tt>n</tt>. Unfortunately,
the corresponding function <tt>advance</tt> is completely underspecified in this regard, so I couldn't borrow wording
from it. We cannot even assume here that <tt>n</tt> is the difference type of the iterator, because for output iterators there is
no requirements for this associated type to be defined. The presented wording attempts to minimize assumptions, but still
can be considered as controversial. 
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 25.1 [algorithms.general] around p12 as indicated:</p>

<blockquote>
<p>
-12- In the description of the algorithms operators <tt>+</tt> and <tt>-</tt> are used for some of the iterator categories for which
they do not have to be defined. In these cases the semantics of <tt>a+n</tt> is the same as that of
</p>
<blockquote>
<pre>
X tmp = a;
advance(tmp, n);
return tmp;
</pre>
</blockquote>
<p>
<ins>when <tt>X</tt> meets the input iterator requirements (24.2.3 [input.iterators]), otherwise it is the same as that of</ins>
</p>
<blockquote>
<pre>
<ins>X tmp = a;
for (auto i = n; i; ++tmp, (void) --i) 
  *tmp = <i>Expr</i>(i); 
return tmp;</ins>
</pre>
</blockquote>
<p>
<ins>where <tt><i>Expr</i>(i)</tt> denotes the <tt>(n-i)</tt><sup>th</sup> expression that is assigned to for the corresponding algorithm;</ins> and that of <tt>b-a</tt> is the same as of
</p>
<blockquote>
<pre>
return distance(a, b);
</pre>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2178" href="#2178">2178.</a> <tt>Allocator</tt> requirement changes not mentioned Annex C</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements], C.5 [diff.library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2012-08-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Given that a number of things were removed from the allocator requirements (<tt>reference</tt>, <tt>const_reference</tt>, 
<tt>address()</tt> in 17.6.3.5 [allocator.requirements]), it seems that these incompatible changes should be 
mentioned in Annex C.5 [diff.library], more specifically in [diff.cpp03].
</p>

<p><i>[
2012-10 Portland: Move to Open 
]</i></p>


<p>
It was clearly pointed out by Bill during the C++11 process that our change to allocator requirements
potentially broke 3rd party user containers written to expect C++03 allocators, or rather, an
allocator written to the minimal requirements of C++11 might not be guaranteed to work with a container
written to the previous rules.  This was a trade-off in making allocaters easier to write by use of
the <tt>allocator_traits</tt> framework.
</p>

<p>
This probably does merit a write-up in Annex C, and we look forward to seeing wording.  Until then,
the best we can do is move the issue to Open.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2179" href="#2179">2179.</a> <tt>enable_shared_from_this</tt> and construction from raw pointers</h3>
<p><b>Section:</b> 20.11.2.5 [util.smartptr.enab], 20.11.2.2.1 [util.smartptr.shared.const] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-08-16 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in [util.smartptr.enab].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in [util.smartptr.enab].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
On reflector message <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32927">c++std-lib-32927</a>, 
Matt Austern asked whether the following example should be well-defined or not
</p>
<blockquote><pre>
struct X : public enable_shared_from_this&lt;X&gt; { };
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
pointing out that 20.11.2.2.1 [util.smartptr.shared.const] does not seem to allow it, since
<tt>xp1</tt> and <tt>xp2</tt> aren't allowed to share ownership, because each of them is required to have 
<tt>use_count() == 1</tt>. Despite this wording it might be reasonable (and technical possible)
to implement that request.
<p/>
On the other hand, there is the non-normative note in 20.11.2.5 [util.smartptr.enab] p11 (already part of TR1):
</p>
<blockquote><p>
The <tt>shared_ptr</tt> constructors that <span style="color:#C80000;font-weight:bold">create unique pointers</span> 
can detect the presence of an <tt>enable_shared_from_this</tt> base and assign the newly created <tt>shared_ptr</tt> 
to its <tt>__weak_this member</tt>.
</p></blockquote>
<p>
Now according to the specification in 20.11.2.2.1 [util.smartptr.shared.const] p3-7:
</p>
<blockquote><pre>
template&lt;class Y&gt; explicit shared_ptr(Y* p);
</pre></blockquote>
<p>
the notion of <em>creating unique pointers</em> can be read to be included by this note, because the post-condition
of this constructor is <tt>unique() == true</tt>. Evidence for this interpretation seems to be weak, though.
<p/>
Howard Hinnant presented the counter argument, that actually the following is an "anti-idiom" and it seems questionable 
to teach it to be well-defined in any case:
</p>
<blockquote><pre>
auto xraw = new X;
shared_ptr&lt;X&gt; xp1(xraw);
shared_ptr&lt;X&gt; xp2(xraw);
</pre></blockquote>
<p>
He also pointed out that the current post-conditions of the affected <tt>shared_ptr</tt> constructor
would need to be reworded.
<p/>
It needs to be decided, which direction to follow. If this idiom seems too much broken to be supported,
the note could be improved. If it should be supported, the constructors in
20.11.2.2.1 [util.smartptr.shared.const] need a careful analysis to ensure that post-conditions
are correct.
<p/>
Several library implementations currently do not support this example, instead they typically
cause a crash. Matt points out that there are currently no explicit requirements imposed on
<tt>shared_ptr</tt> objects to prevent them from owning the same underlying object without sharing the 
ownership. It might be useful to add such a requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
More discussion is needed to pick a direction to guide a proposed resolution.
</p>

<p><i>[2013-05-09 Jonathan comments]</i></p>

<p>
The note says the newly created <tt>shared_ptr</tt> is assigned to the <tt>weak_ptr</tt> member. It doesn't 
say before doing that the <tt>shared_ptr</tt> should check if the <tt>weak_ptr</tt> is non-empty and possibly 
share ownership with some other pre-existing <tt>shared_ptr</tt>.
</p>

<p><i>[2015-08-26 Daniel comments]</i></p>

<p>
LWG issue <a href="lwg-active.html#2529">2529</a> is independent but related to this issue.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper p0033r1 at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2183" href="#2183">2183.</a> Muddled allocator requirements for <tt>match_results</tt> constructors</h3>
<p><b>Section:</b> 28.10.1 [re.results.const], 28.10.6 [re.results.all] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-08-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in [re.results.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in [re.results.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
28.10.1 [re.results.const] p1 says:
</p>
<blockquote><p>
In all <tt>match_results</tt> constructors, a copy of the <tt>Allocator</tt> argument shall be used for any memory 
allocation performed by the constructor or member functions during the lifetime of the object.
</p></blockquote>
<p>
There are three constructors:
</p>
<blockquote><pre>
match_results(const Allocator&amp; = Allocator());
match_results(const match_results&amp; m);
match_results(match_results&amp;&amp; m) noexcept;
</pre></blockquote>
<p>
The second and third constructors do no have an <tt>Allocator</tt> argument, so despite the "all <tt>match_results</tt> 
constructors", it is not possible to use "the <tt>Allocator</tt> argument" for the second and third constructors.
<p/>
The requirements for those two constructors also does not give any guidance. The second constructor has no language 
about allocators, and the third states that the stored <tt>Allocator</tt> value is move constructed from 
<tt>m.get_allocator()</tt>, but doesn't require using that allocator to allocate memory.
<p/>
The same basic problem recurs in 28.10.6 [re.results.all], which gives the required return value for 
<tt>get_allocator()</tt>:
</p>
<blockquote><p>
<i>Returns</i>: A copy of the <tt>Allocator</tt> that was passed to the object's constructor or, if that allocator 
has been replaced, a copy of the most recent replacement.
</p></blockquote>
<p>
Again, the second and third constructors do not take an <tt>Allocator</tt>, so there is nothing that meets this 
requirement when those constructors are used.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2184" href="#2184">2184.</a> Muddled allocator requirements for <tt>match_results</tt> assignments</h3>
<p><b>Section:</b> 28.10.1 [re.results.const], 28.10.6 [re.results.all] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-08-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in [re.results.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in [re.results.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The effects of the two assignment operators are specified in Table 141. Table 141 makes no mention of allocators, 
so, presumably, they don't touch the target object's allocator. That's okay, but it leaves the question: 
<tt>match_results::get_allocator()</tt> is supposed to return "A copy of the Allocator that was passed to the 
object's constructor or, if that allocator has been replaced, a copy of the most recent replacement"; if assignment 
doesn't replace the allocator, how can the allocator be replaced?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2189" href="#2189">2189.</a> Throwing <tt>swap</tt> breaks unordered containers' state</h3>
<p><b>Section:</b> 23.2.5.1 [unord.req.except] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-09-23 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The hash functor and key-comparison functor of unordered containers are allowed to throw on <tt>swap</tt>.
</p>
<p>
23.2.5.1 [unord.req.except]p3 "For unordered associative containers, no <tt>swap</tt> function throws
an exception unless that exception is thrown by the swap of the container's Hash or Pred object (if any)."
</p>
<p>
In such a case we must offer the basic exception safety guarantee, where both objects are left in valid
but unspecified states, and no resources are leaked.  This yields a corrupt, un-usable container if the
first <tt>swap</tt> succeeds, but the second fails by throwing, as the functors form a matched pair.
</p>
<p>
So our basic scenario is first, swap the allocators if the allocators propagate on swap, according to
<tt>allocator_traits</tt>.  Next we swap the pointers to our internal hash table data structures, so that
they match the allocators that allocated them.  (Typically, this operation cannot throw).  Now our containers
are back in a safely destructible state if an exception follows.
</p>
<p>
Next, let's say we swap the hash functor, and that throws.  We have a corrupt data structure, in that the
buckets are not correctly indexed by the correct functors, lookups will give unpredicatable results etc.
We can safely restore a usable state by forcibly clearing each container - which does not leak resources
and leaves us with two (empty but) usable containers.
</p>
<p>
Now let us assume that the hasher swap succeeds.  Next we swap the equality comparator functor, and this
too could throw. The important point to bear in mind is that these two functors form an important pairing
- two objects that compare equal by the equality functor must also hash to the same value.  If we swap
one without the other, we most likely leave the container in an unusable state, even if we clear out all
elements.
</p>
<p>
1. A colleague pointed out that the solution for this is to dynamically allocate the two functors, and then
we need only swap pointers, which is not a throwing operation.  And if we don't want to allocate on default
construction (a common QoI request), we might consider moving to a dynamically allocated functors whenever
<tt>swap</tt> is called, or on first insertion.  Of course, allocating memory in <tt>swap</tt> is a whole
new can of worms, but this does not really sound like the design we had intended.
</p>

<p>
2. The simplest option is to say that we do not support hasher or equality functors that throw on ADL
<tt>swap</tt>.  Note that the requirement is simply to not throw, rather than to be explicitly
marked as <tt>noexcept</tt>.  Throwing functors are allowed, so long as we never use values that
would actually manifest a throw when used in an unordered container.
</p>

<p>
Pablo went on to give me several more options, to be sure we have a full set to consider:
</p>
<p>
3. Disallow one or the other functor from throwing.  In that case, the 
possibly-throwing functor must be swapped first, then the other functor, 
the allocator, and the data pointer(s) afterwards (in any order -- there 
was a TC that allocator assignment and swap may not throw if the 
corresponding propagation trait is true.). Of course, the question 
becomes: which functor is allowed to throw and which one is not?
</p>
<p>
4. Require that any successful functor <tt>swap</tt> be reliably reversible.  
This is very inventive.  I know of no other place in the standard where 
such a requirement is stated, though I have occasionally wanted such a 
guarantee.
</p>
<p>
5. Allow a failed swap to leave the containers in a state where future 
insertions may fail for reasons other than is currently allowed.  
Specifically, if the hash and equality functors are out of sync, all 
insertions will fail.  Presumably some "incompletely swapped" exception 
would be thrown.  This is "slightly" inventive, although people have been 
discussing "radioactive" states for a while.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2191" href="#2191">2191.</a> Incorrect specification of <tt>match_results(match_results&amp;&amp;)</tt></h3>
<p><b>Section:</b> 28.10.1 [re.results.const] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-10-02 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results.const">active issues</a> in [re.results.const].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.const">issues</a> in [re.results.const].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
28.10.1 [re.results.const]/3: "Move-constructs an object of class <tt>match_results</tt> satisfying the same 
postconditions as Table 141."
</p>
<p>
Table 141 lists various member functions and says that their results should be the results of the corresponding member 
function calls on <tt>m</tt>. But <tt>m</tt> has been moved from, so the actual requirement ought to be based on the 
value that <tt>m</tt> had <em>before</em> the move construction, not on <tt>m</tt> itself.
</p>
<p>
In addition to that, the requirements for the copy constructor should refer to Table 141.
<p/>
<u>Ganesh</u>:
<p/>
Also, the requirements for move-assignment should refer to Table 141. Further it seems as if in Table 141 all phrases of
"for all integers <tt>n &lt; m.size()</tt>" should be replaced by "for all <em>unsigned</em> integers 
<tt>n &lt; m.size()</tt>".
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2195" href="#2195">2195.</a> Missing constructors for <tt>match_results</tt></h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-10-06 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results">active issues</a> in [re.results].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The requirement expressed in 28.10 [re.results] p2
</p>
<blockquote><p>
The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specified in 23.2.3 [sequence.reqmts], except that only operations defined for 
const-qualified sequence containers are supported.
</p></blockquote>
<p>
can be read to require the existence of the described constructors from as well, but they do not exist in the
synopsis. 
<p/>
The missing sequence constructors are: 
</p>
<blockquote><pre>
match_results(initializer_list&lt;value_type&gt;);
match_results(size_type, const value_type&amp;);
template&lt;class InputIterator&gt; match_results(InputIterator, InputIterator);
</pre></blockquote>
<p>
The missing allocator-aware container constructors are:
</p>
<blockquote><pre>
match_results(const match_results&amp;, const Allocator&amp;);
match_results(match_results&amp;&amp;, const Allocator&amp;);
</pre></blockquote>
<p>
It should be clarified, whether (a) constructors are an exception of above mentioned operations or (b) whether
at least some of them (like those accepting a <tt>match_results</tt> value and an allocator) should be added.
<p/>
As visible in several places of the standard (including the core language), constructors seem usually to be considered 
as "operations" and they certainly can be invoked for const-qualified objects.
<p/>
The below given proposed resolution applies only the minimum necessary fix, i.e. it excludes constructors from
above requirement. 
</p>

<p><i>[2013-04-20, Bristol]</i></p>

<p>Check current implementations to see what they do and, possibly, write a paper.</p>

<p><i>[2013-09 Chicago]</i></p>

<p>Ask Daniel to update the proposed wording to include the allocator copy and move constructors.</p>

<p><i>[2014-01-18 Daniel changes proposed resolution]</i></p>

<p><strong>Previous resolution from Daniel [SUPERSEDED]:</strong></p>

<blockquote class="note">
<ol>
<li><p>Change 28.10 [re.results] p2 as indicated:</p>
<blockquote><p>
The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specified in 23.2.3 [sequence.reqmts], except that only operations defined for 
const-qualified sequence containers <ins>that are not constructors</ins> are supported.
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-05-06 Lenexa]</i></p>

<p>MC passes important knowledge to EF.</p>
<p>VV, RP: Looks good.</p>
<p>TK: Second form should be conditionally noexcept</p>
<p>JY: Sequence constructors are not here, but mentioned in the issue writeup. Why?</p>
<p>TK: That would have been fixed by the superseded wording.</p>
<p>JW: How does this interact with Mike Spertus' allocator-aware regexes? [...] Perhaps it doesn't.</p>
<p>JW: Can't create match_results, want both old and new resolution.</p>
<p>JY: It's problematic that users can't create these, but not this issue.</p>
<p>VV: Why conditional noexcept?</p>
<p>MC: Allocator move might throw.</p>
<p>JW: Update superseded wording to "only non-constructor operations that are"?</p>
<p>MC: Only keep superseded, but append "and the means of constructing match_results are limited to [...]"?</p>
<p>JY: Bullet 4 paragraph 2 needs to address the allocator constructor.</p>
<p>Assigned to JW for drafting.</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: I want Mike Spertus to be aware of this issue.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 28.10 [re.results] p4, class template <tt>match_results</tt> synopsis, as indicated:</p>
<blockquote><pre>
[&hellip;]
// 28.10.1, construct/copy/destroy:
explicit match_results(const Allocator&amp; a = Allocator());
match_results(const match_results&amp; m);
<ins>match_results(const match_results&amp; m, const Allocator&amp; a);</ins>
match_results(match_results&amp;&amp; m) noexcept;
<ins>match_results(match_results&amp;&amp; m, const Allocator&amp; a) noexcept;</ins>
[&hellip;]
</pre></blockquote>
</li>

<li><p>Change 28.10.1 [re.results.const]  as indicated: [<i>Drafting note:</i> Paragraph 6 as currently written,
makes not much sense, because the <tt>noexcept</tt> does not allow any exception to propagate. Further-on, the allocator requirements
do not allow for throwing move constructors. Deleting it seems to be near to editorial &mdash; <i>end drafting note</i>]</p>
<blockquote>

<pre>
match_results(const match_results&amp; m);
<ins>match_results(const match_results&amp; m, const Allocator&amp; a);</ins>
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Constructs an object of class <tt>match_results</tt>, as a copy of <tt>m</tt>.
</p>
</blockquote>

<pre>
match_results(match_results&amp;&amp; m) noexcept;
<ins>match_results(match_results&amp;&amp; m, const Allocator&amp; a) noexcept;</ins>
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> Move-constructs an object of class <tt>match_results</tt> from <tt>m</tt> satisfying the same postconditions
as Table 142. <del>Additionally</del><ins>For the first form</ins>, the stored <tt>Allocator</tt> value is move constructed 
from <tt>m.get_allocator()</tt>.
<p/>
<del>-6- <i>Throws:</i> Nothing if the allocator's move constructor throws nothing.</del>
</p>
</blockquote>

</blockquote>
</li>
</ol>






<hr>
<h3><a name="2198" href="#2198">2198.</a> <tt>max_load_factor(z)</tt> makes no strong guarantees, but bans useful behavior</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-10-09 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The user cannot specify a <tt>max_load_factor</tt> for their unordered container
at construction, it must be supplied after the event, when the container is
potentially not empty.  The contract for this method is deliberately vague, not
guaranteeing to use the value supplied by the user, and any value actually used
will be used as a ceiling that the container will <i>attempt</i> to respect.
</p>
<p>
The only guarantee we have is that, if user requests a <tt>max_load_factor</tt>
that is less than the current <tt>load_factor</tt>, then the operation will take
constant time, thus outlawing an implementation that chooses to rehash and so
preserve as a class invariant that <tt>load_factor &lt; max_load_factor</tt>.
</p>
<p>
Reasonable options conforming to the standard include ignoring the user's request
if the requested value is too low, or deferring the rehash to the next <tt>insert</tt>
operation and allowing the container to have a strange state (wrt <tt>max_load_factor</tt>)
until then - and there is still the question of rehashing if the next <tt>insert</tt>
is for a duplicate key in a unique container.
</p>
<p>
Given the deliberate vagueness of the current wording, to support a range of reasonable
(but not <i>perfect</i>) behaviors, it is not clear why the equally reasonable rehash
to restore the constraint should be outlawed.  It is not thought that this is a performance
critical operation, where users will be repeatedly setting low load factors on populated
containers, in a tight or (less unlikely) an instant response scenario.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to provide wording.
</p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2199" href="#2199">2199.</a> unordered containers are required to have an initial max load factor of 1.0</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-10-09 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The default constructor, allocator-aware constructor, and range-based constructors
for the unordered containers do not offer a means to control the initial
<tt>max_load_factor</tt>, so the standard mandates the value 1.0.  This seems overly
restrictive, as there is plenty of research suggesting a value between 0.5 and 1.0
is more often optimal for unique-key containers, and perhaps a slightly higher
value might be appropriate for multi-containers.
</p>
<p>
Rather than guess at the appropriate <tt>max_load_factor</tt>, it seems reasonable
that the standard should allow vendors to pick a value at their discretion, with
perhaps a note of advice.  It is less clear whether the default value should be
implementation-defined or unspecified, given the ease of a user determining this
by querying this attribute immediately after construction.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to provide wording.
</p>
<p>
Marshall: It seems to me that what you really want is to be able to pass a max load factor in the
constructor, but that's a different issue.
</p>
<p>
Alisdair agrees in principle, but concerned with adding yet more constructors to these classes.
</p>



<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2201" href="#2201">2201.</a> Missing macro entries from C standard library</h3>
<p><b>Section:</b> C.5 [diff.library] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kevin McCarty <b>Opened:</b> 2012-02-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#diff.library">issues</a> in [diff.library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It seems that in C.5 [diff.library], Table 150 the following macros from 18.3.3 [c.limits], Table 31 
are missing:
</p>
<blockquote><pre>
LLONG_MIN 
LLONG_MAX
ULLONG_MAX
</pre></blockquote>
<p>
In addition in C.5 [diff.library], Table 150 the following macros from 18.3.3 [c.limits], Table 32 
are missing:
</p>
<blockquote><pre>
DECIMAL_DIG 
FLT_EVAL_METHOD
</pre></blockquote>
<p>
Furtheron it seems that in C.5 [diff.library], Table 149/150 further macros are missing as well, e.g. 
<tt>HUGE_VALF</tt>, <tt>INFINITY</tt>, etc.
</p>

<p><i>[2014-02 Issaquah:]</i></p>

<p>
This is an issue, all of C has not been updated for C99, C99 functions are missing, whole section needs to be overhauled.
<p/>
The issue needs to be updated for functions and other missing items and when that happens the issue title is wrong and
needs to be adapted.
</p>

<p><i>[2016-08 Chicago: Zhihao Yuan comments]</i></p>

<p>
We suggest to either:
</p>
<ol>
<li><p>
Having a paper to rewrite C.5 C standard library by striking
the content shared by C and C++ and leave only the
differences;
</p></li>
<li><p>
Having a paper, or a complete proposed wording to fix
the missing names added between C89 and C99.
</p></li>
</ol>
<p>
For 1), some C11 headers being excluded from C++ (such as
<tt>thread.h</tt>) need to be added to this section.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2202" href="#2202">2202.</a> Missing allocator support by <tt>async</tt></h3>
<p><b>Section:</b> 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Detlef Vollmann <b>Opened:</b> 2012-10-19 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>Discussion:</b></p>

<p>
<tt>promise</tt>, <tt>packaged_task</tt>, and <tt>async</tt> are the only
places where a shared state is actually supposed to be allocated. Accordingly,
<tt>promise</tt> and <tt>packaged_task</tt> are "allocator-aware". But
function template <tt>async</tt> provides no way to provide an allocator.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Matt: deprecate async 
<p/>
Nico: read my paper 
<p/>
Alisdair: defer issues to wait for polymorphic allocators 
<p/>
Alisdair: defer, active topic of research Deferred 
</p>

<p><i>[2014-02-20 Re-open Deferred issues as Priority 4]</i></p>


<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
We want whatever status approximates: "will not fix; we're working on a replacement facility and don't want to add features to a broken one"
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2206" href="#2206">2206.</a> Inaccuracy in <tt>initializer_list</tt> constructor requirements</h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts], 23.2.4 [associative.reqmts], 23.2.5 [unord.req], 26.6.1.2 [rand.req.seedseq] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-21 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In 23.2.3 [sequence.reqmts] p3, we have "<tt>il</tt> designates an object of type
<tt>initializer_list&lt;value_type&gt;</tt>", and then several functions that take
'<tt>il</tt>' as an argument. However, an expression like <tt>{1, 2, 'a'}</tt> is <em>not</em>
an object of type <tt>initializer_list&lt;int&gt;</tt> unless it's used to initialize
an explicitly-typed variable of that type. I believe we want:
</p>
<blockquote><pre>
std::vector&lt;int&gt; v;
v = {1, 2, 'a'};
</pre></blockquote>
<p>
to compile portably, so we should say something different when defining '<tt>il</tt>'. The 
same phrasing happens in 23.2.4 [associative.reqmts], 23.2.5 [unord.req], and 
26.6.1.2 [rand.req.seedseq].
<p/>
This may just be an editorial issue because the actual class synopses declare the functions 
to take <tt>initializer_list&lt;exact_type&gt;</tt>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
This is definitely not NAD
</p>
<p>
Should copy the suggested wording as the proposed resolution.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2208" href="#2208">2208.</a> <tt>std::reverse_iterator</tt> should be a literal type</h3>
<p><b>Section:</b> 24.5.1 [reverse.iterators] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-10-30 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterators">issues</a> in [reverse.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>

<p>
<tt>std::reverse_iterator::reverse_iterator(Iterator)</tt> should be constexpr
so that other constexpr functions can return <tt>reverse_iterator</tt>s. Of the
other methods, the other constructors, <tt>base()</tt>, <tt>operator+</tt>, <tt>operator-</tt>,
<tt>operator[]</tt>, and the non-member operators can probably also be
<tt>constexpr</tt>.
<p/>
<tt>operator*</tt> cannot be constexpr because it involves an assignment to a
member variable. Discussion starting with c++std-lib-33282 indicated
that it would be useful to make reverse_iterator a literal type
despite this restriction on its use at compile time.
</p>



<p><b>Proposed resolution:</b></p>
This issue was Resolved by paper
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0031r0">P0031R0</a>
adopted at Jacksonville, 2016.





<hr>
<h3><a name="2214" href="#2214">2214.</a> Clarify <tt>basic_ios::init</tt> call restrictions</h3>
<p><b>Section:</b> 27.5.5.2 [basic.ios.cons] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Andrey Semashev <b>Opened:</b> 2012-11-09 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.ios.cons">issues</a> in [basic.ios.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is an ambiguity in how <tt>std::basic_ios::init</tt> method (27.5.5.2 [basic.ios.cons]) 
can be used in the derived class. The Standard only specify the state of the <tt>basic_ios</tt> 
object after the call completes. However, in <tt>basic_ios</tt> default constructor description 
(27.5.5.2 [basic.ios.cons]) there is this sentence:
</p>
<blockquote><p>
<i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (27.5.3.7 [ios.base.cons]) 
leaving its member objects uninitialized. The object shall be initialized by calling <tt>basic_ios::init</tt> 
before its first use or before it is destroyed, whichever comes first; otherwise the behavior is undefined.
</p></blockquote>
<p>
This restriction hints that <tt>basic_ios::init</tt> should be called exactly
once before the object can be used or destroyed, because <tt>basic_ios::init</tt> 
may not know whether it was called before or not (i.e. whether its members are actually 
uninitialized or are initialized by the previous call to <tt>basic_ios::init</tt>). There 
is no such restriction in the <tt>basic_ios::init</tt> preconditions so it is not clear whether it is
allowed to call <tt>basic_ios::init</tt> multiple times or not.
<p/>
This problem has already affected publicly available implementations.
For example, Microsoft Visual C++ STL introduces a memory leak if
<tt>basic_ios::init</tt> is called multiple times, while GCC 4.7 and STLPort
reinitialize the <tt>basic_ios</tt> object correctly without memory leak or any
other undesired effects. There was a discussion of this issue on Boost
<a href="http://article.gmane.org/gmane.comp.lib.boost.devel/235659">developers mailing list</a>, 
and there is a <a href="https://sourceforge.net/apps/trac/boost-log/ticket/2#comment:4">test case 
that reproduces the problem</a>. The test case is actually a bug report for my Boost.Log library, 
which attempts to cache <tt>basic_ostream</tt>-derived objects internally to avoid expensive construction 
and destruction. My stream objects allowed resetting the stream buffer pointers the stream
is attached to, without requiring to destroy and construct the stream.
<p/>
My personal view of the problem and proposed resolution follows.
<p/>
While apparently the intent of <tt>basic_ios::init</tt> is to provide a way to
initialize <tt>basic_ios</tt> after default construction, I see no reason to
forbid it from being called multiple times to reinitialize the stream.
Furthermore, it is possible to implement a conforming <tt>basic_ios</tt> that
does not have this restriction.
<p/>
The quoted above section of the Standard that describes the effects of
the default constructor is misleading. The Standard does not mandate
any data members of <tt>basic_ios</tt> or <tt>ios_base</tt> (27.5.3 [ios.base]), which
it derives from. This means that the implementation is allowed to use
non-POD data members with default constructors that initialize the
members with particular default values. For example, in the case of
Microsoft Visual C++ STL the leaked memory is an <tt>std::locale</tt> instance
that is dynamically allocated during <tt>basic_ios::init</tt>, a raw pointer to
which is stored within ios_base. It is possible to store e.g. an
<tt>unique_ptr</tt> instead of a raw pointer as a member of <tt>ios_base</tt>, the smart
pointer will default initialize the underlying raw pointer on default
construction and automatically destroy the allocated object upon being
reset or destroyed, which would eliminate the leak and allow
<tt>basic_ios::init</tt> to be called multiple times. This leads to conclusion
that the default constructor of <tt>basic_ios</tt> cannot leave "its member
objects uninitialized" but instead performs default initialization of
the member objects, which would mean the same thing in case of POD types.
<p/>
However, I feel that restricting <tt>ios_base</tt> and <tt>basic_ios</tt> members to
non-POD types is not acceptable. Since multiple calls to <tt>basic_ios::init</tt> are 
not forbidden by the Standard, I propose to correct the <tt>basic_ios</tt> default 
constructor description so that it is allowed to destroy <tt>basic_ios</tt> object 
without calling <tt>basic_ios::init</tt>. This would imply that any raw members of 
<tt>basic_ios</tt> and <tt>ios_base</tt> should be initialized to values suitable for 
destruction (essentially, this means only initializing raw pointers to NULL). The new 
wording could look like this:
</p>
<blockquote><p>
<i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (27.5.3.7 [ios.base.cons])
initializing its member objects to unspecified state, only suitable for <tt>basic_ios</tt> destruction.
The object shall be initialized by calling <tt>basic_ios::init</tt> before its first use; otherwise 
the behavior is undefined.
</p></blockquote>
<p>
This would remove the hint that <tt>basic_ios::init</tt> must be called exactly
once. Also, this would remove the requirement for <tt>basic_ios::init</tt> to
be called at all before the destruction. This is also an important issue because 
the derived stream constructor may throw an exception before it manages to call 
<tt>basic_ios::init</tt> (for example, if the streambuf constructor throws), and 
in this case the <tt>basic_ios</tt> destructor has undefined behavior.
<p/>
To my mind, the described modification is sufficient to resolve the issue. But to 
emphasize the possibility to call <tt>basic_ios::init</tt> multiple times, a remark 
or a footnote for <tt>basic_ios::init</tt> postconditions could be added to explicitly 
state the semantics of calling it multiple times. The note could read as follows:
</p>
<blockquote><p>
The function can be called multiple times during the object lifetime. Each subsequent 
call reinitializes the object to the described in postconditions initial state.
</p></blockquote>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Alisdair: The current wording is unclear but the proposed resolution is wrong
<p/>
Solution: Clarify that <tt>init</tt> must be called once and only once. Move then to review. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 27.5.5.2 [basic.ios.cons] as indicated:</p>
<blockquote><pre>
basic_ios();
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: Constructs an object of class <tt>basic_ios</tt> (27.5.3.7 [ios.base.cons]) 
<del>leaving its member objects uninitialized</del><ins>initializing its member objects to unspecified state, 
only suitable for <tt>basic_ios</tt> destruction</ins>. The object shall be initialized by calling 
<tt>basic_ios::init</tt> before its first use <del>or before it is destroyed, whichever comes first</del>; 
otherwise the behavior is undefined.
</p>
</blockquote>
<pre>
void init(basic_streambuf&lt;charT,traits&gt;* sb);
</pre><blockquote>
<p>
<i>Postconditions</i>: The postconditions of this function are indicated in Table 128.
<p/>
<ins>-?- <i>Remarks</i>: The function can be called multiple times during the object lifetime. Each subsequent 
call reinitializes the object to the described in postconditions initial state.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2215" href="#2215">2215.</a> (unordered) associative container functors should be <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2012-11-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on the functors used to arrange elements in the various associative and
unordered containers are given by a set of expressions in tables 102 &mdash; Associative container
requirements, and 103 &mdash; Unordered associative container requirements.  In keeping with Library
convention these expressions make the minimal requirements necessary on their types.  For
example, we have the following 3 row extracts for the unordered containers:
</p>
<table>
<tr>
  <td>
    <b>Expression</b>
  </td>
  <td>
    <b>Assertion/note pre-/post-condition</b>
  </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n, hf, eq)</tt>
<tt>X a(n, hf, eq)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.
 </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n, hf)</tt>
<tt>X a(n, hf)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> is <tt>CopyConstructible</tt> and 
                  <tt>key_equal</tt> is <tt>DefaultConstructible</tt>.
 </td>
</tr>

<tr>
  <td>
<pre>
<tt>X(n)</tt>
<tt>X a(n)</tt>
</pre>
  </td>
  <td>
    <i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>DefaultConstructible</tt>.
 </td>
</tr>
</table>

<p>
However, the signature for each class template requires that the functors must effectively be
<tt>CopyConstructible</tt> for each of these expressions:
</p>

<blockquote><pre>
template &lt;class Key,
          class T,
          class Hash  = hash&lt;Key>,
          class Pred  = std::equal_to&lt;Key>,
          class Allocator = std::allocator&lt;std::pair&lt;const Key, T> > >
class unordered_map
{
  <i>...</i>

  <i>// construct/destroy/copy</i>
  explicit unordered_map(size_type n = <i>see below</i>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());

  <i>...</i>
}
</pre></blockquote>

<p>
The letter of the standard can be honored as long as implementors recognize
their freedom to split this one signature into multiple overloads, so that
the documented default arguments (requiring a <tt>CopyConstructible</tt> functor)
are not actually passed as default arguments.
</p>
<p>
As we look into the requirements for the copy constructor and copy-assignment
operator, the requirements are even more vague, as the explicit requirements on
the functors are not called out, other than saying that the functors are copied.
</p>
<p>
Must the functors be <tt>CopyAssignable</tt>? Or is <tt>CopyConstructible</tt>
sufficient in this case?  Do we require that the functors be <tt>Swappable</tt>
so that the copy-swap idiom can be deployed here?  Note that a type that is both
<tt>CopyConstructible</tt> and <tt>CopyAssignable</tt> is still not guaranteed to
be <tt>Swappable</tt> as the user may delete the <tt>swap</tt> function for their
type in their own namespace, which would be found via ADL.
</p>
<p>
Some clean-up of the requirements table looks necessary, to at least document the
assignment behavior.  In addition, we should have clear guidance on whether these
functors should always be <tt>CopyConstructible</tt>, as suggested by the class
template definitions, or if the requirement tables are correct and we should
explicitly split up the constructors in the (unordered) associative containers
to no longer use default (function) arguments to obtain their defaulted functors.
</p>
<p>
I recommend the simplest solution would be to always require that the functors
for (unordered) associative containers be <tt>CopyConstructible</tt>, above the
requirements tables themselves, so that the issue need not be addressed within
the tables.  I suggest that the assignment operators for these containers add
the requirement that the functors be <tt>Swappable</tt>, rather than forwarding
the corresponding <tt>Assignable</tt> requirement.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
Alisdair to propose wording.
</p>

<p><i>[2014-06-08, Daniel comments]</i></p>

<p>
The area of this issue partially overlaps what LWG <a href="lwg-active.html#2227">2227</a> addresses.
</p>

<p><i>[2015-10-20, Daniel comments]</i></p>

<p>
The revised resolution of LWG <a href="lwg-active.html#2227">2227</a> should resolve this issue as well. It follows the recommendations
of the submitter to require <tt>CopyConstructible</tt> requirements for the function objects owned by containers,
but it does not impose any further fundamental requirements.
</p>


<p><b>Proposed resolution:</b></p>
<p>
See the resolution of LWG <a href="lwg-active.html#2227">2227</a>.
</p>





<hr>
<h3><a name="2216" href="#2216">2216.</a> <tt>regex_replace(basic_string)</tt> allocator handling</h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-11-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<blockquote><pre>
template &lt;class traits, class charT, class ST, class SA&gt;
  basic_string&lt;charT, ST, SA&gt;
  regex_replace(const basic_string&lt;charT, ST, SA&gt;&amp; s,
      const basic_regex&lt;charT, traits&gt;&amp; e,
      const charT* fmt,
      regex_constants::match_flag_type flags = 
	    regex_constants::match_default);
</pre></blockquote>
<p>
and friends are documented as
</p>
<blockquote><p>
Constructs an empty string result of type <tt>basic_string&lt;charT, ST, SA&gt;</tt>
and calls <tt>regex_replace(back_inserter(result), s.begin(), s.end(), e, fmt, flags)</tt>.
</p></blockquote>
<p>
This appears to require the result to have a default-constructed
allocator, which isn't even possible for all allocator types. I
suspect the allocator should be copied from 's' instead. Possibly
there should be an additional defaulted argument to override the
allocator of the result.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2220" href="#2220">2220.</a> Under-specification of <tt>operator==</tt> for <tt>regex_token_iterator</tt></h3>
<p><b>Section:</b> 28.12.2.2 [re.tokiter.comp] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-11-21 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Consider the following example:
</p>
<blockquote><pre>
std::string str0("x");
std::regex rg0("a");
std::regex_token_iterator it0(str0.begin(), str0.end(), rg0, -1); // points at "x" in str0
std::string str1("x");
std::regex rg1("b");
std::regex_token_iterator it1(str1.begin(), str1.end(), rg1, -1); // points at "x" in str1
</pre></blockquote>
<p>
28.12.2.2 [re.tokiter.comp] p1 says that <tt>it0.operator==(it1)</tt> returns true "if 
<tt>*this</tt> and <tt>right</tt> are both suffix iterators and <tt>suffix == right.suffix</tt>"; both 
conditions are satisfied in this example. It does not say that they must both be iterators 
into the same sequence, nor does it say (as general iterator requirements do) that they must 
both be in the domain of <tt>==</tt> in order for the comparison to be meaningful. It's a 
simple statement: they're equal if the strings they point at compare equal. Given this being
a valid comparison, the obtained result of "true" looks odd.
<p/>
The problem is that for iterator values prior to the suffix iterator, equality means the same 
regular expression and the same matched sequence (both uses of "same" refer to identity, not equality); 
for the suffix iterator, equality means that the matched sequences compare equal.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2221" href="#2221">2221.</a> No formatted output operator for <tt>nullptr</tt></h3>
<p><b>Section:</b> 27.7.3 [output.streams] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2012-12-07 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
When I write 
</p>
<blockquote><pre>
std::cout &lt;&lt; nullptr &lt;&lt; std::endl;
</pre></blockquote>
<p>
I get a compilation error, "ambiguous overload for '<tt>operator&lt;&lt;</tt>' in '<tt>std::cout &lt;&lt; nullptr</tt>'". 
As far as I can tell, the compiler is right to issue that error. There are inserters for <tt>const void*</tt>, 
<tt>const char*</tt>, <tt>const signed char*</tt>, and <tt>const unsigned char*</tt>, and none for 
<tt>nullptr_t</tt>, so the expression really is ambiguous.
<p/>
<em>Proposed wording</em>:
<p/>
The obvious library solution is to add a <tt>nullptr_t</tt> overload, which would be defined something like
</p>
<blockquote><pre>
template&lt;class C, class T&gt;
basic_ostream&lt;C, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;C, T&gt;&amp; os, nullptr_t) 
{ 
  return os &lt;&lt; (void*) nullptr; 
}
</pre></blockquote>
<p>
We might also consider addressing this at a core level: add a special-case language rule that addresses all 
cases where you write <tt>f(nullptr)</tt> and <tt>f</tt> is overloaded on multiple pointer types. (Perhaps 
a tiebreaker saying that <tt>void*</tt> is preferred in such cases.)
</p>

<p><i>[2016-01-18, comments from Mike and Ville collected by Walter Brown]</i></p>

<p>
<b>Mike Miller</b>: "Changing overload resolution sounds like something that should be
considered by EWG before CWG [&hellip;]"
<p/>
<b>Ville</b>: "Agreed, such a change would be Evolutionary. Personally, I think it would also be wrong, because 
I don't see how <tt>void*</tt> is the right choice to prefer in the case of code that is currently ambiguous. 
Sure, it would solve this particular library issue, but it seemingly has wider repercussions. If LWG really wants 
to, EWG can certainly discuss this issue, but I would recommend solving it on the LWG side (which doesn't mean 
that the standard necessarily needs to change, I wouldn't call it far-fetched to NAD it)."
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Zhihao recommends NAD:</p>
<p>
<tt>nullptr</tt> is printable if being treated as <tt>void*</tt>, but causes
UB if being treated as <tt>char cv*</tt>. Capturing this ambigurity
at compile time and avoid a runtime UB is a good thing.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: General agreement on providing the overload; discussion on what it should say.</p>
<p>Polls:<br/>
Matt's suggestion (in the issue): 2/0/6/2/2/<br/>
Unspecified output: 3/2/5/0/1<br/>
Specified output: 1/1/6/3/0</p>
<p>Move to Open</p>

<p><i>[2016-08 Chicago]</i></p>

<p>
The group consensus is that we only output <tt>nullptr</tt> because
it is of a fundamental type, causing problems in functions doing
forwarding, and we don't want to read it back.
</p>
<p>Fri PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606
</p>

<ol>
<li><p>Insert the signature into 27.7.3.1 [ostream], class template <tt>basic_ostream</tt> synopsis, as follows:</p>

<blockquote class="note">
<p>
[<i>Drafting notes:</i> Why member?  Don't want to define a new category of inserters just for this.]
</p>
</blockquote>

<blockquote>
<pre>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_ostream
    : virtual public basic_ios&lt;charT, traits&gt; {
  public:
    [&hellip;]
    basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(const void* p);
    <ins>basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(nullptr_t);</ins>
    basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(
      basic_streambuf&lt;char_type, traits&gt;* sb);
    [&hellip;]
  };
</pre>
</blockquote>
</li>

<li><p>Append the following new paragraphs to 27.7.3.6.3 [ostream.inserters]:</p>

<blockquote>
<pre>
basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;
  (basic_streambuf&lt;charT, traits&gt;* sb);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-10- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
<pre>
<ins>basic_ostream&lt;charT, traits&gt;&amp; operator&lt;&lt;(nullptr_t);</ins>
</pre>
<blockquote>
<p>
<ins>-??- <i>Effects:</i> Equivalent to <tt>return *this &lt;&lt; s;</tt> where
<tt>s</tt> is an implementation-defined NTCTS.</ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>





<hr>
<h3><a name="2223" href="#2223">2223.</a> <tt>shrink_to_fit</tt> effect on iterator validity</h3>
<p><b>Section:</b> 23.3.11.3 [vector.capacity] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2012-12-17 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
After the additions by <a href="lwg-defects.html#2033">2033</a>, it appears clear that the intended effect includes a reallocation and 
thus the potential effect on iterators should be explicitly added to the text in order to not contradict 
23.2.1 [container.requirements.general]/11, or at the very least, explicitly state that a reallocation may 
happen.
<p/>
Taking consistency with "reserve" into consideration, I propose:
</p>
<ul>
<li><p>
that the current "Remarks" are made its "Effect" instead, inserting "Reallocation happens at this point if and only 
if the function effectively reduces the capacity." after the note on non-bindingness.
</p>
</li>
<li><p>
adding a "Remarks" paragraph, similar to that of reserve: "Reallocation invalidates all the references, pointers, 
and iterators referring to the elements in the sequence."
</p></li>
</ul>
<p>
BTW, while we are at it, I believe the effect on iterators should also be explicitly stated in the other instance 
a reallocation may happen: 23.3.11.5 [vector.modifiers]/1 &mdash; even if obvious, it only contradicts 
23.2.1 [container.requirements.general]/11 implicitly. 
<p/>
I propose to also insert "Reallocation invalidates all the references, pointers, and iterators referring to the 
elements in the sequence." at the appropriate location in its "Remarks".
</p>

<p><i>[2012-12-19: Jonathan Wakely comments]</i></p>


<p>
The described problem also affects <tt>std::basic_string</tt> and <tt>std::deque</tt>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Review.
</p>

<p><i>[2013-04-18, Bristol]</i></p>
 

<p>Daniel extends the P/R.</p>

<p>Rationale:</p>

<p>The wording in 21.3.1.4 [string.capacity] combined with 21.3.1.1 [string.require]
seems to say the necessary things. We cannot impose all requirements as we do for <tt>vector</tt>, because
we want to allow the short-string-optimization.</p>


<p><i>[2014-02-15 post-Issaquah session]</i></p>

<p>
STL: I think that <tt>shrink_to_fit</tt> should be a no-op when called twice.
</p>
<p>
STL: Do we ever define reallocation for <tt>deque</tt>? Nope, all mentions of "reallocation" are in <tt>vector</tt>.
     We define what it means in <tt>vector::reserve()</tt>, but not for <tt>deque</tt>.
</p>
<p>
STL: Oh duh, they define reallocate in the PR. But I think we can do better here.
</p>
<p>
STL: Optimally, deque shrinking just allocates a new map of pointers, and drops empty blocks, but preserves pointers/references to elements.
</p>
<p>
Alisdair: That's like unordered containers, invalidating only iterators.
</p>
<p>
Pablo: It doesn't make sense to reduce <tt>capacity()</tt> to <tt>size()</tt>, because <tt>deque</tt> doesn't have capacity!
</p>
<p>
STL: For <tt>vector</tt>, "effectively reduces the capacity" is unnecessary, the capacity there is observable.
</p>
<p>
STL: There is a strong reason to provide an optimal shrink to fit for <tt>deque</tt>, since only the library implementer can do this.
</p>
<p>
STL: The other thing I don't like the repeated definition of reallocation for <tt>vector</tt>, we define it once and use it in a bunch of places.
     At most we can lift it up to the <tt>vector</tt> synopsis.
</p>
<p>
STL: I'll write new wording.
</p>

<p><i>[2014-10-01, STL adds discussion and provides new wording]</i></p>

<p>
Compared to the previous proposed resolution:
</p>
<ul>
<li><p>
I'm changing <tt>basic_string</tt>'s wording because (1) we should guarantee that capacity won't increase, (2) we should mention 
that it's linear complexity, and (3) we can provide a better invalidation guarantee than 21.3.1.1 [string.require]/5.  
(As previously noted, we already have the strong exception guarantee.) This introduces the term "reallocation" into 
<tt>basic_string</tt>, but immediately explains what it means for iterator validity. As far as I can tell, the Small String 
Optimization doesn't complicate the wording here; it's a reason why an implementation might not honor the request, but if 
the capacity is reduced, we are definitely reallocating buffers and will invalidate everything (including when the destination 
is the small buffer).
</p></li>
<li><p>
Between N3485 and N3936, <tt>deque</tt>'s wording was updated to avoid talking about <tt>capacity()</tt> which it doesn't have.  
Since the container's capacity is unobservable, I'm saying that invalidation is unconditional.
</p></li>
<li><p>
In <tt>vector</tt>'s wording, I'm also guaranteeing that capacity won't increase, and that iterators/etc. remain valid if the 
capacity is unchanged.
</p></li>
</ul>
<p>
My wording doesn't directly say that <tt>shrink_to_fit()</tt> should be a no-op when called twice in a row. (Indirectly, 
if the first call reduces <tt>capacity()</tt> to <tt>size()</tt>, the second call must preserve iterators/etc.) I considered 
rewording the complexity to say "linear if reallocation happens", but that's potentially problematic (what if we copy almost 
all <tt>N</tt> elements, then one throws and we have to unwind? There are no effects, so reallocation didn't happen, yet we 
took longer than constant time). Implementers can always do better than the stated complexity bounds.
<p/>
I chose not to modify <tt>deque</tt>'s requirements, so implementations remain free to reallocate the elements themselves.
<p/>
I didn't attempt to centralize vector's reallocation wording. That can be done editorially, if someone is sufficiently motivated.
</p>

<p><strong>Previous resolution from Juan Soulie/Daniel [SUPERSEDED]:</strong></p>

<blockquote class="note">
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Keep 21.3.1.4 [string.capacity] around p14 <em>unchanged</em>, because we don't speak about
reallocations and we give the strong exception guarantee in 21.3.1.1 [string.require] (Invalidation
specification also at that place):</p>
<blockquote><pre>
void shrink_to_fit();
</pre>
<p>
-14- <i>Remarks</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ].
</p>
</blockquote>
</li>

<li><p>Edit 23.3.8.3 [deque.capacity] around p7 as indicated:</p>
<blockquote><pre>
void shrink_to_fit();
</pre>
<p>
-5- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ] Reallocation happens at this point if and only 
if the function effectively reduces the capacity. If an exception is thrown other than by the move constructor 
of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins> 
<p/>
-6- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-7- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ] If an exception is thrown other than by the move constructor 
of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</del><ins>Reallocation invalidates all 
the references, pointers, and iterators referring to the elements in the sequence.</ins>
</p>
</blockquote>
</li>

<li><p>Edit 23.3.11.3 [vector.capacity] around p7 as indicated:</p>
<blockquote><pre>
void shrink_to_fit();
</pre>
<p>
-7- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ] Reallocation happens at this point if and only 
if the function effectively reduces the capacity. If an exception is thrown other than by the move constructor 
of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins> 
<p/>
-8- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-9- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to 
<tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i> ] If an exception is thrown other than by the move constructor 
of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</del><ins>Reallocation invalidates all 
the references, pointers, and iterators referring to the elements in the sequence.</ins>
</p>
</blockquote>
</li>

<li><p>Edit 23.3.11.5 [vector.modifiers] p1 as indicated:</p>
<blockquote><pre>
iterator insert(const_iterator position, const T&amp; x);
iterator insert(const_iterator position, T&amp;&amp; x);
iterator insert(const_iterator position, size_type n, const T&amp; x);
template &lt;class InputIterator&gt;
iterator insert(const_iterator position, InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list&lt;T&gt;);
template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);
template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</pre>
<p>
-1- <i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. <ins>Reallocation 
invalidates all the references, pointers, and iterators referring to the elements in the sequence.</ins> If 
no reallocation happens, all the iterators and references before the insertion point remain valid. If an 
exception is thrown other than by the copy constructor, move constructor, assignment operator, or move 
assignment operator of <tt>T</tt> or by any <tt>InputIterator</tt> operation there are no effects. If an 
exception is thrown by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt>, the effects are unspecified.
</p>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
GR: I'm concerned that <tt>shrink_to_fit</tt> may cause reallocation without changing the capacity. [&hellip;] 
It's about correctness. The statement about invalidation is useless if I cannot detect whether reallocation has happened?
<p/>
AM: It seems like the logic goes the other way round: It's the capacity change that causes reallocation, so if 
there's no capacity change, there's no reallocation. But that's not quite how I'd like to say it... maybe this, : 
"If capacity does not change, no reallocation occurs."
<p/>
GR: Where does it actually say that <tt>reserve()</tt> invalidates? AM: It should say that in the container requirements. 
VV: vector specifies in <tt>reserve</tt> that there's reallocation if and only if the capacity changes. GR: I can't find
anything in the container requirements about <tt>reserve</tt>. DK: No, it's specified for every container separately. 
GR: It isn't specified for string.
<p/>
GR: I'm noticing that the issue touches on <tt>shrink_to_fit</tt> for a bunch of containers. Anyway, I think the 
reserve issue [re string] is in scope for this issue. This change is touching on a lot of members.
<p/>
AM: Landing this change will provide clarity for what we should do with <tt>basic_string</tt>. GR: We're already asking 
for changes; we should fix string as well. AM: If one of the changes is ready before the other, I'd like to land the 
finished part first, but if both are ready for Lenexa, I'm equally happy to fix them in one go.
<p/>
DK will reword this. 
<p/>
<b>Conclusion</b>: Update wording, revisit in Lenexa. 
</p>
<p><i>[2016-08 Chicago]</i></p>

<p>Monday PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol>
<li><p>Change 21.3.1.4 [string.capacity] p14 as depicted:</p>

<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-14- <i><del>Remarks</del><ins>Effects</ins></i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce 
<tt>capacity()</tt> to <tt>size()</tt>. [<i>Note</i>: The request is non-binding to allow latitude for 
implementation-specific optimizations. &mdash; <i>end note</i>] <ins>It does not increase <tt>capacity()</tt>, 
but may reduce <tt>capacity()</tt> by causing reallocation.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Linear in the size of the sequence.</ins>
<p/>
<ins>-?- <i>Remarks</i>: Reallocation invalidates all the references, pointers, and iterators referring to the 
elements in the sequence. If no reallocation happens, they remain valid.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.8.3 [deque.capacity] p5-p7 as depicted:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-5- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce memory use but does not change 
the size of the sequence. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific 
optimizations. &mdash; <i>end note</i>] If an exception is thrown other than by the move constructor of a 
non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins>
<p/>
-6- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-7- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce memory use but does not change the
size of the sequence. [<i>Note</i>: The request is non-binding to allow latitude for implementation-specific
optimizations. &mdash; <i>end note</i>]</del><ins><tt>shrink_to_fit</tt> invalidates all the references, pointers, 
and iterators referring to the elements in the sequence.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.11.3 [vector.capacity] p7-p9 as depicted:</p>
<blockquote>
<pre>
void shrink_to_fit();
</pre>
<blockquote>
<p>
-7- <i>Requires</i>: <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt>.
<p/>
<ins>-?- <i>Effects</i>: <tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to <tt>size()</tt>. 
[<i>Note</i>: The request is non-binding to allow latitude for implementation-specific optimizations. &mdash; <i>end note</i>] 
It does not increase <tt>capacity()</tt>, but may reduce <tt>capacity()</tt> by causing reallocation. If an exception is 
thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.</ins>
<p/>
-8- <i>Complexity</i>: Linear in the size of the sequence.
<p/>
-9- <i>Remarks</i>: <del><tt>shrink_to_fit</tt> is a non-binding request to reduce <tt>capacity()</tt> to <tt>size()</tt>. 
[<i>Note</i>: The request is non-binding to allow latitude for implementation-specific optimizations. &mdash; <i>end 
note</i>] If an exception is thrown other than by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt> there 
are no effects.</del><ins>Reallocation invalidates all the references, pointers, and iterators referring to the elements 
in the sequence. If no reallocation happens, they remain valid.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 23.3.11.5 [vector.modifiers] p1 as depicted:</p>

<blockquote>
<p>
-1- <i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. <ins>Reallocation invalidates all 
the references, pointers, and iterators referring to the elements in the sequence.</ins> If no reallocation happens,
all the iterators and references before the insertion point remain valid. [&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2226" href="#2226">2226.</a> <tt>wstring_convert</tt> methods do not take allocator instance</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Glen Fernandes <b>Opened:</b> 2012-12-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>wstring_convert</tt> class template, described in 22.3.3.2.2 [conversions.string], does not 
support custom stateful allocators. It only supports custom stateless allocators.
<p/>
The <tt>to_bytes</tt> member function returns <tt>basic_string&lt;char, char_traits&lt;char&gt;, Byte_alloc&gt;</tt>  
but it does not take an instance of <tt>Byte_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
Similarly the <tt>from_bytes</tt> member function returns <tt>basic_string&lt;Elem, char_traits&lt;Elem&gt;, Wide_alloc&gt;</tt>  
but it does not take an instance of <tt>Wide_alloc</tt> to pass to the constructor of the <tt>basic_string</tt>.
<p/>
This makes these two member functions and the <tt>wstring_convert</tt> class template not usable when <tt>Wide_alloc</tt> 
or <tt>Byte_alloc</tt> are stateful allocators.
</p>

<p><i>[2013-01-22, Glen provides wording]</i></p>


<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to NAD Future.
</p>
<p>
This is clearly an extension that the LEWG may want to take a look at, once we have more experience
with appropriate use of allocators with the C++11 model.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>In 22.3.3.2.2 [conversions.string]/2 and /6 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>from_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Wide_alloc</tt>:</p>

<blockquote><pre>
wide_string from_bytes(char byte<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *ptr<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const byte_string&amp; str<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
wide_string from_bytes(const char *first, const char *last<ins>, const Wide_alloc&amp; alloc = Wide_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In 22.3.3.2.2 [conversions.string] /8 specify that this <tt>Wide_alloc</tt> allocator parameter is used to
construct the <tt>wide_string</tt> object returned from the function:</p>

<p>
-7- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>byte</tt> to a wide string.
The second member function shall convert the null-terminated sequence beginning at <tt>ptr</tt> to a wide
string. The third member function shall convert the sequence stored in <tt>str</tt> to a wide string. The fourth
member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a wide string.
<p/>
-8- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Wide_alloc</tt> allocator parameter is used to construct the <tt>wide_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

<li><p>In 22.3.3.2.2 [conversions.string]/2 and /12 "Class template <tt>wstring_convert</tt> synopsis" change the overloads 
of the member function <tt>to_bytes()</tt> so that all four overloads take an additional parameter
which is an instance of <tt>Byte_alloc</tt>:</p>

<blockquote><pre>
byte_string to_bytes(Elem wchar<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *wptr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const wide_string&amp; wstr<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
byte_string to_bytes(const Elem *first, const Elem *last<ins>, const Byte_alloc&amp; alloc = Byte_alloc()</ins>);
</pre></blockquote>
</li>

<li><p>In 22.3.3.2.2 [conversions.string] /13 specify that this <tt>Byte_alloc</tt> allocator parameter is used to
construct the <tt>byte_string</tt> object returned from the function:</p>

<p>
-12- <i>Effects</i>: The first member function shall convert the single-element sequence <tt>wchar</tt> to a byte string.
The second member function shall convert the null-terminated sequence beginning at <tt>wptr</tt> to a byte
string. The third member function shall convert the sequence stored in <tt>wstr</tt> to a byte string. The
fourth member function shall convert the sequence defined by the range <tt>[first, last)</tt> to a byte string.
<p/>
-13- In all cases:
</p>
<ul>
<li><p>If the <tt>cvtstate</tt> object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.</p></li>

<li><p>The number of input elements successfully converted shall be stored in <tt>cvtcount</tt>.</p></li>

<li><p><ins>The <tt>Byte_alloc</tt> allocator parameter is used to construct the <tt>byte_string</tt> object returned 
from the function.</ins></p></li>
</ul>
</li>

</ol>





<hr>
<h3><a name="2227" href="#2227">2227.</a> Stateful comparison objects in associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2012-12-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 102 in 23.2.4 [associative.reqmts]/8 states on expression <tt>a.key_comp()</tt> that it 
"returns the comparison object out of which a was constructed". At the same time, 
23.2.1 [container.requirements.general]/8 states (starting in the third line) that 
"...Any <tt>Compare</tt>, <tt>Pred</tt>, or <tt>Hash</tt> objects belonging to <tt>a</tt> and <tt>b</tt> 
shall be swappable and <em>shall be exchanged</em> by unqualified calls to non-member swap...". This is 
problematic for any compliant implementation, since once swapped the container cannot return the comparison 
object out of which it was constructed unless incurring in storing an otherwise needless object.
<p/>
The simple solution is to correct that statement in Table 102, but I believe this is part of a larger problem 
of underspecified behavior: The new standard has made an effort in regards to allocators and now fully 
specifies what happens to stateful allocator objects. It has even specified what happens to stateful <tt>hasher</tt> 
and <tt>key_equal</tt> members of unordered containers (they propagate), but it says nothing about stateful 
comparison objects of (ordered) associative containers, except for the statement in 
23.2.1 [container.requirements.general]/8 referred above and only related to <tt>swap</tt>.
<p/>
For example, it is unclear to me what is specified to happen on an assignment: should the comparison object 
be copied/moved along with the elements, or should the left-hand side object keep its own?
Maybe this has been intentionally left unspecified with the purpose of compatibility with C++98, which I 
understand it specified that comparison objects were kept for the entire life of the container (like allocators) 
&mdash; an unfortunate choice. But anyway, the segment of 23.2.1 [container.requirements.general] quoted 
above seems to break any possible backwards compatibility with C++98 in this regard.
<p/>
Therefore, taking into consideration consistency with how this is dealed with for unordered associative 
containers, I propose that Table 102 is modified as follows:
</p>
<ul>
<li>
<p>
The row for expression <tt>a.key_comp()</tt> is changed so that its "assertion/note pre-/post-condition" reads 
"Returns <tt>a</tt>'s comparison object."
</p>
</li>

<li>
<p>
A new row is added at the appropriate location (which I believe would be after "X(il)" row), with:
</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td>
<tt>X(b)<br/>
X a(b)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
Copy constructor. In addition to<br/>
the requirements of Table 96, copies<br/>
the comparison object.
</td>
<td>
Linear in <tt>b.size()</tt>
</td>
</tr>

<tr>
<td>
<tt>a = b</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
Copy assignment operator. In addition to<br/>
the requirements of Table 96, copies the<br/>
comparison object.
</td>
<td>
Linear in <tt>a.size()</tt> and <tt>b.size()</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ul>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Review.
</p>

<p><i>[2013-04-18, Bristol]</i></p>
 
<p>
STL: can't believe we don't specify this already. this is totally necessary
<p/>
Alisdair: how does it do this? copy construction? assignment?
<p/>
Also need it for move.
<p/>
STL: we already specify this for constructing from a comparator, not during copy construction though.
<p/>
Jonathan: don't like wording, should say "<tt>key_compare</tt> is <tt>CopyConstructible</tt>. Uses <tt>b.key_comp()</tt> 
as a comparison object."
<p/>
STL: we get it right for unordered!
<p/>
Jonathan: can't wordsmith this now, but I think implementations do the right thing.
<p/>
Alisdair: not sure what right thing is for moves. Also we say nothing about propagating allocators to functors.
</p>
<p>
Moved to Open.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
TK: There's no need for fine-grained propagate/not-propagate control. If you don't want to propagate the predicate, you can 
simply construct or insert from an iterator range.
<p/>
VV: libstdc++ already implements the resolution of this issue.
<p/>
GR: There are a couple of other problems. We don't specify move constructor and move assignment for maps. Those are just general.
<p/>
TK: General container requirements already describe the semantics for {copy,move}-{construction,assignment}, so it doesn't 
seem that there's room for choice in <tt>std::map</tt> assignments. <tt>unordered_map</tt> is different, though.
<p/>
[Note: Check what general container requirements say about container equality.]
<p/>
DK will draft wording. The decision is to unambiguously make all {copy,move}-{construction,assignment} operations endow the 
LHS with the exact state of the RHS, including all predicates and hash function states.
<p/>
Conclusion: Update wording, revisit later. 
</p>

<p><i>[2015-05-06 Lenexa: Waiting for updated wording]</i></p>


<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Change Table 102 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(il)</tt>
</td>
<td>
<tt></tt>
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
<td>
same as <tt>X(il.begin(), il.end())</tt>.
</td>
</tr>

<tr>
<td>
<ins><tt>X(b)<br/>
X a(b)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>Copy constructor. In addition to<br/>
the requirements of Table 96, copies<br/>
the comparison object.</ins>
</td>
<td>
<ins>Linear in <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = b</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>Copy assignment operator. In addition to<br/>
the requirements of Table 96, copies the<br/>
comparison object.</ins>
</td>
<td>
<ins>Linear in <tt>a.size()</tt> and <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.key_comp()</tt>
</td>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<del>r</del><ins>R</ins>eturns <del>the</del><ins><tt>a</tt>'s</ins> comparison object<br/>
<del>out of which a was constructed.</del>
</td>
<td>
constant
</td>
</tr>


</table>
</blockquote>

</li>

</ol>
</blockquote>

<p><i>[2015-10-19 Daniel comments and provides alternative wording]</i></p>

<p>
The current standard is especially unclear in regard to what effects move operations of unordered/associative
containers should have. We have one example that is standardized exactly in this way by looking at 
23.6.5.2 [priqueue.cons.alloc] p7:
</p>
<blockquote>
<pre>
template &lt;class Alloc&gt; priority_queue(priority_queue&amp;&amp; q, const Alloc&amp; a);
</pre>
<blockquote>
<p>
-7- <i>Effects</i>: Initializes <tt>c</tt> with <tt>std::move(q.c)</tt> as the first argument and <tt>a</tt> as 
the second argument, and initializes <tt>comp</tt> with <tt>std::move(q.comp)</tt>
</p>
</blockquote>
</blockquote>
<p>
A similarly comparable example are the move-operations of <tt>std::unique_ptr</tt> in regard to the deleter 
(when this is no a reference), which also respect move-capabilities of that function object.
<p/>
We have wording from C++98 for associative containers (but <em>not</em> for unordered containers!) that was never
adjusted to C++11 move-semantics in 23.2.4 [associative.reqmts] p12:
</p>
<blockquote><p>
When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.
</p></blockquote>
<p>
The second sentence of this wording is problematic for several reasons:
</p>
<ol>
<li><p>It only talks about copy operations, not about move operations, except that the term "assignment" without
leading "copy" is a bit ambigious (albeit it seems clear in the complete context).</p></li>
<li><p>It is not really clear how to interpret "as if that comparison object had been
passed to the target container in its constructor" for an assignment operation. A possible but not conclusive
interpretation could be that this is wording supporting a "copy-via-swap" idiom.</p></li>
<li><p>There does not exist similar wording for unordered containers, except that Table 102 provides entries for
copy construction and copy assignment of the containers whose wording just talks of "copies" in either case.</p></li>
</ol>
<p>
Existing implementations differ already:
</p>
<ol>
<li><p>Visual Studio 2015 uses copy construction and copy assignment for the two copy operations but uses swap operations
for the move operations.</p></li>
<li><p>GCC's libstdc++ performs copy construction and copy assignment for the two copy operations and for the two
move operations, respectively</p></li>
<li><p>clang++'s libc++ performs copy/move construction and copy/move assignment for the corresponding
four copy/move operations</p></li>
</ol>
<p>
The alternative wording provided below attempts to clarify that container copy/move operations perform the corresponding
copy/move operations on the owned function objects.
<p/>
In addition the wording also resolves LWG <a href="lwg-active.html#2215">2215</a>: I believe that the current
wording should require that container function objects should meet the <tt>CopyConstructible</tt> requirements. Adding
this general requirement also fixes the underspecified requirements of the accessor functions <tt>key_comp()</tt> and
<tt>value_comp()</tt>.
<p/>
I don't think that a general requirement for <tt>Swappable</tt> is needed, only the member <tt>swap</tt> function currently requires this.
Nonetheless the wording below does <em>support</em> stateful functors that are <em>also</em> moveable or move-assignable,
therefore the specified semantics in terms of move operations.
<p/>
I should add the following warning, though: If this proposed wording would be accepted, there is a little chance of
code breakage, because the current wording <em>can</em> be read that in general there is no requirement that the
container functors are <tt>CopyConstructible</tt>. The following code example is accepted by gcc + libstd++:
</p>
<blockquote><pre>
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;

struct Cmp {
  Cmp() = default;
  Cmp(const Cmp&amp;) = delete;
  Cmp(Cmp&amp;&amp;) = delete;
  Cmp&amp; operator=(const Cmp&amp;) = delete;
  Cmp&amp; operator=(Cmp&amp;&amp;) = delete;
  template&lt;class T&gt;
  bool operator()(const T&amp; x, const T&amp; y) const
  {
    return x &lt; y;
  }
};

typedef std::map&lt;int, int, Cmp&gt; MyMap;

int main() {
  MyMap m;
  std::cout &lt;&lt; (m.find(12) == m.end()) &lt;&lt; std::endl;
}
</pre></blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4527.</p>

<ol>
<li><p>Change 23.2.4 [associative.reqmts] p8 as indicated:</p>

<blockquote><p>
-8- In Table 101, <tt>X</tt> denotes an associative container class, <tt>a</tt> denotes a value of type <tt>X</tt>, 
<ins><tt>b</tt> denotes a possibly <tt>const</tt> value of type <tt>X</tt>, <tt>rv</tt> denotes a non-<tt>const</tt> rvalue of 
type <tt>X</tt>,</ins> <tt>u</tt> denotes the name of a variable being declared, [&hellip;]
</p></blockquote>
</li>

<li><p>Change Table 101 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 101 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<tt>Compare</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Compare</tt> is <tt>CopyConstructible</tt>.</ins><br/>
defaults to <tt>less&lt;key_type&gt;</tt>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X(c)<br/>
X u(c);</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<del><i>Requires:</i> <tt>key_compare</tt> is <tt>CopyConstructible</tt>.<br/></del> 
<i>Effects</i>: Constructs an empty container.<br/> 
Uses a copy of <tt>c</tt> as a comparison object.
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(i,j,c)<br/>
X u(i,j,c);</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<i>Requires:</i> <del><tt>key_compare</tt> is <tt>CopyConstructible</tt>.<br/></del> 
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: Constructs an empty container and inserts elements<br/>
from the range <tt>[i, j)</tt> into it; uses <tt>c</tt> as a comparison object.
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(il)</tt>
</td>
<td>
<tt></tt>
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
<td>
same as <tt>X(il.begin(), il.end())</tt>.
</td>
</tr>

<tr>
<td>
<ins><tt>X(b)<br/>
X a(b)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>(In addition to the requirements of Table 95)<br/>
<i>Effects:</i> Copy constructs the comparison object of <tt>a</tt> from<br/> 
the comparison object of <tt>b</tt>.</ins>
</td>
<td>
<ins>Linear in <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>X(rv)<br/>
X a(rv)</tt></ins>
</td>
<td>
<tt></tt>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Effects:</i> Move constructs the comparison object of <tt>a</tt> from<br/> 
the comparison object of <tt>rv</tt>.</ins>
</td>
<td>
<ins>constant</ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = b</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>key_compare</tt> is <tt>CopyAssignable</tt>.<br/> 
<i>Effects:</i> Copy assigns the comparison object of <tt>b</tt><br/>
to the comparison object of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear in <tt>a.size()</tt> and <tt>b.size()</tt></ins>
</td>
</tr>

<tr>
<td>
<ins><tt>a = rv</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>key_compare</tt> is <tt>MoveAssignable</tt>.<br/> 
<i>Effects:</i> Move assigns from the comparison object of <tt>rv</tt><br/>
to the comparison object of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.key_comp()</tt>
</td>
<td>
<tt>X::key_compare</tt>
</td>
<td>
<del>r</del><ins>R</ins>eturns <del>the</del><ins><tt>a</tt>'s</ins> comparison object<br/>
<del>out of which a was constructed.</del>
</td>
<td>
constant
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 23.2.4 [associative.reqmts] p12 as indicated:</p>

<blockquote><p>
-12- When an associative container is constructed by passing a comparison object the container shall not store
a pointer or reference to the passed object, even if that object is passed by reference. <del>When an associative
container is copied, either through a copy constructor or an assignment operator, the target container shall
then use the comparison object from the container being copied, as if that comparison object had been
passed to the target container in its constructor.</del>
</p></blockquote>
</li>


<li><p>Change 23.2.5 [unord.req] p11 as indicated:</p>

<blockquote><p>
-11- In Table 102: <tt>X</tt> denotes an unordered associative container class, <tt>a</tt> denotes a value of type <tt>X</tt>, 
<tt>b</tt> denotes a possibly <tt>const</tt> value of type <tt>X</tt>, <ins><tt>rv</tt> denotes a non-<tt>const</tt> rvalue 
of type <tt>X</tt>,</ins> [&hellip;]
</p></blockquote>
</li>

<li><p>Change Table 102 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X::hasher</tt>
</td>
<td>
<tt>Hash</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Hash</tt> is <tt>CopyConstructible</tt>.<br/></ins>
<tt>Hash</tt> shall be a unary function object type<br/> 
such that the expression <tt>hf(k)</tt> has type <tt>std::size_t</tt>.
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::key_equal</tt>
</td>
<td>
<tt>Pred</tt>
</td>
<td>
<ins><i>Requires</i>: <tt>Pred</tt> is <tt>CopyConstructible</tt>.<br/></ins>
<tt>Pred</tt> shall be a binary predicate that takes<br/> 
two arguments of type <tt>Key</tt>.<br/> 
<tt>Pred</tt> is an equivalence relation.
</td>
<td>
compile time
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(n, hf, eq)<br/>
X a(n, hf, eq)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<del><i>Requires</i>: <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.<br/></del>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>X(n, hf)<br/>
X a(n, hf)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> is <tt>CopyConstructible</tt> and<br/></del>
<tt>key_equal</tt> is <tt>DefaultConstructible</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(i, j, n, hf, eq)<br/>
X a(i, j, n, hf, eq)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyConstructible</tt>.<br/></del>
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td>
<tt>X(i, j, n, hf)<br/>
X a(i, j, n, hf)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<i>Requires</i>: <del><tt>hasher</tt> is <tt>CopyConstructible</tt> and<br/></del>
<tt>key_equal</tt> is <tt>DefaultConstructible</tt>.<br/> 
<tt>value_type</tt> is <tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>*i</tt>.<br/>
<i>Effects</i>: [&hellip;]
</td>
<td>
[&hellip;]
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(b)<br/>
X a(b)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
<del>Copy constructor. In addition<br/>
to the requirements of Table 95,<br/>
copies the hash function,<br/>
predicate, and maximum load<br/>
factor.</del>
<ins>(In addition to the requirements of Table 95)<br/>
<i>Effects:</i> Copy constructs the hash function, predicate, and maximum load factor<br/> 
of <tt>a</tt> from the corresponding objects of <tt>b</tt>.</ins>
</td>
<td>
Average case linear in<br/> 
<tt>b.size()</tt>,<br/>
worst case quadratic.
</td>
</tr>

<tr>
<td>
<ins><tt>X(rv)<br/>
X a(rv)</tt></ins>
</td>
<td>
<ins><tt>X</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Effects:</i> Move constructs the hash function, predicate, and maximum load factor<br/> 
of <tt>a</tt> from the corresponding objects of <tt>rv</tt>.</ins>
</td>
<td>
<ins>constant</ins>
</td>
</tr>

<tr>
<td>
<tt>a = b</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<del>Copy assignment operator. In<br/>
addition to the requirements of<br/>
Table 95, copies the hash<br/>
function, predicate, and<br/>
maximum load factor.</del>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>CopyAssignable</tt>.<br/> 
<i>Effects:</i> Copy assigns the hash function, predicate, and maximum load factor<br/> 
of <tt>b</tt> to the corresponding objects of <tt>a</tt>.</ins>
</td>
<td>
Average case linear in<br/> 
<tt>b.size()</tt>,<br/>
worst case quadratic.
</td>
</tr>

<tr>
<td>
<ins><tt>a = rv</tt></ins>
</td>
<td>
<ins><tt>X&amp;</tt></ins>
</td>
<td>
<ins>(In addition to the requirements of Table 95 and Table 98)<br/>
<i>Requires:</i> <tt>hasher</tt> and <tt>key_equal</tt> are <tt>MoveAssignable</tt>.<br/> 
<i>Effects:</i> Move assigns the hash function, predicate, and maximum load factor<br/> 
from <tt>rv</tt> to the corresponding objects of <tt>a</tt>.</ins>
</td>
<td>
<ins>Linear</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2016-08-07]</i></p>

<p>
Daniel removes the previously proposed wording to work on revised wording.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2232" href="#2232">2232.</a> [CD] The <tt>char_traits</tt> specializations should declare their <tt>length()</tt>, <tt>compare()</tt>, and 
<tt>find()</tt> members constexpr</h3>
<p><b>Section:</b> 21.2.3 [char.traits.specializations] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2012-12-24 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#char.traits.specializations">issues</a> in [char.traits.specializations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>

<p><b>Addresses ES 14, US 19</b></p>

<p>
These functions have easy recursive constexpr implementations that, unfortunately, aren't efficient at runtime. 
EWG is still figuring out how to solve this problem in general (e.g., 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3444.html">N3444</a> isn't sufficient to avoid 
stack overflows in debug builds or to get the optimal assembly-based implementations at runtime), so users can't 
portably solve this problem for themselves, but implementations can use compiler-specific techniques to choose 
the right implementation inside their standard libraries.
</p>

<p>
The LWG is still undecided about whether individual implementations can add constexpr to these functions, so we 
need to add <tt>constexpr</tt> to the standard here for implementations to be able to improve this.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Open.
</p>
<p>
There are a number of people who have a strong interest in this issue not available for the telecon.
</p>
<p>
It also plays at the heart of a discussion about library freedoms for <tt>constexpr</tt> and specifying
a library that may depend on unspecified compiler intrinsics to be implementable.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Moved to NAD Future.
</p>
<p>
While it is clear that this feature can be implemented using only C++14 <tt>constexpr</tt> features,
there is real concern that we cannot call the efficient, highly optimized, C implementations of these
functions under a C++14 <tt>constexpr</tt> implementation, nor implement similar ourselves as this
typically involves use of inline <tt>asm</tt> instructions.
</p>
<p>
Clang and libc++ have some experience of using intrinsics to try to address the performance issue, but
the current intrinsics are not general enough to support <tt>char_traits</tt>.  The intrinsics support
only operations on character string literals, and the string literal is no longer visible <i>as</i> a
literal after passing as a <tt>const char *</tt> to the <tt>char_traits</tt> functions.
</p>
<p>
Additional concern was raised that these operations are unlikely to be useful anyway, as the only client
is <tt>basic_string</tt> which relies on dynamic memory allocation, and so cannot effectively be made a
literal type.  Jeffrey then pointed out the pending <tt>string_view</tt> library that will also use
<tt>char_traits</tt> and would most certainly benefit from being a literal type.
</p>

<p>
Given the choice of giving up performance on a critical library component, or requiring a compiler
intrinsic with only unsuccessful implementation experience, the consensus is to not reject this, unless
compelling implementation experience is demonstrated.  NAD Future seems the appropriate resolution.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 21.2.3.1 [char.traits.specializations.char], 21.2.3.2 [char.traits.specializations.char16_t], 
21.2.3.3 [char.traits.specializations.char32_t], and 21.2.3.4 [char.traits.specializations.wchar.t]:</p>
<blockquote><pre>
static <ins>constexpr</ins> int compare(const char_type* s1, const char_type* s2, size_t n);
static <ins>constexpr</ins> size_t length(const char_type* s);
static <ins>constexpr</ins> const char_type* find(const char_type* s, size_t n, const char_type&amp; a);
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="2236" href="#2236">2236.</a> <tt>kill_dependency</tt> unconditionally noexcept</h3>
<p><b>Section:</b> 29.2 [atomics.syn], 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-01-19 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.syn">issues</a> in [atomics.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The "magic" <tt>kill_dependency</tt> function is a function without any constraints on the template parameter <tt>T</tt> 
and is specified as
</p>

<blockquote><pre>
template &lt;class T&gt;
T kill_dependency(T y) noexcept;
</pre><blockquote>
<p>
-14- <i>Effects</i>: The argument does not carry a dependency to the return value (1.10).
<p/>
-15- <i>Returns</i>: <tt>y</tt>.
</p>
</blockquote></blockquote>

<p>
I wonder whether the unconditional <tt>noexcept</tt> is really intended here:
Assume we have some type <tt>U</tt> that has a potentially throwing move
constructor (or it has a potentially throwing copy constructor and no
move constructor), for any "normal" function template with the same
signature and the same effects (modulo the dependency magic) this
would mean that it cannot safely be declared <tt>noexcept</tt> because of the
return statement being part of the complete function call affected by
<tt>noexcept</tt> (The by-value function argument is irrelevant in this
context). In other words it seems that a function call such as
</p>

<blockquote><pre>
struct S {
  ...
  S(const S&amp; r) { if(<em>some condition</em>) throw Something(); }
  ...
};

int main() {
  S s1 = ...;
  S s2 = std::kill_dependency(s1);
}
</pre></blockquote>

<p>
would be required to call <tt>std::terminate</tt> if the copy constructor of <tt>S</tt> throws during the return 
of <tt>std::kill_dependency</tt>.
<p/>
To require copy elision for this already magic function would look like a low-hanging fruit to solve this problem, 
but this case is not covered by current copy elision rules see 12.8 p31 b1:
<p/>
"&mdash; in a return statement in a function with a class return type, when the expression is the name of a non-volatile 
automatic object (other than a function or catch-clause parameter) with the same <em>cv</em>-unqualified type as the 
function return type, the copy/move operation can be omitted by constructing the automatic object directly into the
function's return value".
<p/>
Some options come into my mind:
</p>
<ol>
<li><p>
Make the exception-specification a constrained one in regard via <tt>std::is_nothrow_move_constructible</tt>:
</p>

<blockquote><pre>
template &lt;class T&gt;
T kill_dependency(T y) noexcept(<em>see below</em>);
</pre></blockquote>

<p>
This is similar to the approach taken for function templates such as <tt>std::swap</tt>.
</p>
</li>

<li><p>
Use perfect forwarding (This needs further wording to correct the effects):
</p>

<blockquote><pre>
template &lt;class T&gt;
T&amp;&amp; kill_dependency(T&amp;&amp; y) noexcept;
</pre></blockquote>
</li>

<li><p>
Impose constraints on the template arguments in regard to throwing exceptions while copying/moving.
</p></li>

<li><p>
Keep the state as it is but possibly add a note about a call of <tt>std::terminate</tt> in above scenario.
</p></li>
</ol>

<p>
A second problem is that the current wording is not clear whether it is well-defined to call the function with
types that are reference types, such as in the following example:
</p>

<blockquote><pre>
#include &lt;atomic&gt;

int main()
{
  int a = 12;
  int&amp; b = std::kill_dependency&lt;int&amp;&gt;(a);
}
</pre></blockquote>

<p>
It is unclear what kind of dependency is killed here. This is presumably a core language problem, but could
affect the possible resolutions of the problem.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>
Recommend using a revised example:
</p>
<blockquote><pre>
int lookup(class D* p) 
{
  class E* q = p-&gt;a.load(memory_order_consume);
  int y = std::kill_dependency(q-&gt;y);
}
</pre></blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2237" href="#2237">2237.</a> <tt>&lt;cuchar&gt;</tt> macros</h3>
<p><b>Section:</b> 21.5 [c.strings] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2013-01-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in [c.strings].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Apparently C1X changes <tt>__STDC_UTF_16__</tt> and <tt>__STDC_UTF_32__</tt> from macros
defined in <tt>uchar.h</tt> (and reflected in C++ by Table 79) to be predefined by the compiler. 
Do we want to do the same?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2238" href="#2238">2238.</a> Problematic iterator-pair constructor of containers</h3>
<p><b>Section:</b> 21.5 [c.strings] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Johannes Schaub <b>Opened:</b> 2013-02-02 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.strings">active issues</a> in [c.strings].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.strings">issues</a> in [c.strings].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The non-explicit nature of the iterator-pair constructor of containers, such a
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</pre></blockquote>

<p>
can be selected in unexpected situations, leading to a hard runtime error, as demonstrated by the following example:
</p>

<blockquote><pre>
#include &lt;vector&gt;

void f(std::vector&lt;char&gt; v){ /* ... */}

int main() {
  f({"A", "B"});
}
</pre></blockquote>

<p>
The actually intended initializer-list constructor isn't feasible here, so the best match is the constructor template
</p>

<blockquote><pre>
template &lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const Allocator&amp; = Allocator());
</pre></blockquote>

<p>
This compiles, but will result in code running amok. The potential trap (that cannot be easily detected by the
library implementation) could be reduced by making this constructor explicit. It would still have the effect to 
be selected here, but the code would be ill-formed, so the programmer gets a clear message here.
</p>

<p><i>[2014-06 Rapperswil]</i></p>

<p>
JW: can't fix this, don't want to touch this, Do The Right Thing clause has been a source of tricky issues. 
only really happens with string literals, that's the only way to create an array that isn't obviously an array
<p/>
GR: want to see paper
<p/>
AM: is it only string literals, or also UDLs?
<p/>
STL: maybe, but we don't need to deal with that. This is only a problem in a very specific case 
<p/>
Leave as Open. 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2241" href="#2241">2241.</a> <tt>&lt;cstdalign&gt;</tt> and <tt>#define</tt> of <tt>alignof</tt></h3>
<p><b>Section:</b> 18.10 [support.runtime] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2013-02-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.runtime">active issues</a> in [support.runtime].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.runtime">issues</a> in [support.runtime].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 18.10 [support.runtime] p2:
</p>

<blockquote><p>
The contents of these headers are the same as the Standard C library headers [..], <tt>&lt;stdalign.h&gt;</tt>, [..]
</p></blockquote>

<p>
Since our base C standard is C99, which doesn't have a <tt>&lt;stdalign.h&gt;</tt>, the reference to a non-existing 
C header is irritating (In this context <tt>&lt;stdalign.h&gt;</tt> doesn't refer to the deprecated C++ header
<tt>&lt;stdalign.h&gt;</tt> described in D.4 [depr.c.headers]).
<p/>
Furthermore, it would be also important that it doesn not define a macro named <tt>alignof</tt>, which C11 also defines 
in this header. 
<p/>
Currently we only have the following guarantee as part of 18.10 [support.runtime] p7:
</p>

<blockquote><p>
The header <tt>&lt;cstdalign&gt;</tt> and the header <tt>&lt;stdalign.h&gt;</tt> shall not define a macro named 
<tt>alignas</tt>.
</p></blockquote>

<p>
It is unclear what the better strategy is: Striking the reference to <tt>&lt;stdalign.h&gt;</tt> in
18.10 [support.runtime] p2 or upgrading to C11 as new base C standard.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
STL: related to earlier issue on C4, <a href="lwg-active.html#2201">2201</a>, and now we get a C11 header<br/>
JY: find _Alignof as keyword C11 FDIS has four defines in stdalign.h<br/>
AM: need paper for C11 as base library we should really do that<br/>
STL: really need vendor input<br/>
STL: don't think we need to do anything right now not P1<br/>
AM: any objections to downscale to P2  (no objections)
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
Walter: this is on track to go away if we adopt Clark's paper to rebase to C11<br/>
Room: tentatively resolved; revisit after C11 paper: <a href="http://wg21.link/P0063">P0063</a><br/>
</p>

<p><i>[2016-03 Oulu]</i></p>

<p><a href="http://wg21.link/P0063">P0063</a> was adopted.</p>
<p>Change status to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2242" href="#2242">2242.</a> <tt>[uninitialized_]copy_n()</tt> defect</h3>
<p><b>Section:</b> 25.4.1 [alg.copy], 20.10.10.4 [uninitialized.copy] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Sean Parent <b>Opened:</b> 2013-02-14 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in [alg.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in [alg.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>copy_n()</tt> and <tt>uninitialized_copy_n()</tt> only return the output iterator, and not the input iterator. 
Likely the interface was simply copied from the original STL. Unfortunately the interface in the original STL contains a bug.
<p/>
<tt>copy_n()</tt> and <tt>uninitialized_copy_n()</tt> must return the resulting input iterator as well as the output 
iterator (I would suggest returning a pair). Without this, there is no way to continue reading from an actual input 
iterator &mdash; and if it is really a forward iterator, it will cost <tt>n</tt> increments to get back to where you were.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: refer to LEWG</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2243" href="#2243">2243.</a> <tt>istream::putback</tt> problem</h3>
<p><b>Section:</b> 27.7.2.3 [istream.unformatted] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2013-03-01 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 27.7.2.3 [istream.unformatted] / 34, when describing <tt>putback</tt>, it says that "<tt>rdbuf-&gt;sputbackc()</tt>" 
is called. The problem are not the obvious typos in the expression, but the fact that it may lead to different 
interpretations, since nowhere is specified what the required argument to <tt>sputbackc</tt> is.
<p/>
It can be guessed to be "<tt>rdbuf()-&gt;sputbackc(c)</tt>", but "<tt>rdbuf()-&gt;sputbackc(char_type())</tt>" or 
just anything would be as conforming (or non-confoming) as the first guess.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2245" href="#2245">2245.</a> <tt>packaged_task::reset()</tt> memory allocation</h3>
<p><b>Section:</b> 30.6.9.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-03-05 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The effects of <tt>packaged_task::reset()</tt> result in memory allocation, but
don't allow a user to provide an allocator.
<p/>
<tt>packaged_task::reset()</tt> needs to be overloaded like so:
</p>

<blockquote><pre>
template&lt;class Alloc&gt;  
void reset(const Alloc&amp;);
</pre></blockquote>

<p>
Alternatively, the effects of <tt>reset()</tt> need to require the same allocator is used 
as at construction, which would require the constructor to store the allocator for later use.
<p/>
I like to remark that GCC at the moment uses the second option, i.e. the allocator passed to the constructor 
(if any) is used to create the new shared state, because this didn't require any change to the
interface.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>

<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
No strong opinions in SG1, and this is really an LWG issue.  Back to you.
</p>

<p><i>[2016-08-02 Chicago, Billy O'Neal comments and suggests concrete wording]</i></p>

<p>
Talked this over with Alasdair, who says there's little desire to allow the <tt>packaged_task</tt> to 
be change allocators after initial construction, making what libstdc++ does already the "right thing." 
A clarification note is still necessary to indicate that the allocator supplied to the 
<tt>allocator_arg_t</tt> constructor is to be used.
</p>
<p>Wed PM: Move to Tentatively Ready</p>

<p><i>[2016-09-08]</i></p>

<p>
Alisdair requests change to Review.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606
</p>

<ol>
<li><p>Change 30.6.9.1 [futures.task.members] as indicated:</p>

<blockquote>
<pre>
void reset();
</pre>
<blockquote>
<p>
-22- <i>Effects:</i> 
</p>
<ul>
<li><p><ins>if the shared state associated with <tt>*this</tt> was created via the <tt>packaged_task(F&amp;&amp; f)</tt> 
constructor, a</ins><del>A</del>s if <tt>*this = packaged_task(std::move(f))</tt>, where <tt>f</tt> is the task stored in 
<tt>*this</tt>.</p></li>
<li><p><ins>if the shared state associated with <tt>*this</tt> was created via the 
<tt>packaged_task(allocator_arg_t, Allocator&amp; a, F&amp;&amp;)</tt> constructor, as if 
<tt>*this = packaged_task(allocator_arg, a, std::move(f))</tt>, where <tt>a</tt> is the allocator used to allocate 
the shared state associated with <tt>*this</tt>, and <tt>f</tt> is the task stored in <tt>*this</tt>.</ins></p></li>
</ul>
<p>
[<i>Note:</i> This constructs a new shared state for <tt>*this</tt>. The old state is abandoned 
(30.6.4). &mdash; <i>end note</i>]
<p/>
-23- <i>Throws:</i>
</p>
<ul>
<li><p><ins>if no allocator was used,</ins> <tt>bad_alloc</tt> if memory for the new shared state could not be allocated.</p></li>
<li><p><ins>if an allocator was used, any exception thrown by <tt>std::allocator_traits&lt;Allocator&gt;::template 
rebind_traits&lt;<i>unspecified</i>&gt;::allocate</tt>.</ins></p></li>
<li><p>any exception thrown by the move constructor of the task stored in the shared state.</p></li>
<li><p><tt>future_error</tt> with an error condition of <tt>no_state</tt> if <tt>*this</tt> has no shared state.</p></li>
</ul>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2248" href="#2248">2248.</a> <tt>numeric_limits::is_iec559</tt> misnamed</h3>
<p><b>Section:</b> 18.3.2 [limits] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2013-03-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#limits">issues</a> in [limits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This member should probably be named "is_ieee754". Or at least the standard should explain that IEC-559 no longer exists, 
and that it's been superseded by IEEE-754.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2256" href="#2256">2256.</a> On <tt>vector</tt> iterator invalidation</h3>
<p><b>Section:</b> 23.3.11.5 [vector.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2013-04-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.modifiers">active issues</a> in [vector.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>

<p>
23.3.11.5 [vector.modifiers]/p3 says:
</p>
<blockquote><pre>
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>
<i>Effects</i>: Invalidates iterators and references at or after the point of the erase.
</p>
</blockquote></blockquote>
<p>
Consider this example:
</p>
<blockquote><pre>
#include &lt;vector&gt;
#include &lt;cassert&gt;

int main()
{
  typedef std::vector&lt;int&gt; C;
  C c = {1, 2, 3, 4};
  C::iterator i = c.begin() + 1;
  C::iterator j = c.end() - 1;
  assert(*i == 2);
  assert(*j == 4);
  c.erase(c.begin());
  <span style="color:#C80000;font-weight:bold">assert(*i == 3); // Why is this not perfectly fine?!</span>
}
</pre></blockquote>
<p>
Why has the iterator <tt>i</tt> been invalidated? It still refers to a perfectly reasonable, fully constructed object. 
If <tt>vector::iterator</tt> were to be implemented as a pointer (which is legal), it is not possible for that last 
line to do anything but run fine.
<p/>
The iterator <tt>j</tt> on the other hand now points at end, and any iterators that may now point beyond <tt>end()</tt>, 
into uninitialized memory, are clearly invalid.
<p/>
But why do we say that an iterator that <em>must</em> point to a valid object is invalid? This looks to me like we 
simply got sloppy in our specification.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This is related to <a href="lwg-defects.html#2698">2698</a>
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2260" href="#2260">2260.</a> Missing requirement for <tt>Allocator::pointer</tt></h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-05-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For an allocator <tt>A&lt;T&gt;</tt> which defines <tt>A&lt;T&gt;::pointer</tt> to a class type,
i.e. not <tt>T*</tt>, I see no requirement that <tt>A&lt;T&gt;::pointer</tt> is convertible to
<tt>A&lt;U&gt;::pointer</tt>, even if <tt>T*</tt> is convertible to <tt>U*</tt>.  Such conversions are
needed in containers to convert from e.g. <tt>ListNodeBase*</tt> to <tt>ListNode&lt;T&gt;*</tt>.
</p>

<p>The obvious way to do such conversions appears to be
<tt>pointer_traits::pointer_to()</tt>, but that's ill-formed if the static
member function <tt>A&lt;T&gt;::pointer::pointer_to()</tt> doesn't exist and the
allocator requirements don't mention that function, so you need to
cast <tt>A&lt;T&gt;::pointer</tt> to <tt>A&lt;T&gt;::void_pointer</tt> then cast that to
<tt>A&lt;U&gt;::pointer</tt>.
</p>

<p>
Is converting via <tt>void_pointer</tt> really intended, or are we missing a requirement that 
<tt>pointer_traits&lt;A&lt;T&gt;::pointer&gt;::pointer_to()</tt> be well-formed?
</p>

<p>Proposed resolution:</p>

<p>Add to the Allocator requirements table the following requirement:</p>

<blockquote>
<p>
The expression <tt>pointer_traits&lt;XX::pointer&gt;::pointer_to(r)</tt> is well-defined.
</p>
</blockquote>

<p><i>[2013-09 Chicago]</i></p>

<p>
Pablo to come back with proposed wording
</p>

<p><i>[2015-07 Telecom]</i></p>

<p>
Marshall to ping Pablo for proposed wording and disable current wording.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class = "note">
<ol>
<li><p>
Edit Table 28 as indicated:
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z)</tt>
</td>
<td>
<tt>X::const_pointer</tt>
</td>
<td>
<tt>static_cast&lt;X::const_pointer&gt;(z) == q</tt>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<ins><tt>pointer_traits&lt;X::pointer&gt;::pointer_to(r)</tt></ins>
</td>
<td>
<ins><tt>X::pointer</tt></ins>
</td>
<td>
&nbsp;
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>


</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2261" href="#2261">2261.</a> Are containers required to use their '<tt>pointer</tt>' type internally?</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-05-14 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements">active issues</a> in [container.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Is a container <tt>C</tt> only supposed to refer to allocated memory (blocks of
contiguous storage, nodes, etc.) through objects of type <tt>C::pointer</tt>
rather than <tt>C::value_type*</tt>?
</p>

<p>
I don't see anything explicitly requiring this, so a container could
immediately convert the result of <tt>get_allocator().allocate(1)</tt> to a
built-in pointer of type <tt>value_type*</tt> and only deal with the built-in
pointer until it needs to deallocate it again, but that removes most
of the benefit of allowing allocators to use custom pointer types.
</p>

<p><i>[2014-06-12, Jonathan comments]</i></p>

<p>
This issue is basically the same issue as LWG <a href="lwg-active.html#1521">1521</a>, which agrees it's an issue, 
to be dealt with in the future, so I request that <a href="lwg-active.html#2261">2261</a> not be closed as a dup 
unless we reopen <a href="lwg-active.html#1521">1521</a>.
</p>

<p><i>[2016-08, Zhihao comments]</i></p>

<p>The <tt>pointer</tt> types are not exposed in the container interface,
and we consider that the memory allocation constraints
"all containers defined in this clause obtain memory using an
allocator" already implies the reasonable expectation.  We
propose the fix as non-normative.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: General agreement on direction, Alisdair and Billy to update wording</p>
<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<p><i>[Drafting notes: if people prefer this to be normative, strip
the "Note" markups.]</i></p>


<p>Modify 23.2.1 [container.requirements.general]/8 as indicated:</p>

<blockquote><p>
Unless otherwise specified, all containers defined in this clause obtain
memory using an allocator (see 17.6.3.5 [allocator.requirements]).
<ins>[<i>Note:</i> In particular, containers and iterators
do not store references to allocated elements other than through the
allocator's pointer type, i.e., as objects of type <tt><i>P</i></tt> or
<tt>pointer_traits&lt;<i>P</i>&gt;::template rebind&lt;<i>unspecified</i>&gt;</tt>,
where <tt><i>P</i></tt> is
<tt>allocator_traits&lt;allocator_type&gt;::pointer</tt>. &mdash; <i>end note</i>]</ins>
</p></blockquote>





<hr>
<h3><a name="2262" href="#2262">2262.</a> Requirement for <tt>unique_ptr&lt;T&gt;::get_deleter()(p)</tt> to be able to destroy the <tt>unique_ptr</tt></h3>
<p><b>Section:</b> 20.11.1.2 [unique.ptr.single] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rob Desbois <b>Opened:</b> 2013-05-15 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unique.ptr.single">issues</a> in [unique.ptr.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N3337 20.11.1.2.5 [unique.ptr.single.modifiers] contains 2 non-normative notes stating:
</p>

<blockquote>
<p>
[para 4]: &quot;The order of these operations is significant because the call to <tt>get_deleter()</tt> 
may destroy <tt>*this</tt>.&quot;
</p>
<p>
[para 5]: &quot;The postcondition does not hold if the call to <tt>get_deleter()</tt> destroys <tt>*this</tt> since 
<tt>this->get()</tt> is no longer a valid expression.&quot;
</p>
</blockquote>

<p>
It seems this wording was created to resolve <a href="lwg-defects.html#998">998</a> due to the possibility that a <tt>unique_ptr</tt> may be 
destroyed through deletion of its stored pointer where that directly or indirectly refers to the same <tt>unique_ptr</tt>. 
If <tt>unique_ptr</tt> is required to support circular references then it seems this must be normative text: an implementation 
is currently allowed to operate on <tt>*this</tt> after the assignment and deletion specified in para 4, since this is only 
'disallowed' by the non-normative note.
</p>

<p>I propose the following draft rewording:</p>

<p>
[para 4]: <i>Effects</i>: assigns <tt>p</tt> to the stored pointer, and then if the old value of the stored pointer, <tt>old_p</tt>, was not
equal to <tt>nullptr</tt>, calls <tt>get_deleter()(old_p)</tt>. <ins>No operation shall be performed after the call to 
<tt>get_deleter()(old_p)</tt> that requires <tt>*this</tt> to be valid, because the deletion may destroy <tt>*this</tt> if it is 
referred to directly or indirectly by the stored pointer.</ins> <del>[<i>Note:</i> The order of these operations is significant
because the call to <tt>get_deleter()</tt> may destroy <tt>*this</tt>. &mdash; <i>end note</i>]</del>
<p/>
[para 5]: <i>Postconditions</i>: <ins>If the call <tt>get_deleter()(old_p)</tt> destroyed <tt>*this</tt>, none. Otherwise,</ins> 
<tt>get() == p</tt>. <del>[<i>Note:</i> The postcondition does not hold if the call to <tt>get_deleter()</tt>
destroys <tt>*this</tt> since <tt>this->get()</tt> is no longer a valid expression. &mdash; <i>end note</i>]</del>
</p>

<p>
I expect it will also be necessary to amend the requirements for a deleter, so in addition:
</p>

<p>
20.11.1.2 [unique.ptr.single] [para 1]: The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>Where <tt>D</tt> is not an lvalue reference type, <tt>d(ptr)</tt> shall be valid if <tt>ptr</tt> 
refers directly or indirectly to the invoking <tt>unique_ptr</tt> object.</ins>
</p>

<p><i>[2013-10-05, Stephan T. Lavavej comments and provides alternative wording]</i></p>

<p>
In Chicago, we determined that the original proposed change to 20.11.1.2 [unique.ptr.single]/1 was insufficient, because 
<tt>d</tt> might be a reference to a deleter functor that's destroyed during self-destruction.
<p/>
We believed that 20.11.1.2.5 [unique.ptr.single.modifiers]/4 was already sufficiently clear. The Standard occasionally prevents 
implementations of <tt>X</tt> from doing various things, through the principle of "nothing allows <tt>X</tt> to fail in that situation".  
For example, <tt>v.push_back(v[0])</tt> is required to work for non-empty vectors because nothing allows that to fail. In this case, 
the intent to allow self-destruction is already clear.
<p/>
Additionally, we did not believe that 20.11.1.2.5 [unique.ptr.single.modifiers]/5 had to be changed. The current note is slightly 
squirrely but it does not lead to confusion for implementers or users.
</p>

<p>
Previous resolution from Rob Desbois:
</p>
<blockquote class="note">
<ol>
<li>
<p>
Edit 20.11.1.2 [unique.ptr.single] p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>Where <tt>D</tt> is not an lvalue reference type, <tt>d(ptr)</tt> shall be valid if <tt>ptr</tt> 
refers directly or indirectly to the invoking <tt>unique_ptr</tt> object.</ins>
</p></blockquote>
</li>

<li>
<p>
Edit 20.11.1.2.5 [unique.ptr.single.modifiers] p4+5 as indicated:
</p>
<blockquote><pre>
void reset(pointer p = pointer()) noexcept;
</pre><blockquote>
<p>
-3- <i>Requires:</i> The expression <tt>get_deleter()(get())</tt> shall be well formed, shall have well-defined behavior,
and shall not throw exceptions.
<p/>
-4- <i>Effects:</i> assigns <tt>p</tt> to the stored pointer, and then if the old value of the stored pointer, <tt>old_p</tt>, was not
equal to <tt>nullptr</tt>, calls <tt>get_deleter()(old_p)</tt>. <ins>No operation shall be performed after the call to 
<tt>get_deleter()(old_p)</tt> that requires <tt>*this</tt> to be valid, because the deletion may destroy <tt>*this</tt> if it is 
referred to directly or indirectly by the stored pointer.</ins> <del>[<i>Note:</i> The order of these operations is significant
because the call to <tt>get_deleter()</tt> may destroy <tt>*this</tt>. &mdash; <i>end note</i>]</del>
<p/>
-5- <i>Postconditions:</i> <ins>If the call <tt>get_deleter()(old_p)</tt> destroyed <tt>*this</tt>, none. Otherwise,</ins> 
<tt>get() == p</tt>. <del>[<i>Note:</i> The postcondition does not hold if the call to <tt>get_deleter()</tt>
destroys <tt>*this</tt> since <tt>this->get()</tt> is no longer a valid expression. &mdash; <i>end note</i>]</del>
</p>
</blockquote></blockquote>
</li>
</ol>

</blockquote>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li>
<p>
Edit 20.11.1.2 [unique.ptr.single] p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.10), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins><tt>d(ptr)</tt> shall be valid even if it triggers the destruction of <tt>d</tt> or (if 
<tt>D</tt> is an lvalue reference to function object type) the function object that <tt>d</tt> refers to.</ins>
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-05, Lenexa]</i></p>

<p>
After some discussion in Lenexa there was some wavering on if the added sentence is necessary. Here is example code that 
demonstrates why the extra sentence is necessary. In this example the call to <tt>d(ptr)</tt> is valid, however the deleter 
references <tt>*this</tt> after destructing its element:
</p>
<blockquote><pre>
#include &lt;cassert&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;

class Deleter
{
    int state_ = 0;

    enum
    {
        destructed            = -4,
        self_move_assigned    = -3,
        move_assigned_from    = -2,
        move_constructed_from = -1
    };
public:
    ~Deleter() {state_ = destructed;}

    Deleter() = default;
    Deleter(Deleter const&amp;) = default;
    Deleter&amp; operator=(Deleter const&amp;) = default;

    Deleter(Deleter&amp;&amp; a) noexcept
        : state_(a.state_)
    {a.state_ = move_constructed_from;}

    Deleter&amp; operator=(Deleter&amp;&amp; a) noexcept
    {
        if (this == &amp;a)
            state_ = self_move_assigned;
        else
        {
            state_ = a.state_;
            a.state_ = move_assigned_from;
        }
        return *this;
    }

    Deleter(int state)
        : state_(state)
    {
        assert(state &gt;= 0);
    }

    template &lt;class T&gt;
    void
    operator()(T* t) const
    {
        std::cout &lt;&lt; "Deleter beginning operator()(T*)\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; *this &lt;&lt; '\n';
        std::cout &lt;&lt; "Deleter about to destruct the X.\n";
        delete t;
        std::cout &lt;&lt; "Deleter has destructed the X.\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; *this &lt;&lt; '\n';
        std::cout &lt;&lt; "Deleter ending operator()(T*)\n";
    }

    friend
    std::ostream&amp;
    operator&lt;&lt;(std::ostream&amp; os, const Deleter&amp; a)
    {
        switch (a.state_)
        {
        case destructed:
            os &lt;&lt; "**destructed**";
            break;
        case self_move_assigned:
            os &lt;&lt; "self_move_assigned";
            break;
        case move_assigned_from:
            os &lt;&lt; "move_assigned_from";
            break;
        case move_constructed_from:
            os &lt;&lt; "move_constructed_from";
            break;
        default:
            os &lt;&lt; a.state_;
            break;
        }
        return os;
    }
};

struct X
{
    Deleter deleter_{1};
};

int main()
{
    auto xp = new X;
    {
        std::unique_ptr&lt;X, Deleter&amp;&gt; p(xp, xp-&gt;deleter_);
        std::cout &lt;&lt; "unique_ptr is constructed.\n";
        std::cout &lt;&lt; "The deleter = " &lt;&lt; p.get_deleter() &lt;&lt; '\n';
        std::cout &lt;&lt; "Destructing unique_ptr...\n";
    }
    std::cout &lt;&lt; "unique_ptr is destructed.\n";
}
</pre></blockquote>
<p>
Which outputs:
</p>
<blockquote>
<pre>
unique_ptr is constructed.
The deleter = 1
Destructing unique_ptr...
Deleter beginning operator()(T*)
The deleter = 1
Deleter about to destruct the X.
Deleter has destructed the X.
The deleter = **destructed**
Deleter ending operator()(T*)
unique_ptr is destructed.
</pre>
</blockquote>
<p>
The line "<tt>The deleter = **destructed**</tt>" represents the deleter referencing itself after it has been destructed by the 
<tt>d(ptr)</tt> expression, but prior to that call returning.
<p/>
Suggested alternative to the current proposed wording:
</p>
<blockquote>
<p>
The expression <tt>d(ptr)</tt> shall not refer to the object <tt>d</tt> after it executes <tt>ptr-&gt;~T()</tt>.
</p>
</blockquote>

<p><i>[2015-07, Telecom]</i></p>

<p>
Geoffrey: Deleter may or may not execute ~T().<br/>
Alisdair: After the destructor after the element has run. Say it in words instead of code. <br/>
Howard will provide updated wording. Perhaps need both normative and non-normative wording.<br/>
</p>

<p><i>[2015-08-03, Howard updates P/R per telecon discussion.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4431.</p>

<ol>
<li>
<p>
Edit 20.11.1.2 [unique.ptr.single] p1 as indicated:
</p>
<blockquote><p>
The default type for the template parameter <tt>D</tt> is <tt>default_delete</tt>. 
A client-supplied template argument <tt>D</tt> shall be a function object type (20.9), lvalue-reference to function, or 
lvalue-reference to function object type for which, given a value <tt>d</tt> of type <tt>D</tt> and a value <tt>ptr</tt> of type 
<tt>unique_ptr&lt;T, D&gt;::pointer</tt>, the expression <tt>d(ptr)</tt> is valid and has the effect of disposing of the pointer 
as appropriate for that deleter. <ins>The expression <tt>d(ptr)</tt>, if it destructs the object referred to by <tt>ptr</tt>,
shall not refer to the object <tt>d</tt> after it destructs <tt>*ptr</tt>.
[<i>Note:</i> The object being destructed may control the lifetime of <tt>d</tt>. &mdash; <i>end note</i>]</ins>
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2265" href="#2265">2265.</a> 29.3p9 appears to rule out some acceptable executions</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Brian Demsky <b>Opened:</b> 2013-06-17 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I believe that the following variation on IRIW should admit executions in
which <tt>c1 = d1 = 5</tt> and <tt>c2 = d2 = 0</tt>.  If this is allowed, then what is sequence of
program evaluations for 29.3 [atomics.order] p9 that justifies the store to <tt>z</tt>?  It seems that
29.3 [atomics.order] p9 should not allow this execution because one of the stores to <tt>x</tt> or <tt>y</tt> has
to appear earlier in the sequence, each of the <tt>fetch_adds</tt> reads the previous load in the thread (and thus must 
appear later in the sequence), and 29.3 [atomics.order] p9 states that each load must read from the last prior 
assignment in the sequence.
</p>

<blockquote><pre>
atomic_int x;
atomic_int y;
atomic_int z;
int c1, c2, d1, d2;

static void a(void* obj)
{
  atomic_store_explicit(&amp;x, 5, memory_order_relaxed); 
}

static void b(void* obj)
{
  atomic_store_explicit(&amp;y, 5, memory_order_relaxed); 
}

static void c(void* obj)
{
  c1 = atomic_load_explicit(&amp;x, memory_order_relaxed);
  // this could also be an atomic load if the address depends on c1:
  c2 = atomic_fetch_add_explicit(&amp;y, c1, memory_order_relaxed);  
}

static void d(void* obj)
{
  d1 = atomic_load_explicit(&amp;y, memory_order_relaxed);
  d2 = atomic_fetch_add_explicit(&amp;x, d1, memory_order_relaxed); 
}

int user_main(int argc, char** argv)
{
  thrd_t t1, t2, t3, t4;

  atomic_init(&amp;x, 0);
  atomic_init(&amp;y, 0);

  printf("Main thread: creating 4 threads\n");
  thrd_create(&amp;t1, (thrd_start_t)&amp;a, NULL);
  thrd_create(&amp;t2, (thrd_start_t)&amp;b, NULL);
  thrd_create(&amp;t3, (thrd_start_t)&amp;c, NULL);
  thrd_create(&amp;t4, (thrd_start_t)&amp;d, NULL);

  thrd_join(t1);
  thrd_join(t2);
  thrd_join(t3);
  thrd_join(t4);
  printf("c1=%d c2=%d\n",c1,c2);
  printf("d1=%d d2=%d\n",d1,d2);

  // Can this store write 1000 (i.e., c1=d1=5, c2=d2=0)?
  atomic_store(&amp;z, (c1+d1)*100+c2+d2);

  printf("Main thread is finished\n");

  return 0;
}
</pre></blockquote>

<p>
It seems that the easiest fix is to allow a load in 29.3 [atomics.order] p9 to read from any prior
store in the evaluation order.
<p/>
That said, I would personally advocate the following:
It seems to me that C/C++ atomics are in a bit of different situation than Java
because:
</p>
<ol>
<li><p>People are expected to use relaxed C++ atomics in potentially racy
situations, so it isn't clear that semantics as complicated as the JMM's
causality would be sane.
</p></li>
<li><p>People who use C/C++ atomics are likely to be experts and use them in a
very controlled fashion. I would be really surprised if compilers would find
any real wins by optimizing the use of atomics.
</p></li>
</ol>
<p>
Why not do something like:
<p/>
There is satisfaction DAG of all program evaluations. Each evaluation
observes the values of variables as computed by some prior assignment in
the DAG.
<p/>
There is an edge <tt>x-&gt;y</tt> between two evaluations <tt>x</tt> and <tt>y</tt> if:
</p>
<ol>
<li><p>the evaluation <tt>y</tt> observes a value computed by the evaluation <tt>x</tt> or
</p></li>
<li><p>the evaluation <tt>y</tt> is an atomic store, the evaluation <tt>x</tt> is an atomic load, and
there is a condition branch c that may depend (intrathread dependence) on <tt>x</tt>
and <tt>x-sb-&gt;c</tt> and <tt>c-sb-&gt;y</tt>.
</p></li>
</ol>
<p>
This seems to allow reordering of relaxed atomics that processors do without
extra fence instructions, allows most reorderings by the compiler, and gets
rid of satisfaction cycles.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>


<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
This was partially addressed (weasel-worded) in C++14 (See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3786.htm">N3786</a>).
The remainder is an open research problem.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3710.html">N3710</a> outlines a "solution" that doesn't have a consensus behind it because it costs performance.  We have no better solution at the moment.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2267" href="#2267">2267.</a> <tt>partial_sort_copy</tt> underspecified for ranges of two different types</h3>
<p><b>Section:</b> 25.5.1.4 [partial.sort.copy] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern  <b>Opened:</b> 2013-06-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The signature of this function is:
</p>

<blockquote><pre>
template&lt;class InputIterator, class RandomAccessIterator&gt;
RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
                  RandomAccessIterator result_first,
                  RandomAccessIterator result_last);

</pre></blockquote>

<p>
(and the usual overload for an explicitly provided comparison function). The standard says nothing about requirements 
in the case where the input type (<tt>iterator_traits&lt;InputIterator&gt;::value_type</tt>) and the output type 
(<tt>iterator_traits&lt;RandomAccessIterator&gt;::value_type</tt>) are different.
<p/>
Presumably the input type must be convertible to the output type. What's less clear is what the requirements are on 
the comparison operator. Does the algorithm only perform comparisons on two values of the output type, or does it also 
perform comparisons on values of the input type, or might it even perform heterogeneous comparisons?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2269" href="#2269">2269.</a> Container iterators and argument-dependent lookup</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2013-06-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following code snippet:
</p>

<blockquote><pre>
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
  std::vector&lt;int&gt; v1(100, 3);
  std::vector&lt;int&gt; v2(100);
  copy(v1.begin(), v1.end(), v2.begin());
}
</pre></blockquote>

<p>
It compiles without error on my desktop. Is it required to? I can't find evidence from the standard that it is. 
In my test <tt>std::copy</tt> was found by argument-dependent lookup because the implementation I used made 
<tt>std::vector&lt;int&gt;::iterator</tt> a user-defined type defined in namespace <tt>std</tt>. But the standard 
only requires <tt>std::vector&lt;int&gt;::iterator</tt> to be an implementation specified random access iterator 
type. I can't find anything requiring it to be a user-defined type at all (and in fact there are reasonable implementation 
where it isn't), let alone a user defined type defined in a specific namespace.
</p>

<p>
Since the defining namespace of container iterators is visible to users, should the standard say anything about what 
that namespace is?
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2286" href="#2286">2286.</a> <tt>stringbuf::underflow()</tt> underspecified</h3>
<p><b>Section:</b> 27.8.2.4 [stringbuf.virtuals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Sergey Zubkov <b>Opened:</b> 2013-08-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#stringbuf.virtuals">issues</a> in [stringbuf.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 27.8.2.4 [stringbuf.virtuals]/1, <tt>basic_stringbuf::underflow()</tt> is specified to unconditionally 
return <tt>traits::eof()</tt> when a read position is not available.
<p/>
The semantics of <tt>basic_stringbuf</tt> require, and existing libraries implement it so that this function makes 
a read position available if possible to do so, e.g. if some characters were inserted into the stream since the 
last call to <tt>overflow()</tt>, resulting in <tt>pptr() &gt; egptr()</tt>. Compare to the conceptually similar 
D.5.1.3 [depr.strstreambuf.virtuals]/15.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>

<li><p>Change 27.8.2.4 [stringbuf.virtuals] as indicated:</p>

<blockquote>
<pre>
int_type underflow();
</pre><blockquote>
<p>
-1- <i>Returns:</i> If the input sequence has a read position available <ins>or the function makes a read position available 
(as described below)</ins>, returns <tt>traits::to_int_type(*gptr())</tt>. Otherwise, returns <tt>traits::eof()</tt>. Any 
character in the underlying buffer which has been initialized is considered to be part of the input sequence.
<p/>
<ins>-?- The function can make a read position available only if <tt>(mode &amp; ios_base::in) != 0</tt> and if the write 
next pointer <tt>pptr()</tt> is not null and is greater than the current read end pointer <tt>egptr()</tt>. To make a read 
position available, the function alters the read end pointer <tt>egptr()</tt> to equal <tt>pptr()</tt>.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2289" href="#2289">2289.</a> <tt>constexpr</tt> guarantees of defaulted functions still insufficient</h3>
<p><b>Section:</b> 20.4.2 [pairs.pair], 20.5.2.1 [tuple.cnstr], 20.17.5 [time.duration] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-09 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">N3471</a> and
some similar <tt>constexpr</tt> papers, specific wording was added to <tt>pair</tt>, <tt>tuple</tt>, and other templates
that were intended to impose implementation constraints that ensure that the observable <tt>constexpr</tt> "character"
of a defaulted function template is solely determined by the required expressions of the user-provided types when instantiated,
for example:
</p>

<blockquote><p>
The defaulted move and copy constructor, respectively, of pair shall be a <tt>constexpr</tt> function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function.
</p></blockquote>

<p>
This wording doesn't require enough, especially since the core language via CWG 1358 does now support <tt>constexpr</tt>
function template instantiations, even if such function cannot appear in a constant expression (as specified in 5.20 [expr.const]) 
or as a constant initializer of that object (as specified in  [basic.start.init]). The wording should be 
improved and should require valid uses in constant expressions and as constant initializers instead.
</p>

<p><i>[Lenexa 2015-05-05]</i></p>

<p>STL : notice order of move/copy and copy/move with "respectively".</p>
<p>General word-smithing; ask for updated wording</p>
<p>Are we happy with this with changes we are suggesting?</p>
<p>unanimous</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 20.4.2 [pairs.pair] p2 as indicated:</p>

<blockquote>
<p>
-2- <del>The defaulted move and copy constructor, respectively, of pair shall be a <tt>constexpr</tt> function if and only if
all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function</del><ins>An invocation of the move or copy constructor of <tt>pair</tt> shall be a constant expression 
(5.20 [expr.const]) if all required element-wise initializations would be constant expressions. An invocation of the 
move or copy constructor of <tt>pair</tt> shall be a constant initializer for that <tt>pair</tt> object ( [basic.start.init])
if all required element-wise initializations would be constant initializers for the respective subobjects</ins>.
</p>
</blockquote>
</li>

<li><p>Change 20.5.2.1 [tuple.cnstr] p2 as indicated:</p>

<blockquote>
<p>
-2- <del>The defaulted move and copy constructor, respectively, of <tt>tuple</tt> shall be a <tt>constexpr</tt> function if 
and only if all required element-wise initializations for copy and move, respectively, would satisfy the requirements for
a <tt>constexpr</tt> function. The defaulted move and copy constructor of <tt>tuple&lt;&gt;</tt> shall be <tt>constexpr</tt> 
functions</del><ins>An invocation of the move or copy constructor of <tt>tuple</tt> shall be a constant expression (5.20 [expr.const])
if all required element-wise initializations would be constant expressions. An invocation of the move or copy constructor of 
<tt>tuple</tt> shall be a constant initializer for that <tt>tuple</tt> object ( [basic.start.init]) if all 
required element-wise initializations would be constant initializers for the respective subobjects. An invocation of the 
move or copy constructor of <tt>tuple&lt;&gt;</tt> shall be a constant expression, or a constant initializer for that 
<tt>tuple&lt;&gt;</tt> object, respectively, if the function argument would be constant expression</ins>.
</p>
</blockquote>
</li>

<li><p>Change 20.17.5 [time.duration] p7 as indicated:</p>

<blockquote>
<p>
-7- <i>Remarks:</i> <del>The defaulted copy constructor of duration shall be a <tt>constexpr</tt> function if and only if
the required initialization of the member <tt>rep_</tt> for copy and move, respectively, would satisfy the
requirements for a <tt>constexpr</tt> function.</del><ins>An invocation of the copy constructor of <tt>duration</tt> shall 
be a constant expression (5.20 [expr.const]) if the required initialization of the member <tt>rep_</tt> would be a constant expression.
An invocation of the copy constructor of <tt>duration</tt> shall be a constant initializer for that <tt>duration</tt> object 
( [basic.start.init]) if the required initialization of the member <tt>rep_</tt> would be constant initializers 
for this subobject</ins>.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2290" href="#2290">2290.</a> Top-level "SFINAE"-based constraints should get a separate definition in Clause 17</h3>
<p><b>Section:</b> 20.15 [meta] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-02 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current library specification uses at several places wording that is intended to refer to
core language template deduction failure at the top-level of expressions (aka "SFINAE"), for example:
</p>

<blockquote><p>
The expression <tt>declval&lt;T&gt;() = declval&lt;U&gt;()</tt> is well-formed when treated as an unevaluated operand (Clause 5). 
Access checking is performed as if in a context unrelated to <tt>T</tt> and <tt>U</tt>. Only the validity of the immediate context 
of the assignment expression is considered. [<i>Note:</i> The compilation of the expression can result in side effects 
such as the instantiation of class template specializations and function template specializations, the generation of
implicitly-defined functions, and so on. Such side effects are not in the "immediate context" and can result in the program
being ill-formed. &mdash; <i>end note</i>]
</p></blockquote>

<p>
Similar wording can be found in the specification of <tt>result_of</tt>, <tt>is_constructible</tt>, and <tt>is_convertible</tt>,
being added to resolve an NB comment by LWG <a href="lwg-defects.html#1390">1390</a> and <a href="lwg-defects.html#1391">1391</a> through 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">N3142</a>.
<p/>
This wording is necessary to limit speculative compilations needed to implement these traits, but it is also lengthy and repetitive.
</p>

<p><i>[2014-05-19, Daniel suggests a descriptive term]</i></p>

<p>
<b>constrictedly well-formed expression</b>:
<p/>
An expression <em>e</em> depending on a set of types <tt>A1</tt>, ..., <tt>An</tt> which is well-formed when treated as 
an unevaluated operand (Clause 5). Access checking is performed as if in a context unrelated to <tt>A1</tt>, ..., 
<tt>An</tt>. Only the validity of the immediate context of <em>e</em> is considered. [<i>Note:</i> The compilation of 
the expression can result in side effects such as the instantiation of class template specializations and function 
template specializations, the generation of implicitly-defined functions, and so on. Such side effects are not in the 
"immediate context" and can result in the program being ill-formed. &mdash; <i>end note</i>]
</p>

<p><i>[2014-05-20, Richard and Jonathan suggest better terms]</i></p>

<p>
Richard suggested "locally well-formed"
<p/>
Jonathan suggested "contextually well-formed" and then "The expression ... is valid in a contrived argument
deduction context"
</p>

<p><i>[2014-06-07, Daniel comments and improves wording]</i></p>

<p>
The 2014-05-19 suggestion did only apply to expressions, but there are two important examples that are not expressions, but instead
are involving an <em>object definition</em> (<tt>std::is_constructible</tt>) and a <em>function definition</em> 
(<tt>std::is_convertible</tt>), respectively, instead. Therefore I suggest to rephrase the usage of "expression" into "program 
construct" in the definition of Jonathan's suggestion of "valid in a contrived argument deduction context".
<p/>
I would like to point out that given the new definition of "valid in a contrived argument deduction context", there are several other 
places of the Library specification that could take advantage of this wording to improve the existing specification, such as 
20.14.12.2 [func.wrap.func] p2, most functions in 20.10.8.2 [allocator.traits.members], and the <tt>**Insertable</tt>, 
<tt>EmplaceConstructible</tt>, and <tt>Erasable</tt> definitions in 23.2.1 [container.requirements.general], but given that
these are not fully described in terms of the aforementioned wording <em>yet</em>, I would recommend to fix them by a separate issue 
once the committee has agreed on following the suggestion presented by this issue.
</p>

<p><i>[2015-05-05 Lenexa: Move to Open]</i></p>

<p>...</p>
<p>MC: I think we like the direction but it isn't quite right: it needs some work</p>
<p>JW: I'm prepared to volunteer to move that further, hopefully with the help of Daniel</p>
<p>Roger Orr: should this be Core wording because it doesn't really have anything to do with libraries - the term could then just be used here</p>
<p>AM: Core has nothing to deal with that, though</p>
<p>HT: it seems there is nothing to imply that allows dropping out with an error - maybe that's a separate issue</p>
<p>MC: I'm not getting what you are getting at: could you write an issue? - any objection to move to Open?</p>
<p>...</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Add the following new definition to 17.3 [definitions] as indicated:</p>

<p>
<ins><b>valid in a contrived argument deduction context</b> [defns.valid.contr.context]</ins>
<p/>
<ins>A program construct <em>c</em> depending on a set of types <tt>A1</tt>, ..., <tt>An</tt>, and treated as 
an unevaluated operand (Clause 5) when <em>c</em> is an expression, which is well-formed. 
Access checking is performed as if in a context unrelated to <tt>A1</tt>, ..., <tt>An</tt>. 
Only the validity of the immediate context (14.8.2 [temp.deduct]) of <em>c</em> is considered. 
[<i>Note:</i> The compilation of <em>c</em> can result in side effects such as the instantiation of class template 
specializations and function template specializations, the generation of implicitly-defined functions, and so on. 
Such side effects are not in the "immediate context" and can result in the program being ill-formed. &mdash; 
<i>end note</i>].</ins>
</p>
</li>

<li><p>Change Table 49 ("Type property predicates") as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 49 &mdash; Type property predicates</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T, class U&gt;<br/>
struct is_assignable;</tt>
</td>

<td>
The expression
<tt>declval&lt;T&gt;() =<br/>
declval&lt;U&gt;()</tt> is <ins>valid in a<br/>
contrived argument deduction context<br/>
([defns.valid.contr.context]) for types<br/>
<tt>T</tt> and <tt>U</tt>.</ins>
<del>well-formed when treated<br/>
as an unevaluated operand<br/>
(Clause 5). Access<br/>
checking is performed as if<br/>
in a context unrelated to <tt>T</tt><br/>
and <tt>U</tt>. Only the validity of<br/>
the immediate context of<br/>
the assignment expression<br/>
is considered. [<i>Note</i>: The<br/>
compilation of the<br/>
expression can result in<br/>
side effects such as the<br/>
instantiation of class<br/>
template specializations<br/>
and function template<br/>
specializations, the<br/>
generation of<br/>
implicitly-defined<br/>
functions, and so on. Such<br/>
side effects are not in the<br/>
"immediate context" and<br/>
can result in the program<br/>
being ill-formed. &mdash; end<br/>
note]</del>
</td>

<td align="center">
[&hellip;]
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 20.15.4.3 [meta.unary.prop] p7 as indicated:</p>

<blockquote><p>
-7- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre></blockquote>
<p>
the predicate condition for a template specialization <tt>is_constructible&lt;T, Args...&gt;</tt> shall be satisfied
if and only if the following variable definition <del>would be well-formed</del> for some invented 
variable <tt>t</tt> <ins>would be valid in a contrived argument deduction context ([defns.valid.contr.context]) for 
types <tt>T</tt> and <tt>Args...</tt></ins>:
</p>
<blockquote><pre>
T t(create&lt;Args&gt;()...);
</pre></blockquote>
<p>
[<i>Note</i>: These tokens are never interpreted as a function declaration. &mdash; <i>end note</i>] <del>Access checking is
performed as if in a context unrelated to <tt>T</tt> and any of the <tt>Args</tt>. Only the validity of the immediate context
of the variable initialization is considered. [<i>Note</i>: The evaluation of the initialization can result in side
effects such as the instantiation of class template specializations and function template specializations, the
generation of implicitly-defined functions, and so on. Such side effects are not in the "immediate context"
and can result in the program being ill-formed. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

<li><p>Change Table 57 ("Other transformations") as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 57 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class Fn, class... ArgTypes&gt;<br/>
struct result_of&lt;Fn(ArgTypes...)&gt;;</tt>
</td>

<td align="center">
[&hellip;]
</td>

<td>
If the expression<br/>
<tt><i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...)</tt> is<br/>
<ins>valid in a contrived argument deduction<br/>
context ([defns.valid.contr.context]) for types<br/>
<tt>Fn</tt> and <tt>ArgTypes...</tt></ins>
<del>well<br/>
formed when treated as an<br/>
unevaluated operand (Clause 5)</del>, the<br/>
member typedef type shall name the<br/>
type<br/>
<tt>decltype(<i>INVOKE</i>(declval&lt;Fn&gt;(),<br/>
declval&lt;ArgTypes&gt;()...))</tt>;<br/>
otherwise, there shall be no member<br/>
type. <del>Access checking is performed as<br/>
if in a context unrelated to <tt>Fn</tt> and<br/>
<tt>ArgTypes</tt>. Only the validity of the<br/>
immediate context of the expression is<br/>
considered. [<i>Note</i>: The compilation of<br/>
the expression can result in side<br/>
effects such as the instantiation of<br/>
class template specializations and<br/>
function template specializations, the<br/>
generation of implicitly-defined<br/>
functions, and so on. Such side effects<br/>
are not in the "immediate context"<br/>
and can result in the program being<br/>
ill-formed. &mdash; <i>end note</i>]</del>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Change 20.15.6 [meta.rel] p4 as indicated:</p>

<blockquote><p>
-4- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  add_rvalue_reference_t&lt;T&gt; create() noexcept;
</pre></blockquote>
<p>
the predicate condition for a template specialization <tt>is_convertible&lt;From, To&gt;</tt> shall be satisfied if and
only if the return expression in the following code would be <del>well-formed</del><ins>valid in a contrived argument 
deduction context ([defns.valid.contr.context]) for types <tt>To</tt> and <tt>From</tt></ins>, including any implicit conversions
to the return type of the function:
</p>
<blockquote><pre>
To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>
<p>
[<i>Note</i>: This requirement gives well defined results for reference types, <tt>void</tt> types, array types, and
function types. &mdash; <i>end note</i>] <del>Access checking is performed as if in a context unrelated to <tt>To</tt> 
and <tt>From</tt>. Only the validity of the immediate context of the expression of the return-statement (including conversions to
the return type) is considered. [<i>Note</i>: The evaluation of the conversion can result in side effects such as
the instantiation of class template specializations and function template specializations, the generation of
implicitly-defined functions, and so on. Such side effects are not in the "immediate context" and can result
in the program being ill-formed. &mdash; <i>end note</i>]</del>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2292" href="#2292">2292.</a> Find a better phrasing for "shall not participate in overload resolution"</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2013-09-03 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++14 CD has 25 sections including the phrase "X shall not
participate in overload resolution ...". Most of these uses are double
negatives, which are hard to interpret. "shall not ... unless" tends
to be the easiest to read, since the condition is true when the
function is available, but we also have a lot of "if X is not Y, then
Z shall not participate", which actually means "You can call Z if X is
Y." The current wording is also clumsy and long-winded. We should find
a better and more concise phrasing.
<p/>
As an initial proposal, I'd suggest using "X is enabled if and only if Y" in prose
and adding an "<i>Enabled If:</i> ..." element to 17.5.1.4 [structure.specifications].
<p/>
Daniel:
<p/>
I suggest to name this new specification element for 17.5.1.4 [structure.specifications]
as "<i>Template Constraints:</i>" instead, because the mentioned wording form was intentionally provided 
starting with LWG <a href="lwg-defects.html#1237">1237</a> to give implementations more freedom to realize the 
concrete constraints. Instead of the original <tt>std::enable_if</tt>-based specifications
we can use better forms of "SFINAE" constraints today and it eases the path to possible language-based
constraints in the future.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2294" href="#2294">2294.</a> <tt>&lt;cstdlib&gt;</tt> should declare <tt>abs(double)</tt></h3>
<p><b>Section:</b> 26.9 [c.math] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2013-09-04 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.math">active issues</a> in [c.math].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
&hellip; and <tt>abs(float)</tt> and <tt>abs(long double)</tt>. And <tt>&lt;cmath&gt;</tt> should declare 
<tt>abs(int)</tt>, <tt>abs(long)</tt>, and <tt>abs(long long)</tt>.
<p/>
As things currently stand, this program is illegal:
</p>
<blockquote><pre>
#include &lt;cstdlib&gt;

int main() {
  double d = -1.23;
  double dd = std::abs(d);
  return 0;
}
</pre></blockquote>
<p>
The call is ambiguous because of the various integer overloads, that's because <tt>&lt;cstdlib&gt;</tt> provides 
<tt>abs(int)</tt> but not <tt>abs(double)</tt>.
<p/>
This lead one commenter on Stackoverflow to state that <tt>abs</tt> is dangerous, and to recommend using <tt>fabs</tt> instead.
<p/>
In general, it makes sense to declare overloaded functions that take user-defined types in the same header as the 
definition of the user-defined types; it isn't necessary to declare all of the overloads in the same place. But 
here we're not dealing with any user-defined types; we're dealing with builtin types, which are always defined; 
all of the overloads should be defined in the same place, to avoid mysterious problems like the one in the code above.
<p/>
The standard library has six overloads for <tt>abs</tt>:
</p>
<blockquote><pre>
int abs(int);  // &lt;cstdlib&gt;
long abs(long); // &lt;cstdlib&gt;
long long abs(long long); // &lt;cstdlib&gt;

float abs(float); // &lt;cmath&gt;
double abs(double); // &lt;cmath&gt;
long double abs(long double); // &lt;cmath&gt;
</pre></blockquote>
<p>
These should all be declared in both headers.
<p/>
I have no opinion on <tt>&lt;stdlib.h&gt;</tt> and <tt>&lt;math.h&gt;</tt>.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
This issue is related to LWG <a href="lwg-defects.html#2192">2192</a>
<p/>
Move to open
</p>

<p><i>[2014-02-13 Issaquah &mdash; Nicolai Josuttis suggest wording]</i></p>


<p><i>[2015-03-03, Geoffrey Romer provides improved wording]</i></p>

<p>
See proposed resolution of LWG <a href="lwg-defects.html#2192">2192</a>.
</p>

<p><i>[2015-09-11, Telecon]</i></p>

<p>Geoff provided combined wording for <a href="lwg-defects.html#2192">2192</a> after Cologne, Howard to provide updated wording for Kona.</p>
<p>Howard: my notes say I wanted to use <tt>is_unsigned</tt> instead of 'unsigned integral type'.</p>

<strong>Previous resolution from Nicolai [SUPERSEDED]:</strong>
<blockquote class = "note">
<ol>
<li><p>Edit 26.9 [c.math] after p7 as indicated:</p>

<blockquote><p>
-6- In addition to the <tt>int</tt> versions of certain math functions in <tt>&lt;cstdlib&gt;</tt>, C++ adds <tt>long</tt> and <tt>long long</tt>
overloaded versions of these functions, with the same semantics.
<p/>
-7- The added signatures are:
</p>
<blockquote><pre>
long abs(long);                    <i>// labs()</i>
long long abs(long long);          <i>// llabs()</i>
ldiv_t div(long, long);            <i>// ldiv()</i>
lldiv_t div(long long, long long); <i>// lldiv()</i>
</pre></blockquote>
<p>
<ins>-?- To avoid ambiguities, C++ also adds the following overloads of <tt>abs()</tt> to <tt>&lt;cstdlib&gt;</tt>,
with the semantics defined in <tt>&lt;cmath&gt;</tt>:</ins>
</p>
<blockquote><pre>
<ins>float abs(float);
double abs(double);
long double abs(long double);</ins>
</pre></blockquote>
<p>
<ins>-?- To avoid ambiguities, C++ also adds the following overloads of <tt>abs()</tt> to <tt>&lt;cmath&gt;</tt>,
with the semantics defined in <tt>&lt;cstdlib&gt;</tt>:</ins>
</p>
<blockquote><pre>
<ins>int abs(int);
long abs(long);
long long abs(long long);</ins>
</pre></blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-08 Chicago]</i></p>

<p>Resolved by <a href="lwg-defects.html#2192">2192</a></p>


<p><b>Proposed resolution:</b></p>
<p>
See proposed resolution of LWG <a href="lwg-defects.html#2192">2192</a>.
</p>





<hr>
<h3><a name="2295" href="#2295">2295.</a> Locale name when the provided <tt>Facet</tt> is a <tt>nullptr</tt></h3>
<p><b>Section:</b> 22.3.1.2 [locale.cons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2013-09-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.3.1.2 [locale.cons] p14 ends with:
</p>
<blockquote><p>
"[&hellip;] If <tt>f</tt> is null, the resulting object is a copy of <tt>other</tt>."
</p></blockquote>
<p>
but the next line p15 says: 
</p>
<blockquote><p>
"<i>Remarks:</i> The resulting locale has no name."
</p></blockquote>
<p>
But both can't be true when <tt>other</tt> has a name and <tt>f</tt> is null.
<p/>
I've tried it on two implementations (MSVC,GCC) and they are inconsistent with each other on this.
</p>
<p>
Daniel Kr&uuml;gler:
<p/>
As currently written, the <i>Remarks</i> element applies unconditionally for all cases and thus should
"win". The question arises whether the introduction of this element by LWG <a href="lwg-closed.html#424">424</a> had actually intended
to change the previous <i>Note</i> to a <i>Remarks</i> element. In either case the wording should be improved
to clarify this special case.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2303" href="#2303">2303.</a> Explicit instantiation of <tt>std::vector&lt;UserType&gt;</tt> broken?</h3>
<p><b>Section:</b> 18.6.2.3 [new.delete.placement] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-18 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.placement">issues</a> in [new.delete.placement].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The library gives explicit permission in 17.6.4.2.1 [namespace.std] p2 that user code may explicitly instantiate
a library template provided that the instantiations depend on at least one user-defined type:
</p>

<blockquote><p>
A program may explicitly instantiate a template defined in the standard library only if the declaration
depends on the name of a user-defined type and the instantiation meets the standard library requirements
for the original template.
</p></blockquote>

<p>
But it seems that the C++11 library is not specified in a way that guarantees such an instantiation to be well-formed
if the minimum requirements of the library is not satisfied. 
<p/>
For example, in general, the first template parameter of <tt>std::vector</tt> is not required to be 
<tt>DefaultConstructible</tt> in general, but due to the split of the single C++03 member function
with default argument
</p>
<blockquote><pre>
void resize(size_type sz, T c = T());
</pre></blockquote>
<p>
into
</p>
<blockquote><pre>
void resize(size_type sz);
void resize(size_type sz, const T&amp; c);
</pre></blockquote>
<p>
the effect is now that for a type <tt>ND</tt> that is not <tt>DefaultConstructible</tt>, such as
</p>
<blockquote><pre>
struct NP { 
  NP(int); 
};
</pre></blockquote>
<p>
the explicit instantiation of <tt>std::vector&lt;ND&gt;</tt> is no longer well-formed, because the attempt to
instantiate the single-argument overload of <tt>resize</tt> cannot not succeed, because this function imposes
the <tt>DefaultInsertable</tt> requirements and given the default allocator this effectively requires
<tt>DefaultConstructible</tt>.
</p>
<p>
But <tt>DefaultConstructible</tt> is not the only point, what about <tt>CopyConstructible</tt> versus
<tt>MoveConstructible</tt> alone? It turns out that currently the second <tt>resize</tt> overload
would fail during an explicit instantiation for a type like
</p>
<blockquote><pre>
struct MO { 
  MO() = default; 
  MO(MO&amp;&amp;) = default; 
};
</pre></blockquote>
<p>
because it imposes <tt>CopyInsertable</tt> requirements that end up being equivalent to the <tt>CopyConstructible</tt>
requirements for the default allocator.
<p/>
Technically a library can solve these issues: For special member functions by defining them in some base class, for others
by transforming them effectively into a function template due to the great feature of default template arguments for
function templates (At the very moment the validity of the latter approach depends on a resolution of core language issue
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1635">CWG 1635</a>, though). E.g. the here mentioned 
<tt>resize</tt> functions of <tt>std::vector</tt> could be prevented from instantiation by defining them like this 
with an implementation:
</p>
<blockquote><pre>
template&lt;class = void&gt;
void resize(size_type sz) { [&hellip;] }
template&lt;class = void&gt;
void resize(size_type sz, const T&amp; c) { [&hellip;] }
</pre></blockquote>
<p>
In this case, these functions could also be defined in a base class, but the latter approach won't work in all cases.
<p/>
Basically such an implementation is required to constrain all member functions that are not covered by the general
requirements imposed on the actual library template parameters. I tested three different C++11 library implementations
and but none could instantiate for example <tt>std::list</tt>, <tt>std::vector</tt>, or <tt>std::deque</tt> with
value types that are not <tt>DefaultConstructible</tt> or only <tt>MoveConstructible</tt>. 
<p/>

<p/>
This issue is raised to clarify the current situation in regard to the actual requirements imposed on user-provided
types that are used to explicitly instantiate Library-provided templates. For example, the current Container requirements
impose very little requirements on the actual value type and it is unclear to which extend library implementations have
to respect that. 
<p/>
The minimum solution of this issue should be to at least realize that there is no fundamental requirement on 
<tt>DefaultConstructible</tt> for value types of library containers, because we have since C++03 the general
statement of 17.6.3.1 [utility.arg.requirements] ("In general, a default constructor is not required.").
It is unclear whether <tt>CopyConstructible</tt> should be required for an explicit instantiation request, but
given the careful introduction of move operations in the library it would seem astonishing that a
<tt>MoveConstructible</tt> type wouldn't suffice for value types of the container types.
<p/>
In any case I can envision at least two approaches to solve this issue:
</p>
<ol>
<li>
<p>
As indicated in LWG <a href="lwg-active.html#2292">2292</a>, those function could get an explicit "<i>Template Constraints:</i>"
element, albeit this promises more than needed to solve this issue.
</p>
</li>
<li>
<p>
The library could introduce a completely new element form, such as "<i>Instantiation Constraints:</i>" that
would handle this situation for explicit instantiation situations. This would allow for simpler techniques
to solve the issue when explicit instantiation is required compared to the first bullet, because it would not 
(necessarily) guarantee SFINAE-friendly expression-wellformedness, such as inspecting the expression 
<tt>std::declval&lt;std::vector&lt;ND&gt;&amp;&gt;.resize(0)</tt> in an unevaluated context.
</p>
</li>
</ol>

<p>
It should be noted that the 2013-08-27 comment to LWG <a href="lwg-defects.html#2193">2193</a> could be resolved by a similar solution
as indicated in this issue here.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2307" href="#2307">2307.</a> Should the Standard Library use <tt>explicit</tt> only when necessary?</h3>
<p><b>Section:</b> 23 [containers] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-09-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#containers">active issues</a> in [containers].</p>
<p><b>View all other</b> <a href="lwg-index.html#containers">issues</a> in [containers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#2193">2193</a> yields <tt>explicit</tt> for default ctors to allow <tt>{}</tt>, but not for
all cases of uniform initialization. For example:
</p>
<blockquote><pre>
explicit vector(size_type count, const Allocator&amp; alloc = Allocator());
</pre></blockquote>
<p>
This prevents <tt>{n, alloc()}</tt>. Although this use is relatively rare,
but the behavior is inconsistent with that of
</p>
<blockquote><pre>
vector(size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator());
</pre></blockquote>

<p><i>[Urbana 2014-11-07: Move to Open]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2318" href="#2318">2318.</a> <tt>basic_string</tt>'s wording has confusing relics from the copy-on-write era</h3>
<p><b>Section:</b> 21.3.1 [basic.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.3.1.4 [string.capacity]/8 specifies <tt>basic_string::resize(n, c)</tt> with:
</p>
<blockquote><p>
<i>Effects:</i> Alters the length of the string designated by <tt>*this</tt> as follows:
</p>
<ul>
<li><p>
If <tt>n &lt;= size()</tt>, the function replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose 
elements are a copy of the initial elements of the original string designated by <tt>*this</tt>.
</p>
</li>
<li><p>
If <tt>n &gt; size()</tt>, the function replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose 
first <tt>size()</tt> elements are a copy of the original string designated by <tt>*this</tt>, and whose remaining elements are all 
initialized to <tt>c</tt>.
</p>
</li>
</ul>
</blockquote>
<p>
This wording is a relic of the copy-on-write era. In addition to being extremely confusing, it has undesirable implications.  
Saying "replaces the string designated by <tt>*this</tt> with a string of length <tt>n</tt> whose elements are a copy" suggests 
that the trimming case can reallocate. Reallocation during trimming should be forbidden, like <tt>vector</tt>.
<p/>
At least 7 paragraphs are affected: 21.3.1.4 [string.capacity]/8, 21.3.1.6.2 [string::append]/9, 
21.3.1.6.3 [string::assign]/3 and /10, 21.3.1.6.4 [string::insert]/11, 21.3.1.6.5 [string::erase]/4, and 
21.3.1.6.6 [string::replace]/11 say "replaces the string [designated/controlled] by <tt>*this</tt>". (21.3.1.6.7 [string::copy]/3 
is different &mdash; it "replaces the string designated by <tt>s</tt>".)
<p/>
Of the affected paragraphs, <tt>resize()</tt> and <tt>erase()</tt> are the most important to fix because they should forbid 
reallocation during trimming.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2321" href="#2321">2321.</a> Moving containers should (usually) be required to preserve iterators</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2.1 [container.requirements.general]/10 says that unless otherwise specified, "no <tt>swap()</tt> function invalidates 
any references, pointers, or iterators referring to the elements of the containers being swapped. [<i>Note:</i> The <tt>end()</tt> 
iterator does not refer to any element, so it may be invalidated. &mdash; <i>end note</i>]". However, move constructors and move 
assignment operators aren't given similar invalidation guarantees. The guarantees need several exceptions, so I do not believe 
that blanket language like /11 "Unless otherwise specified (either explicitly or by defining a function in terms of other functions), 
invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, 
or change the values of, objects within that container." is applicable.
</p>

<p><i>[2014-02-13 Issaquah]</i></p>

<p>
General agreeement on intent, several wording nits and additional paragraphs to hit.
</p>
<p>
STL to provide updated wording.  Move to Open.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: in the proposed wording, I'd like to mention that the iterators now refer to elements of a different container. 
I think we're saying something like this somewhere. JY: There's some wording like that for swap I think. TK: It's also in 
<tt>list::splice()</tt>. DK to JY: 23.2.1p9.
<p/>
VV: The issue says that STL was going to propose new wording. Has he done that? AM: I believe we're looking at that. 
GR: The request touches on multiple paragraphs, and this PR has only one new paragraph, so this looks like it's not up-to-date. 
MC: This was last updated a year ago in Issaquah.
<p/>
<b>Conclusion</b>: Skip, not up to date. 
</p>

<p><i>[2015-06, Telecon]</i></p>

<p>Still waiting for updated wording</p>

<p><i>[2015-08 Chicago]</i></p>

<p>Still waiting for updated wording</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 23.2.1 [container.requirements.general]/10 change as indicated:</p>

<blockquote><p>
-10- Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.3.4, and 23.3.7.5) all container types defined in this
Clause meet the following additional requirements:
</p>
<ul>
<li><p>
[&hellip;]
</p></li>
<li><p>
no copy constructor or assignment operator of a returned iterator throws an exception.
</p></li>
<li><p>
<ins>no move constructor (or move assignment operator when 
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt> is true) of a container 
(except for <tt>array</tt>) invalidates any references, pointers, or iterators referring to the elements of the source container. 
[<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element, so it may be invalidated. &mdash; <i>end note</i>]</ins>
</p></li>
<li><p>
no <tt>swap()</tt> function throws an exception.
</p></li>
<li><p>
no <tt>swap()</tt> function invalidates any references, pointers, or iterators referring to the elements of the
containers being swapped. [<i>Note:</i> The <tt>end()</tt> iterator does not refer to any element, so it may be
invalidated. &mdash; <i>end note</i>]
</p></li>
</ul>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2331" href="#2331">2331.</a> <tt>regex_constants::collate</tt>'s effects are inaccurately summarized</h3>
<p><b>Section:</b> 28.5.1 [re.synopt] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.synopt">active issues</a> in [re.synopt].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.synopt">issues</a> in [re.synopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The table in 28.5.1 [re.synopt]/1 says that <tt>regex_constants::collate</tt> "Specifies that character ranges of the form 
"<tt>[a-b]</tt>" shall be locale sensitive.", but 28.13 [re.grammar]/14 says that it affects individual character comparisons 
too.
</p>

<p><i>[2012-02-12 Issaquah : recategorize as P3]</i></p>


<p>
Marshall Clow: 28.13/14 only applies to ECMAScript
</p>

<p>
All: we're unsure
</p>

<p>
Jonathan Wakely: we should ask John Maddock
</p>

<p>
Move to P3
</p>

<p><i>[2014-5-14, John Maddock response]</i></p>

<p>
The original intention was the original wording: namely that <tt>collate</tt> only made character ranges locale sensitive.  
To be frank it's a feature that's probably hardly ever used (though I have no real hard data on that), and is a leftover 
from early POSIX standards which <em>required</em> locale sensitive collation for character ranges, and then later changed 
to implementation defined if I remember correctly (basically nobody implemented locale-dependent collation).
<p/>
So I guess the question is do we gain anything by requiring all character-comparisons to go through the locale when this bit 
is set? Certainly it adds a great deal to the implementation effort (it's not what Boost.Regex has ever done). I guess the 
question is are differing code-points that collate identically an important use case? I guess there might be a few Unicode 
code points that do that, but I don't know how to go about verifying that.
<p/>
STL:
<p/>
If this was unintentional, then 28.5.1 [re.synopt]/1's table should be left alone, while 28.13 [re.grammar]/14 
should be changed instead.
<p/>
Jeffrey Yasskin:
<p/>
<a href="http://www.unicode.org/reports/tr18/tr18-13.html#Tailored_Loose_Matches">This page</a>
mentions that [V] in Swedish should match "W" in a perfect world.
<p/>
However, the most recent version of <a href="http://www.unicode.org/reports/tr18/#Tailored_Loose_Matches">TR18</a> retracts
both language-specific loose matches <em>and</em> language-specific ranges
because "for most full-featured regular expression engines, it is
quite difficult to match under code point equivalences that are not
1:1" and "tailored ranges can be quite difficult to implement
properly, and can have very unexpected results in practice. For
example, languages may also vary whether they consider lowercase below
uppercase or the reverse. This can have some surprising results: [a-Z]
may not match anything if <tt>Z &lt; a</tt> in that locale."
<p/>
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.15">ECMAScript</a> doesn't include collation at all.
<p/>
IMO, +1 to changing 28.13 instead of 28.5.1. It seems like we'd be on
fairly solid ground if we wanted to remove <tt>regex_constants::collate</tt>
entirely, in favor of named character classes, but of course that's
not for this issue.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 28.5.1 [re.synopt]/1, Table 138 &mdash; "<tt>syntax_option_type</tt> effects", change as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 138 &mdash; <tt>syntax_option_type</tt> effects</caption>
<tr>
<th align="center">Element</th>
<th align="center">Effect(s) if set</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>collate</tt>
</td>
<td>
Specifies that character <del>ranges of the form "<tt>[a-b]</tt>"</del><ins>comparisons and character range comparisons</ins> 
shall be locale sensitive.
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2334" href="#2334">2334.</a> <tt>atomic</tt>'s default constructor requires "uninitialized" state even for types with non-trivial default-constructor</h3>
<p><b>Section:</b> 29.6.5 [atomics.types.operations.req] <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-10-03 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations.req">issues</a> in [atomics.types.operations.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to 29.6.5 [atomics.types.operations.req] p4,
</p>
<blockquote><pre>
A ::A () noexcept = default;
</pre><blockquote>
<p>
<i>Effects:</i> leaves the atomic object in an uninitialized state. [<i>Note:</i> These semantics ensure compatibility
with <tt>C</tt>. &mdash; <i>end note</i>]
</p>
</blockquote></blockquote>
<p>
This implementation requirement is OK for POD types, like <tt>int</tt>, but 29.5 [atomics.types.generic] p1
intentionally allows template arguments of <tt>atomic</tt> with a non-trivial default constructor ("The type of the template argument 
<tt>T</tt> shall be trivially copyable (3.9)"), so this wording can be read in a way that makes the behaviour of the following code
undefined:
</p>
<blockquote><pre>
#include &lt;atomic&gt;
#include &lt;iostream&gt;

struct S {
  S() noexcept : v(42) {}
  int v;
};

int main() {
  std::atomic&lt;S&gt; as; // Default-initialization
  std::cout &lt;&lt; as.load().v &lt;&lt; std::endl; // ?
}
</pre></blockquote>
<p>
For a user-defined emulation of <tt>atomic</tt> the expected outcome would be defined and the program would output "42",
but existing implementations differ and the result value is a "random number" for at least one implementation. This seems
very surprising to me.
<p/>
To realize that seemingly existing requirement, an implementation is either required to violate normal language rules internally
or to perform specific bit-randomization-techniques after the normal default-initialization that called the default constructor
of <tt>S</tt>.
<p/>
According to my understanding, the non-normative note in 29.6.5 [atomics.types.operations.req] p4 is intended to
refer to types that are valid <tt>C</tt>-types, but the example type <tt>S</tt> is not such a type.
<p/>
To make the mental model of <tt>atomic</tt>'s default constructor more intuitive for user-code, I suggest to clarify the wording
to have the effects of default-initialization instead. The current state seems more like an unintended effect of imprecise
language used here and has some similarities to wording that was incorrectly used to specify <tt>atomic_flag</tt> initialization 
as described by LWG <a href="lwg-defects.html#2159">2159</a>.
</p>

<p><i>[2014-05-17, Daniel comments and provides alternative wording]</i></p>


<p>
The current wording was considered controversial as expressed by reflector discussions. To me, the actual problem is not newly
introduced by that wording, but instead is already present in basically all paragraphs specifying semantics of atomic types,
since the wording never clearly distinguishes the value of the actual atomic type <i>A</i> and the value of the "underlying",
corresponding non-atomic type <i>C</i>. The revised proposed wording attempts to improve the current ambiguity of these two
kinds of values.
</p>

<strong>Previous resolution from Daniel [SUPERSEDED]:</strong>
<p/>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 29.6.5 [atomics.types.operations.req] p4 as indicated: <em>[Editorial note: There is no exposition-only
member in <tt>atomic</tt>, which makes it a bit hard to specify what actually is initialized, but the usage of the term "value" 
seems consistent with similar wording used to specify the effects of the atomic <tt>load</tt> functions]</em></p>

<blockquote><pre>
A ::A () noexcept = default;
</pre><blockquote>
<p>
-4- <i>Effects:</i> <del>leaves the atomic object in an uninitialized state</del><ins>The value of the atomic object
is default-initialized (8.6 [dcl.init])</ins>. [<i>Note:</i> These semantics ensure compatibility
with <tt>C</tt>. &mdash; <i>end note</i>]
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Modify 29.6.5 [atomics.types.operations.req] p2 as indicated: <em>[Editorial note: This is a near-to editorial
change not directly affecting this issue, but <tt>atomic_address</tt> does no longer exist and the pointed to definition is
relevant in the context of this issue resolution.]</em>
</p>
<blockquote>
<p>
-2- In the following operation definitions:
</p>
<ul>
<li><p>an <i>A</i> refers to one of the atomic types.</p></li>
<li><p>a <i>C</i> refers to its corresponding non-atomic type. <del>The <tt>atomic_address</tt> atomic type corresponds to the
<tt>void*</tt> non-atomic type.</del></p></li>
<li><p>[&hellip;]</p></li>
</ul>
</blockquote>
</li>

<li><p>Modify 29.6.5 [atomics.types.operations.req] p4 and the following as indicated: <em>[Editorial note: There 
is no exposition-only member in <tt>atomic</tt>, which makes it a bit hard to specify what actually is initialized, but 
the introductory wording of 29.6.5 [atomics.types.operations.req] p2 b2 defines: "a <i>C</i> refers to its 
corresponding non-atomic type." which helps to specify the semantics in terms of "the <i>C</i> value referred to by the 
atomic object"]</em></p>

<blockquote>
<pre>
<i>A</i>::<i>A</i>() noexcept = default;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> <del>leaves the atomic object in an uninitialized state</del><ins>Default-initializes (8.6 [dcl.init]) 
the <i>C</i> value referred to by the atomic object</ins>. [<i>Note:</i> These semantics ensure compatibility with <tt>C</tt>. 
&mdash; <i>end note</i>]
</p>
</blockquote>

<pre>
constexpr <i>A</i>::<i>A</i>(<i>C</i> desired) noexcept;
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> <ins>Direct-i</ins><del>I</del>nitializes the <ins><i>C</i> value referred to by the atomic</ins> object 
with the value <tt>desired</tt>. Initialization is not an atomic operation (1.10). [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
void atomic_init(volatile <i>A</i>* object, <i>C</i> desired) noexcept;
void atomic_init(<i>A</i>* object, <i>C</i> desired) noexcept;
</pre>
<blockquote>
<p>
-8- <i>Effects:</i> Non-atomically initializes <ins>the <i>C</i> value referred to by</ins> <tt>*object</tt> with value 
<tt>desired</tt>. [&hellip;]
</p>
</blockquote>

<pre>
void atomic_store(volatile <i>A</i>* object, <i>C</i> desired) noexcept;
[&hellip;]
void <i>A</i>::store(<i>C</i> desired, memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-9- [&hellip;]
<p/>
-10- <i>Effects:</i> Atomically replaces the <ins><i>C</i></ins> value pointed to by 
<tt>object</tt> or by <tt>this</tt> with the value of <tt>desired</tt>. [&hellip;]
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
<i>C</i> atomic_load(const volatile <i>A</i>* object) noexcept;
[&hellip;]
<i>C</i> <i>A</i>::load(memory_order order = memory_order_seq_cst) const noexcept;
</pre>
<blockquote>
<p>
-13- [&hellip;]
<p/>
-14- [&hellip;]
<p/>
-15- <i>Returns:</i> Atomically returns the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
<i>C</i> atomic_exchange(volatile <i>A</i>* object, C desired) noexcept;
[&hellip;]
<i>C</i> <i>A</i>::exchange(C desired, memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-18- <i>Effects</i>: Atomically replaces the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt> with <tt>desired</tt>. [&hellip;]
<p/>
-19- <i>Returns:</i> Atomically returns the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt> 
immediately before the effects.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
<i>C</i> atomic_fetch_key(volatile <i>A</i>* object, <i>M</i> operand) noexcept;
[&hellip;]
<i>C</i> <i>A</i>::fetch_key(<i>M</i> operand, memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-28- <i>Effects</i>: Atomically replaces the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt> with 
the result of the computation applied to the <ins><i>C</i></ins> value pointed to by <tt>object</tt> or by <tt>this</tt> and 
the given <tt>operand</tt>. [&hellip;]
<p/>
-29- <i>Returns:</i> Atomically<del>,</del> <ins>returns</ins> the <ins><i>C</i></ins> value pointed to by <tt>object</tt>
or by <tt>this</tt> immediately before the effects.
<p/>
[&hellip;]
</p>
</blockquote>

</blockquote>
</li>

<li><p>Modify 29.7 [atomics.flag] p5 and the following as indicated:</p>

<blockquote>
<pre>
bool atomic_flag_test_and_set(volatile atomic_flag* object) noexcept;
[&hellip;]
bool atomic_flag::test_and_set(memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-5- <i>Effects</i>: Atomically sets the <ins>bool</ins> value pointed to by <tt>object</tt> or by <tt>this</tt> to <tt>true</tt>. 
[&hellip;]
<p/>
-6- <i>Returns</i>: Atomically<del>,</del> <ins>returns</ins> the <ins>bool</ins> value <del>of the</del><ins>pointed 
to by</ins> <tt>object</tt> <ins>or by <tt>this</tt></ins> immediately before the effects.
</p>
</blockquote>

<pre>
void atomic_flag_clear(volatile atomic_flag* object) noexcept;
[&hellip;]
void atomic_flag::clear(memory_order order = memory_order_seq_cst) noexcept;
</pre>
<blockquote>
<p>
-7- [&hellip;]
<p/>
-8- <i>Effects</i>: Atomically sets the <ins>bool</ins> value pointed to by <tt>object</tt> or by <tt>this</tt> to <tt>false</tt>. 
[&hellip;]
</p>
</blockquote>

</blockquote>

</li>
</ol>





<hr>
<h3><a name="2335" href="#2335">2335.</a> <tt>array&lt;array&lt;int, 3&gt;, 4&gt;</tt> should be layout-compatible with <tt>int[4][3]</tt></h3>
<p><b>Section:</b> 23.3.7 [array] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2013-10-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In order to replace some uses of C arrays with <tt>std::array</tt>, we need it
to be possible to cast from a <tt>std::array&lt;&gt;</tt> to an equivalent C array.
Core wording doesn't appear to be in quite the right state to allow
casting, but if we specify that appropriate types are
layout-compatible, we can at least write:
</p>
<blockquote><pre>
union {
  array&lt;array&lt;array&lt;int, 2&gt;, 3&gt;, 4&gt; arr;
  int carr[4][3][2];
};
</pre></blockquote>
<p>
to view memory as the other type: C++14 CD [class.mem]p18.
</p>
I believe it's sufficient to add "<tt>array&lt;T, N&gt;</tt> shall be
layout-compatible (3.9 [basic.types]) with <tt>T[N]</tt>." to 
23.3.7.1 [array.overview], but we might also need some extension to 
9.2 [class.mem] to address the possibility of layout-compatibility 
between struct and array types.
<p>
I checked that libc++ on MacOS already implements this, although it
would be good for someone else to double-check; I haven't checked any
other standard libraries.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2337" href="#2337">2337.</a> <tt>shared_ptr operator*()</tt> should not be <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.11.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-10-05 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.11.1.2.4 [unique.ptr.single.observers]/3: "<tt>pointer operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != nullptr</tt>."
<p/>
20.11.2.2.5 [util.smartptr.shared.obs]/2: "<tt>T&amp; operator*() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
20.11.2.2.5 [util.smartptr.shared.obs]/5: "<tt>T* operator-&gt;() const noexcept;</tt> <i>Requires:</i> <tt>get() != 0</tt>."
<p/>
Narrow-contract functions should not be <tt>noexcept</tt>.
</p>

<p><i>[2014-02-15 Issaquah]</i></p>

<p>
Issue is contentious, raise to P2.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
AM: This ship has sailed. JM: What's the issue? AM: <tt>operator-&gt;</tt> has narrow contract and should never have had 
<tt>noexcept</tt>. DK: Not quite. We explicitly called out that for <tt>shared_ptr</tt> this is fine. You said so in your 
"narrow contract" paper. GR: This would be a fairly major regression in the design of {<tt>unique</tt>,<tt>shared</tt>}<tt>_ptr</tt> 
over raw pointers; raw pointer dereferencing is <tt>noexcept</tt>. It's not a performance regression but a usability regression. 
AM: Do we expect users to query <tt>noexpect</tt> on dereference expressions? Room: Yes. VV: We don't just expect it, we have 
seen it. JM: Yes, users may be querying something like <tt>noexcept(x-&gt;y)</tt> and expect to be checking <tt>y</tt>, but 
silently end up checking <tt>x-&gt;</tt>. 
<p/>
Close as NAD, with explanation from GR.
</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 20.11.1.2 [unique.ptr.single]/1, class template <tt>unique_ptr</tt> synopsis for single objects, change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.1.2.4 [unique.ptr.single.observers] change as indicated:</p>

<blockquote><pre>
pointer operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>get() != nullptr</tt>.
<p/>
-4- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-5- <i>Note:</i> use typically requires that <tt>T</tt> be a complete type.
</p>
</blockquote></blockquote>
</li>

<li><p>In 20.11.2.2 [util.smartptr.shared]/1, class template <tt>shared_ptr</tt> synopsis, change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
T* operator-&gt;() const <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>In 20.11.2.2.5 [util.smartptr.shared.obs] change as indicated:</p>

<blockquote><pre>
T&amp; operator*() const <del>noexcept</del>;
</pre><blockquote>
<p>
-2- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-3- <i>Returns:</i> <tt>*get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
<p/>
-4- <i>Remarks:</i> When <tt>T</tt> is <tt>void</tt>, it is unspecified whether this member function is declared. 
If it is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
</p>
</blockquote></blockquote>

<blockquote><pre>
T* operator-&gt;() const <del>noexcept</del>;
</pre><blockquote>
<p>
-5- <i>Requires:</i> <tt>get() != 0</tt>.
<p/>
-6- <i>Returns:</i> <tt>get()</tt>.
<p/>
<ins>-?- <i>Throws:</i> Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>
</blockquote>

<p><i>[2015-03-03, Geoffrey provides rationale]</i></p>

<p>
<b>Rationale</b>:
</p>
<blockquote>
<p>
It is by design that these members are <tt>noexcept</tt>, and changing that now would be a substantial regression in functionality. 
These classes were designed to substitute for plain pointers as transparently as possible, so since those operations are effectively 
<tt>noexcept</tt> on plain pointers, they should be <tt>noexcept</tt> on <tt>unique_ptr</tt> and <tt>shared_ptr</tt> as well. 
This matters in practice because we expect these members to be used fairly often inside the <tt>noexcept</tt> operator, and such 
code could be broken by this change. These design considerations override our general policy against <tt>noexcept</tt> for 
narrow-contract functions.
<p/>
It is notable that N3279, which proposed this policy, did not propose striking <tt>noexcept</tt> from these operations. It's not 
clear if the omission of <tt>operator*</tt> and <tt>operator-&gt;</tt> was an oversight, or an intentional reflection of the above 
considerations. N3279 was based on N3248 by the same authors, which states that:
</p>
<blockquote>
<p>
"Most applications of <tt>noexcept</tt> for <tt>unique_ptr</tt> and <tt>shared_ptr</tt> are on functions with wide contracts. 
However, there are preconditions on the atomic access functions, so these should lose the specification."
</p>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2338" href="#2338">2338.</a> &sect;[re.traits]/7 expects of locale facets something not guaranteed by [locale.facet]/4</h3>
<p><b>Section:</b> 28.7 [re.traits], 22.3.1.1.2 [locale.facet] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sergey Zubkov <b>Opened:</b> 2013-10-15 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#re.traits">issues</a> in [re.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.7 [re.traits]/7, begins with "if <tt>typeid(use_facet&lt;collate&lt;charT&gt; &gt;) == typeid(collate_byname&lt;charT&gt;)</tt>", 
which appears to be pseudocode with the intention to convey that the collate facet has not been replaced by the user. Cf. the wording in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">N1429</a> "there is no portable way to implement 
<tt>transform_primary</tt> in terms of <tt>std::locale</tt>, since even if the sort key format returned by 
<tt>std::collate_byname&lt;&gt;::transform</tt> is known and can be converted into a primary sort key, the user can still 
install their own custom <tt>std::collate</tt> implementation into the locale object used, and that can use any sort key 
format they see fit.".
<p/>
Taken literally, 28.7 [re.traits]/7 appears to imply that named locales are required to hold their collate facets with 
dynamic type <tt>std::collate_byname&lt;charT&gt;</tt>, which is in fact true in some implementations (e.g libc++), but not others 
(e.g. libstdc++). This does not follow from the description of <tt>_byname</tt> in 22.3.1.1.2 [locale.facet]/4, which is only 
required to provide equivalent semantics, to the named locale's facet, not to actually be one.
</p>


<p><i>[2015-05-06 Lenexa: Move to Open]</i></p>


<p>MC, RP: Consequence of failing to follow the rule is UB.</p>
<p>MC: Tightening of requirements.</p>
<p>RP: It should be this way, we just didn't impose it before.</p>
<p>MC: Second change is a bug fix, original code didn't work.</p>
<p>TK: Doesn't seem to make things worse.</p>
<p>Bring up in larger group tomorrow.</p>
<p>JW arrives.</p>
<p>JW: libstdc++ violates this due to two std::string ABIs.</p>
<p>JW: This prevents installing a type derived from Facet_byname, constrains the implementor from using a smarter derived class version.</p>
<p>JW: Can't look at facet id to detect replacement, because replacements have the same id.</p>
<p>RP: Can you give it multiple ids through multiple inheritance?</p>
<p>JW: No, the facet mechanism wouldn't like that.</p>
<p>JW: We should also ask Martin Sebor, he's implemented this stuff recently.</p>
<p>MC: Sounds like this resolution doesn't work, need a better solution.</p>
<p>JW: Write in words "if the facet has not been replaced by the user", the implementation knows how to detect that, but not like this.</p>
<p>RP: User RE traits need to detect this too.</p>
<p>JW: =(</p>
<p>Move to Open, JW will invite Martin Sebor to join LWG for discussion.</p>
<p>Later ... </p>
<p>JW: This is not needed for user specializations after all.</p>
<p>MC: Agree, [re.traits]/7 only applies to the stdlib traits.</p>
<p>NM: Effects: doesn't make sense.</p>
<p>JW, NM, Martin Sebor to come up with new wording.</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Modify 22.3.1.1.2 [locale.facet]/4 as indicated:</p>

<blockquote><p>
For some standard facets a standard "...<tt>_byname</tt>" class, derived from it, implements the virtual function
semantics <del>equivalent to</del><ins>provided by</ins> that facet of the locale constructed by <tt>locale(const char*)</tt> 
with the same name.
Each such facet provides a constructor that takes a <tt>const char*</tt> argument, which names the locale, and a
<tt>refs</tt> argument, which is passed to the base class constructor. Each such facet also provides a constructor
that takes a string argument <tt>str</tt> and a <tt>refs</tt> argument, which has the same effect as calling the first
constructor with the two arguments <tt>str.c_str()</tt> and <tt>refs</tt>. If there is no "...<tt>_byname</tt>" 
version of a facet, the base class implements named locale semantics itself by reference to other facets. <ins>For any 
locale <tt>loc</tt> constructed by <tt>locale(const char*)</tt> and facet <tt>Facet</tt> that has a corresponding standard 
<tt>Facet_byname</tt> class, <tt>typeid(use_facet&lt;Facet&gt;(loc)) == typeid(Facet_byname)</tt>.</ins>
</p></blockquote>
</li>

<li><p>Modify 28.7 [re.traits]/7 as indicated:</p>

<blockquote><pre>
template &lt;class ForwardIterator&gt;
  string_type transform_primary(ForwardIterator first, ForwardIterator last) const;
</pre><blockquote>
<p>
-7- <i>Effects:</i> if <tt>typeid(use_facet&lt;collate&lt;charT&gt; &gt;<ins>(getloc())</ins>) == typeid(collate_byname&lt;charT&gt;)</tt> 
and the form of the sort key returned by <tt>collate_byname&lt;charT&gt;::transform(first, last)</tt> is known and
can be converted into a primary sort key then returns that key, otherwise returns an empty string.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2342" href="#2342">2342.</a> User conversion to <tt>wchar_t const*</tt> or to <tt>wchar_t</tt> not invoked for <tt>operator&lt;&lt;</tt></h3>
<p><b>Section:</b> 27.7.3.1 [ostream] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alf P. Steinbach <b>Opened:</b> 2013-10-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream">issues</a> in [ostream].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For wide streams argument types <tt>wchar_t const*</tt> and <tt>wchar_t</tt> are supported only as template parameters. 
User defined conversions are not considered for template parameter matching. Hence inappropriate overloads of 
<tt>operator&lt;&lt;</tt> are selected when an implicit conversion is required for the argument, which is inconsistent 
with the behavior for <tt>char const*</tt> and <tt>char</tt>, is unexpected, and is a useless result.
<p/>
Demonstration:
</p>
<blockquote><pre>
#include &lt;iostream&gt;

struct Byte_string
{ 
  operator char const*() const { return "Hurray, it works!"; } 
};

struct Wide_string
{ 
  operator wchar_t const*() const { return L"Hurray, it works!"; } 
};

struct Byte_ch
{ 
  operator char() const { return 'X'; } 
};

struct Wide_ch
{ 
  operator wchar_t() const { return L'X'; } 
};

auto main() -> int
{
  using namespace std;
  wcout &lt;&lt; "'X' as char value   : " &lt;&lt; Byte_ch() &lt;&lt; endl;
  wcout &lt;&lt; "'X' as wchar_t value: " &lt;&lt; Wide_ch() &lt;&lt; endl;
  wcout &lt;&lt; "Byte string pointer : " &lt;&lt; Byte_string() &lt;&lt; endl;
  wcout &lt;&lt; "Wide string pointer : " &lt;&lt; Wide_string() &lt;&lt; endl;
}
</pre></blockquote>
<p>
Example output:
</p>
<blockquote><pre>
'X' as char value   : X
'X' as wchar_t value: 88
Byte string pointer : Hurray, it works!
Wide string pointer : 000803C8
</pre></blockquote>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Modify 27.7.3.1 [ostream], class template <tt>basic_ostream</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
[&hellip;]

<i>// 27.7.3.6.4 character inserters</i>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          charT);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          char);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;,
                                         char);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp;,
                                            wchar_t);</ins>
[&hellip;]

template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          const charT*);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp;,
                                          const char*);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp;,
                                         const char*);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp;,
                                            const wchar_t*);</ins>
[&hellip;]
}

</pre></blockquote>
</li>

<li><p>Modify 27.7.3.6.4 [ostream.inserters.character] as indicated: <em>[Drafting note: 
The replacement of <tt>os</tt> by <tt>out</tt> in p1 and the insertion of "<tt>out.</tt>" in p4 
just fix two obvious typos &mdash; end drafting note]</em></p>

<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          charT c);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          char c);
<i>// specialization</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         char c);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp; out,
                                            wchar_t c);</ins>

<i>// signed and unsigned</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                          signed char c);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                          unsigned char c);
</pre><blockquote>
<p>
-1- <i>Effects:</i> Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) of <tt>out</tt>. 
Constructs a character sequence <tt>seq</tt>. If <tt>c</tt> has type <tt>char</tt> and the character type of the stream 
is not <tt>char</tt>, then <tt>seq</tt> consists of <tt>out.widen(c)</tt>; otherwise <tt>seq</tt> consists of <tt>c</tt>. 
Determines padding for <tt>seq</tt> as described in 27.7.3.6.1 [ostream.formatted.reqmts]. Inserts <tt>seq</tt> into 
<tt>out</tt>. Calls <tt><del>os</del><ins>out</ins>.width(0)</tt>.
<p/>
-2- <i>Returns:</i> <tt>out</tt>.
</p>
</blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const charT* s);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const char* s);
<ins>template&lt;class traits&gt;
  basic_ostream&lt;wchar_t,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;wchar_t,traits&gt;&amp; out,
                                            const wchar_t* s);</ins>
											
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const signed char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const unsigned char* s);
</pre><blockquote>
<p>
-3- <i>Requires:</i> <tt>s</tt> shall not be a null pointer.
<p/>
-4- <i>Effects:</i> Behaves like a formatted inserter (as described in 27.7.3.6.1 [ostream.formatted.reqmts]) of <tt>out</tt>. 
Creates a character sequence <tt>seq</tt> of <tt>n</tt> characters starting at <tt>s</tt>, each widened using <tt>out.widen()</tt> 
(27.5.5.3), where <tt>n</tt> is the number that would be computed as if by:
</p>
<ul>
<li><p>
<tt>traits::length(s)</tt> for the <ins>following</ins> overload<ins>s:</ins>
<ul>
<li><p>
where the first argument is of type <tt>basic_ostream&lt;charT, traits&gt;&amp;</tt> 
and the second is of type <tt>const charT*</tt>,
</p></li>
<li><p>
<del>and also for the overload</del> where the first argument is of type 
<tt>basic_ostream&lt;char, traits&gt;&amp;</tt> and the second is of type <tt>const char*</tt>,
</p></li>
<li><p>
<ins>where the first argument is of type 
<tt>basic_ostream&lt;wchar_t, traits&gt;&amp;</tt> and the second is of type <tt>const wchar_t*</tt>,</ins>
</p></li>
</ul> 
</p></li>
<li><p>
<tt>std::char_traits&lt;char&gt;::length(s)</tt> for the overload where the first argument is of type
<tt>basic_ostream&lt;charT, traits&gt;&amp;</tt> and the second is of type <tt>const char*</tt>,
</p></li>
<li><p>
<tt>traits::length(reinterpret_cast&lt;const char*&gt;(s))</tt> for the other two overloads.
</p></li>
</ul>
<p>
Determines padding for <tt>seq</tt> as described in 27.7.3.6.1 [ostream.formatted.reqmts]. Inserts <tt>seq</tt> into 
<tt>out</tt>. Calls <tt><ins>out.</ins>width(0)</tt>.
<p/>
-5- <i>Returns:</i> <tt>out</tt>.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2343" href="#2343">2343.</a> Is the value of the ECMA-262 RegExp object's multiline property really false?</h3>
<p><b>Section:</b> 28.13 [re.grammar] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Nayuta Taga <b>Opened:</b> 2013-10-30 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the following "Multiline" is the value of the ECMA-262 RegExp object's multiline property.
<p/>
In <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">ECMA-262</a>, 
there are some definitions that relate to Multiline:
</p>
<ul>
<li><p>
ECMA-262 15.10.2.6:
</p>
<blockquote>
<p>
If Multiline is true, ^ matches just after LineTerminator.
<p/>
If Multiline is false, ^ does not match just after LineTerminator.
<p/>
If Multiline is true, $ matches just before LineTerminator.
<p/>
If Multiline is false, $ does not match just before LineTerminator.
</p>
</blockquote>
</li>
<li>
<p>
ECMA-262 15.10.4.1, 15.10.7.4:
</p>
<blockquote><p>
By default, Multiline is false.
</p></blockquote>
</li>
</ul>
<p>
So, the C++11 standard says that Multiline is false. As it is false,
^ matches only the beginning of the string, and $ matches only the end
of the string.
<p/>
However, two flags are defined in 28.5.2 [re.matchflag] Table 139:
</p>
<blockquote>
<p>
<tt>match_not_bol</tt>: the character ^ in the regular expression shall not match <tt>[first,first)</tt>.
<p/>
<tt>match_not_eol</tt>: the character "$" in the regular expression shall not match <tt>[last,last)</tt>.
</p>
</blockquote>
<p>
As Multiline is false, the <tt>match_not_bol</tt> and the <tt>match_not_eol</tt> are
meaningless because they only make ^ and $ match none.
<p/>
In my opinion, Multiline should be true.
<p/>
FYI, Multiline of the existing implementations are as follows:
<p/>
<em>Multiline=false:</em>
</p>
<ul>
<li><p>
libstdc++ r206594
</p></li>
<li><p>
libc++ r199174
</p></li>
</ul>
<p>
<em>Multiline=true:</em>
</p>
<ul>
<li><p>
Visual Studio Express 2013
</p></li>
<li><p>
boost 1.55
</p></li>
</ul>

<p><i>[2015-05-22, Daniel comments]</i></p>

<p>
This issue interacts with LWG <a href="lwg-active.html#2503">2503</a>.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Resolving <a href="lwg-active.html#2503">2503</a> will resolve this as well.</p>


<p><b>Proposed resolution:</b></p>
<p>Resolved by LWG <a href="lwg-active.html#2503">2503</a>.</p>





<hr>
<h3><a name="2348" href="#2348">2348.</a> <tt>charT('1')</tt> is not the wide equivalent of <tt>'1'</tt></h3>
<p><b>Section:</b> 20.9 [template.bitset], 27.7.6 [quoted.manip] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#template.bitset">active issues</a> in [template.bitset].</p>
<p><b>View all other</b> <a href="lwg-index.html#template.bitset">issues</a> in [template.bitset].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Example: <tt>char16_t('1') != u'1'</tt> is possible.
<p/>
The numeric value of <tt>char16_t</tt> is defined to be Unicode
code point, which is same to the ASCII value and UTF-8 for
7-bit chars.  However, <tt>char</tt> is not guaranteed to have an
encoding which is compatible with ASCII. For example, <tt>'1'</tt> in EBCDIC is 241.
<p/>
I found three places in the standard casting narrow char
literals: <tt>bitset::bitset</tt>, <tt>bitset::to_string</tt> and <tt>quoted</tt>.
<p/>
PJ confirmed this issue and says he has a solution used
in their <tt>&lt;filesystem&gt;</tt> implementation, and he may want to
propose it to the standard.
<p/>
The solution in my mind, for now, is to make those default
arguments magical, where the "magic" can be implemented
with a C11 <tt>_Generic</tt> selection (works in clang):
</p>
<blockquote><pre>
#define _G(T, literal) _Generic(T{}, \
      char: literal, \
      wchar_t: L ## literal, \
      char16_t: u ## literal, \
      char32_t: U ## literal)

  _G(char16_t, '1') == u'1'
</pre></blockquote>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Ask for complete PR (need quoted, to string, et al.)</p>
<p>Will then take it up again</p>
<p>Expectation is that this is correct way to fix this</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

[<i>Drafting note:</i> This is a sample wording fixing only one case;
 I'm just too lazy to copy-paste it before we discussed whether
 the solution is worth and sufficient (for example, should the
 other `charT`s like `unsigned char` just don't compile without
 supplying those arguments?  I hope so). &mdash; <i>end drafting note</i>]

<ol>
<li><p>Modify 20.9 [template.bitset] p1, class template <tt>bitset</tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;size_t N&gt; class bitset {
  public:
    [&hellip;]
    template&lt;class charT, class traits, class Allocator&gt;
      explicit bitset(
        const basic_string&lt;charT,traits,Allocator&gt;&amp; str,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type pos = 0,
        typename basic_string&lt;charT,traits,Allocator&gt;::size_type n =
          basic_string&lt;charT,traits,Allocator&gt;::npos,
          charT zero = <del>charT('0')</del><ins><em>see below</em></ins>, charT one = <del>charT('1')</del><ins><em>see below</em></ins>);
     [&hellip;]
  };
  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Modify 20.9.1 [bitset.cons] as indicated:</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
explicit 
bitset(const basic_string&lt;charT, traits, Allocator&gt;&amp; str,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type pos = 0,
       typename basic_string&lt;charT, traits, Allocator&gt;::size_type n =
         basic_string&lt;charT, traits, Allocator&gt;::npos,
         charT zero = <del>charT('0')</del><ins><em>see below</em></ins>, charT one = <del>charT('1')</del><ins><em>see below</em></ins>);
</pre><blockquote>
<p>
<ins>-?- The default values of <tt>zero</tt> and <tt>one</tt> compare equal to the
character literals <tt>0</tt> and <tt>1</tt> of type <tt>charT</tt>, respectively.</ins>
<p/>
-3- <i>Requires::</i> <tt>pos &lt;= str.size()</tt>.
<p/>
[&hellip;]
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2349" href="#2349">2349.</a> Clarify input/output function rethrow behavior</h3>
<p><b>Section:</b> 27.7.2.2.1 [istream.formatted.reqmts] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2013-12-06 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.formatted.reqmts">issues</a> in [istream.formatted.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The formatted input function requirement says in 27.7.2.2.1 [istream.formatted.reqmts]:
</p>
<blockquote><p>
"If an exception is thrown during input then <tt>ios::badbit</tt> is turned on
in <tt>*this</tt>'s error state.  If <tt>(exceptions()&amp;badbit) != 0</tt> then the exception
is rethrown."
</p></blockquote>
<p>
while some formatted function may throw an exception from <tt>basic_ios::clear</tt>, for example
in 20.9.4 [bitset.operators] p6:
</p>
<blockquote><p>
"If no characters are stored in <tt>str</tt>, calls <tt>is.setstate(ios_base::failbit)</tt> (which may 
throw <tt>ios_base::failure</tt>)"
</p></blockquote>
<p>
So should this exception be considered as "an exception [...] thrown
during input"?  And here is an implementation divergence (or you
can read the following as "a bug libc++ only has" :)
</p>
<blockquote><pre>
cin.exceptions(ios_base::failbit);
bitset&lt;N&gt; b;
try {
  cin &gt;&gt; b;  // type 'a' and return
} catch (...)
{}
</pre></blockquote>
<p>
Now <tt>cin.rdstate()</tt> is just <tt>failbit</tt> in libstdc++ (and Dinkumware, by
PJ), but <tt>failbit &amp; badbit</tt> libc++. Similar difference found in other
places, like <tt>eofbit &amp; badbid</tt> after <tt>std::getline</tt>.
<p/>
PJ and Matt both agree that the intention (of <tt>badbit</tt> + rethrow) is
"to signify an exception arising in user code, not the iostreams package".
<p/>
In addition, I found the following words in unformatted input
function's requirements (27.7.2.3 [istream.unformatted]):
</p>
<blockquote><p>
If an exception is thrown during input then <tt>ios::badbit</tt> is turned on
in <tt>*this</tt>'s error state. (Exceptions thrown from <tt>basic_ios&lt;&gt;::clear()</tt>
are not caught or rethrown.)  If <tt>(exceptions()&amp;badbit) != 0</tt> then the
exception is rethrown.
</p></blockquote>
<p>
The content within the parenthesis is added by LWG defect <a href="lwg-defects.html#61">61</a>,
and does fix the ambiguity. However, it only fixed the 1 of 4
requirements, and it lost some context (the word "rethrown" is not
seen before this sentence within this section).
</p>

<p><i>[Lenexa 2015-05-07: Marshall to research and report]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

[<i>Drafting note:</i> The editor is kindly asked to introduce additional spaces at the following marked occurrences of
<tt>operator&amp;</tt> &mdash; <i>end drafting note</i>]

<ol>
<li><p>Modify 27.7.2.2.1 [istream.formatted.reqmts] p1 as indicated:</p>

<blockquote><p>
-1- Each formatted input function begins execution by constructing an object of class <tt>sentry</tt> with the <tt>noskipws</tt>
(second) argument false. If the <tt>sentry</tt> object returns true, when converted to a value of type <tt>bool</tt>, the
function endeavors to obtain the requested input. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> 
is thrown during input then <tt>ios::badbit</tt>
is turned on[Footnote 314] in <tt>*this</tt>'s error state. If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> 
then the exception is rethrown.
In any case, the formatted input function destroys the <tt>sentry</tt> object. If no exception has been thrown, it returns <tt>*this</tt>.
</p></blockquote>
</li>

<li><p>Modify 27.7.3.6.1 [ostream.formatted.reqmts] p1 as indicated:</p>

<blockquote><p>
-1- Each formatted output function begins execution by constructing an object of class <tt>sentry</tt>. If this object
returns true when converted to a value of type <tt>bool</tt>, the function endeavors to generate the requested
output. If the generation fails, then the formatted output function does <tt>setstate(ios_base::failbit)</tt>,
which might throw an exception. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> is thrown 
during output, then <tt>ios::badbit</tt> is turned on[Footnote 327]
in <tt>*this</tt>'s error state. If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> then the exception is rethrown. 
Whether or not
an exception is thrown, the <tt>sentry</tt> object is destroyed before leaving the formatted output function. If no
exception is thrown, the result of the formatted output function is <tt>*this</tt>.
</p></blockquote>
</li>

<li><p>Modify 27.7.3.7 [ostream.unformatted] p1 as indicated:</p>

<blockquote><p>
-1- Each unformatted output function begins execution by constructing an object of class <tt>sentry</tt>. If this object
returns true, while converting to a value of type <tt>bool</tt>, the function endeavors to generate the requested
output. If an exception<ins>, other than the ones thrown from <tt>clear()</tt>, if any,</ins> is thrown during output, 
then ios::badbit is turned on[Footnote 330] in <tt>*this</tt>'s error state.
If <tt>(exceptions() &amp; badbit) != 0</tt> then the exception is rethrown. In any case, the unformatted output
function ends by destroying the <tt>sentry</tt> object, then, if no exception was thrown, returning the value specified
for the unformatted output function.
</p></blockquote>
</li>

<li><p>Modify 27.7.2.3 [istream.unformatted] p1 as indicated:</p>

<blockquote><p>
-1- Each unformatted input function begins execution by constructing an object of class <tt>sentry</tt> with the default
argument <tt>noskipws</tt> (second) argument true. If the <tt>sentry</tt> object returns true, when converted to a value
of type <tt>bool</tt>, the function endeavors to obtain the requested input. Otherwise, if the <tt>sentry</tt> constructor exits
by throwing an exception or if the sentry object returns false, when converted to a value of type <tt>bool</tt>, the
function returns without attempting to obtain any input. In either case the number of extracted characters
is set to <tt>0</tt>; unformatted input functions taking a character array of non-zero size as an argument shall also
store a null character (using <tt>charT()</tt>) in the first location of the array. If an exception<ins>, other than the 
ones thrown from <tt>clear()</tt>, if any,</ins> is thrown during input
then <tt>ios::badbit</tt> is turned on[Footnote 317] in <tt>*this</tt>'s error state. <del>(Exceptions thrown from 
<tt>basic_ios&lt;&gt;::clear()</tt> are not caught or rethrown.)</del> If <tt>(exceptions()<ins> </ins>&amp;<ins> </ins>badbit) != 0</tt> 
then the exception is rethrown. It also counts the number of characters extracted. If no exception has been thrown it ends 
by storing the count in a member object and returning the value specified. In any event the <tt>sentry</tt> object is destroyed 
before leaving the unformatted input function.
</p></blockquote>
</li>

</ol>






<hr>
<h3><a name="2352" href="#2352">2352.</a> Is a default-constructed <tt>std::seed_seq</tt> intended to produce a predictable <tt>.generate()</tt>?</h3>
<p><b>Section:</b> 26.6.7.1 [rand.util.seedseq] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas Plum <b>Opened:</b> 2013-12-02 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With respect to class <tt>seed_seq</tt> 26.6.7.1 [rand.util.seedseq], is a default-constructed 
<tt>std::seed_seq</tt> intended to produce a predictable <tt>.generate()</tt> sequence?
<p/>
Implementations differ.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2358" href="#2358">2358.</a> Apparently-bogus definition of <tt>is_empty</tt> type trait</h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-02-01 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The 'Condition' for <tt>std::is_empty</tt> is listed as:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no non-static data members other than bit-fields of length 0, 
no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which <tt>is_empty&lt;B&gt;::value</tt> 
is false."
</p></blockquote>
<p>
This is incorrect: there is no such thing as a non-static data member that is a bit-field of length 0, since bit-fields of 
length 0 must be unnamed, and unnamed bit-fields are not members (see 9.2.4 [class.bit] p2).
<p/>
It also means that classes such as:
</p>
<blockquote><pre>
struct S {
 int : 3;
};
</pre></blockquote>
<p>
are empty (because they have no non-static data members). There's implementation divergence on the value of 
<tt>is_empty&lt;S&gt;::value</tt>.
<p/>
I'm not sure what the purpose of <tt>is_empty</tt> is (or how it could be useful), but if it's desirable for the above type to 
not be treated as empty, something like this could work:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no non-static data members <del>other than</del><ins>, no unnamed</ins> 
bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class 
<tt>B</tt> for which <tt>is_empty&lt;B&gt;::value</tt> is false."
</p></blockquote>
<p>
and if the above type <em>should</em> be treated as empty, then this might be appropriate:
</p>
<blockquote><p>
"<tt>T</tt> is a class type, but not a union type, with no <ins>(named)</ins> non-static data members <del>other than bit-fields of 
length 0</del>, no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which 
<tt>is_empty&lt;B&gt;::value</tt> is false."
</p></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Walter says: We want <tt>is_empty_v&lt;S&gt;</tt> to produce false as a result.  Therefore, we recommend adoption of the first of the issue's suggestions.</p>
<p>Tuesday AM: Moved to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<p><i>[2016-10 by Marshall - this PR incorrectly highlighted changed portions]</i></p>


<blockquote class="note">
<p>Modify Table 38  Type property predicates for <tt>is_empty</tt> as follows:</p>
<blockquote><p>
<tt>T</tt> is a non-union class type with no non-static data members <del>other than</del><ins>, no unnamed</ins> bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which <tt>is_empty_v&lt;B&gt;</tt> is false.</p>
</blockquote>
</blockquote>

<p><i>[2016-10 Telecom]</i></p>

<p>Should probably point at section 1.8 for some of this. Status back to 'Open'</p>


<p><b>Proposed resolution:</b></p>
<p>Modify Table 38  Type property predicates for <tt>is_empty</tt> as follows:</p>
<blockquote><p>
<tt>T</tt> <del>is a class type, but not a union type,</del><ins>is a non-union class type</ins> with no non-static data members<del> other than</del><ins>, no unnamed</ins> bit-fields of <ins>non-zero</ins> length <del>0</del>, no virtual member functions, no virtual base classes, and no base class <tt>B</tt> for which <tt>is_empty_v&lt;B&gt;</tt> is false.</p>
</blockquote>





<hr>
<h3><a name="2362" href="#2362">2362.</a> unique, associative <tt>emplace()</tt> should not move/copy the <tt>mapped_type</tt> constructor 
arguments when no insertion happens</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-02-15 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>a_uniq.emplace(args)</tt> is specified as:
</p>

<blockquote><p>
<i>Effects</i>: Inserts a value_type object <tt>t</tt> constructed with<br/>
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element in the<br/>
container with key equivalent to the key of <tt>t</tt>. The <tt>bool</tt> component of<br/>
the returned pair is true if and only if the insertion takes place,<br/>
and the iterator component of the pair points to the element with key<br/>
equivalent to the key of <tt>t</tt>. 
</p></blockquote>

<p>
However, we occasionally find code of the form:
</p>

<blockquote><pre>
std::unique_ptr&lt;Foo&gt; p(new Foo);
auto res = m.emplace("foo", std::move(p));
</pre></blockquote>

<p>
where we'd like to avoid destroying the <tt>Foo</tt> if the insertion doesn't
take place (if the container already had an element with the specified key).
<p/>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3873">N3873</a> includes
a partial solution to this in the form of a new <tt>emplace_stable</tt> member function, but LEWG's 
discussion strongly agreed that we'd rather have <tt>emplace()</tt> Just Work:
<p/>
Should <tt>map::emplace()</tt> be guaranteed not to move/copy its arguments if the insertion doesn't happen?
<p/>
SF: 8 F: 3 N: 0 A: 0 SA: 0
<p/>
This poll was marred by the fact that we didn't notice or call out
that <tt>emplace()</tt> must construct the key before doing the lookup, and it
must not then move the key after it determines whether an insert is
going to happen, and the <tt>mapped_type</tt> instance must live next to the key.
<p/>
The very similar issue <a href="lwg-closed.html#2006">2006</a> was previously marked NAD, with
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3178.htm">N3178</a> as
discussion. However, given LEWG's interest in the alternate behavior,
we should reopen the question in this issue.
<p/>
We will need a paper that describes how to implement this before we can make more progress.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2363" href="#2363">2363.</a> Defect in 30.4.1.4.1 [thread.sharedtimedmutex.class]</h3>
<p><b>Section:</b> 30.4.1.5.1 [thread.sharedtimedmutex.class] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-02-16 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.4.1.5.1 [thread.sharedtimedmutex.class] paragraph 2: 
</p>
<blockquote><p> The class <tt>shared_timed_mutex</tt> shall satisfy all of the 
<tt>SharedTimedMutex</tt> requirements (30.4.1.4). It shall be a standard layout class (Clause 9).
</p></blockquote> 
<p>
There's no <tt>SharedTimedMutex</tt> requirements; this name doesn't appear anywhere else in the standard. (Prior to N3891, 
this was <tt>SharedMutex</tt>, which was equally undefined.)
<p/>
I assume this concept should be defined somewhere?
<p/>
Also, n3891 changes 30.4.1.5 [thread.sharedtimedmutex.requirements] from defining "shared mutex type" to defining 
"shared timed mutex type", but its paragraph 2 still talks about "shared mutex type". Is that OK? I think you could argue 
that it's clear enough what it means, but presumably it should use the term that paragraph 1 defined.
<p/>
30.4.2.3 [thread.lock.shared] paragraph 1 talks about the "shared mutex requirements", which again is a term that isn't 
defined, and presumably means "the requirements on a shared timed mutex type" or similar (maybe if <tt>SharedMutex</tt> or 
<tt>SharedTimedMutex</tt> were defined it could be reused here).
</p>

<p><i>[2014-05-22, Daniel comments]</i></p>

<p>
As for <tt>SharedTimedMutex</tt>, there exists a similar problem in regard to <tt>TimedMutex</tt> referred to in
30.4.1.3.1 [thread.timedmutex.class] p2 and in 30.4.1.3.2 [thread.timedmutex.recursive] p2, but nowhere defined.
<p/>
Another problem is, that according to 30.4.1.2.1 [thread.mutex.class] p3, "The class <tt>mutex</tt> shall satisfy all the 
<tt>Mutex</tt> requirements (30.4.1 [thread.mutex.requirements]).", but there are no concrete <tt>Mutex</tt> requirements,
30.4.1 [thread.mutex.requirements] &mdash; titled as "Mutex requirements" &mdash; describes <em>mutex types</em>,
<em>timed mutex types</em>, and <em>shared timed mutex types</em>.
</p>

<p><i>[2014-06-08, Daniel comments and provides wording]</i></p>

<p>
The presented wording adds to the existing <em>mutex types</em>, <em>timed mutex types</em>, and <em>shared timed mutex types</em> 
terms a new set of corresponding <tt>MutexType</tt>, <tt>TimedMutexType</tt>, and <tt>SharedTimedMutexType</tt> requirements. 
<p/>
The reason for the change of requirement names is two-fold: First, the new name better matches the intention to have a concrete 
name for the requirements imposed on the corresponding <em>mutex types</em> (This kind of requirement deviate from the more general
<tt>Lockable</tt> requirements, which are not restricted to a explicitly enumerated set of library types). Second, using 
<tt>**MutexType</tt> over <tt>**Mutex</tt> provides the additional advantage that it reduces the chances of confusing named 
requirements from template parameters named <tt>Mutex</tt> (such as for <tt>unique_lock</tt> or <tt>shared_lock</tt>).
<p/>
Nonetheless the here presented wording has one unfortunate side-effect: Once applied it would have the effect that types
used to instantiate <tt>std::shared_lock</tt> cannot be user-defined shared mutex types due to 30.4.2.3 [thread.lock.shared]. 
The reason is based on the currently lack of an existing <tt>SharedLockable</tt> requirement set, which would complete the 
existing <tt>BasicLockable</tt> and <tt>Lockable</tt> requirements (which are "real" requirements). This restriction is not
actually a problem introduced by the provided resolution but instead one that existed before but becomes more obvious now.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>

<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
Thanks to Daniel, and please put it in SG1-OK status. Perhaps open another issue for the remaining problem Daniel points out?
</p>

<p><i>[2015-10 pre-Kona]</i></p>

<p>
SG1 hands this over to LWG for wording review
</p>

<p><i>[2015-10-21 Kona, Daniel comments and adjusts wording to to untimed shared mutex types]</i></p>

<p>
The new wording reflects the addition of the new shared mutex types. The approach used for <tt>shared_lock</tt>
is similar to the one used for <tt>unique_lock</tt>: The template argument <tt>Mutex</tt> has a reduced requirement set that is not
sufficient for <em>all</em> operations. Only those members that require stronger requirements of <tt>SharedTimedMutexType</tt>
specify that additionally in the <i>Requires</i> element of the corresponding prototype specifications.
<p/>
The proposed wording could be more general if we would introduce more fundamental requirements set for <tt>SharedLockable</tt>
and <tt>SharedTimedLockable</tt> types which could be satisfied by user-provided types as well, because the 
<tt>SharedMutexType</tt> and <tt>SharedTimedMutexType</tt> requirements are essentially restricted to an enumerated set of
types provided by the Standard Library. But this extension seemed too large for this issue and can be easily fixed later
without any harm. 
</p>

<p><b>Previous resolution [SUPERSEDED]:</b></p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 30.4.1.2 [thread.mutex.requirements.mutex] as indicated:</p>

<blockquote><p>
-1- The <em>mutex types</em> are the standard library types <tt>std::mutex</tt>, <tt>std::recursive_mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_timed_mutex</tt>, and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>MutexType</em></tt></ins> 
requirements set out in this section. In this description, <tt>m</tt> denotes an object of a mutex type.
</p></blockquote>
</li>

<li><p>Change 30.4.1.2.1 [thread.mutex.class] as indicated:</p>

<blockquote><p>
-3- The class <tt>mutex</tt> shall satisfy all the <tt>Mutex<ins>Type</ins></tt> requirements 
(<ins>30.4.1.2 [thread.mutex.requirements.mutex]</ins><del>30.4.1 [thread.mutex.requirements]</del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.2.2 [thread.mutex.recursive] as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_mutex</tt> shall satisfy all the <del>Mutex</del><ins><tt>MutexType</tt></ins> requirements 
(<ins>30.4.1.2 [thread.mutex.requirements.mutex]</ins><del>30.4.1 [thread.mutex.requirements]</del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3 [thread.timedmutex.requirements] as indicated:</p>

<blockquote><p>
-1- The <em>timed mutex types</em> are the standard library types <tt>std::timed_mutex</tt>, <tt>std::recursive_timed_mutex</tt>,
and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>TimedMutexType</em></tt></ins> requirements set out below. 
In this description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_time</tt> denotes an object of an instantiation of 
<tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3.1 [thread.timedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.3 [thread.timedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3.2 [thread.timedmutex.recursive] as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.3 [thread.timedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.5 [thread.sharedtimedmutex.requirements] as indicated: [<i>Drafting note</i>: The reference to the
timed mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedTimedMutexType</tt> <em>refine</em> <tt>TimedMutexType</tt>.]</p>

<blockquote>
<p>
-1- The standard library type <tt>std::shared_timed_mutex</tt> is a <em>shared timed mutex type</em>. Shared timed mutex
types shall meet the <ins><tt><em>SharedTimedMutexType</em></tt></ins> requirements <del>of timed mutex types 
(30.4.1.3 [thread.timedmutex.requirements]), and additionally shall meet the requirements</del> set out below. In this 
description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_type</tt> denotes
an object of an instantiation of <tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of
<tt>time_point</tt> (20.12.6).
<p/>
<ins>-?- The shared timed mutex types shall meet the <tt>TimedMutexType</tt> requirements (30.4.1.3 [thread.timedmutex.requirements]).</ins>
</p>
</blockquote>
</li>

<li><p>Change 30.4.1.5.1 [thread.sharedtimedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_timed_mutex</tt> shall satisfy all of the <tt>SharedTimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.2.3 [thread.lock.shared] as indicated: [<i>Drafting note</i>: Once 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3995.htm">N3995</a> has been applied, the following 
reference should be changed to the new <tt>SharedMutexType</tt> requirements ([thread.sharedmutex.requirements]) or 
even better to some new <tt>SharedLockable</tt> requirements (to be defined) &mdash; <i>end drafting note</i>]</p>

<blockquote><p>
-1- [&hellip;] The supplied <tt>Mutex</tt> type shall meet the <del>shared mutex</del><ins><tt>SharedTimedMutexType</tt></ins> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).
<p/>
-2- [<i>Note</i>: <tt>shared_lock&lt;Mutex&gt;</tt> meets the <tt>TimedLockable</tt> requirements 
(30.2.5.4). &mdash; <i>end note</i>]
</p></blockquote>
</li>
</ol>

</blockquote>

<p><i>[2016-02 Jacksonville]</i></p>

<p>
Marshall to review wording.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<ol>
<li><p>Change 30.4.1.2 [thread.mutex.requirements.mutex] as indicated:</p>

<blockquote><p>
-1- The <em>mutex types</em> are the standard library types <tt>std::mutex</tt>, <tt>std::recursive_mutex</tt>, <tt>std::timed_mutex</tt>,
<tt>std::recursive_timed_mutex</tt>, <tt>std::shared_mutex</tt>, and <tt>std::shared_timed_mutex</tt>. They shall meet the 
<ins><tt><em>MutexType</em></tt></ins> requirements set out in this section. In this description, <tt>m</tt> denotes an object 
of a mutex type.
<p/>
-2- The mutex types shall meet the <tt>Lockable</tt> requirements (30.2.5.3 [thread.req.lockable.req]).
</p></blockquote>
</li>

<li><p>Change 30.4.1.2.1 [thread.mutex.class] as indicated:</p>

<blockquote><p>
-3- The class <tt>mutex</tt> shall satisfy all the <tt>Mutex<ins>Type</ins></tt> requirements 
(<ins>30.4.1.2 [thread.mutex.requirements.mutex]</ins><del>30.4.1 [thread.mutex.requirements]</del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.2.2 [thread.mutex.recursive] as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_mutex</tt> shall satisfy all the <del>Mutex</del><ins><tt>MutexType</tt></ins> requirements 
(<ins>30.4.1.2 [thread.mutex.requirements.mutex]</ins><del>30.4.1 [thread.mutex.requirements]</del>). 
It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3 [thread.timedmutex.requirements] as indicated:</p>

<blockquote><p>
-1- The <em>timed mutex types</em> are the standard library types <tt>std::timed_mutex</tt>, <tt>std::recursive_timed_mutex</tt>,
and <tt>std::shared_timed_mutex</tt>. They shall meet the <ins><tt><em>TimedMutexType</em></tt></ins> requirements set out below. 
In this description, <tt>m</tt> denotes an object of a mutex type, <tt>rel_time</tt> denotes an object of an instantiation of 
<tt>duration</tt> (20.12.5), and <tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
<p/>
-2- The timed mutex types shall meet the <tt>TimedLockable</tt> requirements (30.2.5.4 [thread.req.lockable.timed]).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3.1 [thread.timedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.3 [thread.timedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.3.2 [thread.timedmutex.recursive] as indicated:</p>

<blockquote><p>
-2- The class <tt>recursive_timed_mutex</tt> shall satisfy all of the <tt>TimedMutex<ins>Type</ins></tt> requirements 
(30.4.1.3 [thread.timedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.4 [thread.sharedmutex.requirements] as indicated:  [<i>Drafting note</i>: The reference to the
mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedMutexType</tt> <em>refines</em> <tt>MutexType</tt>.]</p>

<blockquote><p>
-1- The standard library types <tt>std::shared_mutex</tt> and <tt>std::shared_timed_mutex</tt> are <em>shared mutex types</em>.
Shared mutex types shall meet the <ins><tt><em>SharedMutexType</em></tt></ins> requirements <del>of mutex types 
(30.4.1.2 [thread.mutex.requirements.mutex]), and additionally shall meet the 
requirements</del> set out below. In this description, <tt>m</tt> denotes an object of a shared mutex type.
<p/>
<ins>-?- The shared mutex types shall meet the <tt>MutexType</tt> requirements (30.4.1.2 [thread.mutex.requirements.mutex]).</ins>
</p>
</blockquote>
</li>

<li><p>Change 30.4.1.4.1 [thread.sharedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_mutex</tt> shall satisfy all of the <ins><tt>SharedMutexType</tt></ins> requirements 
<del>for shared mutexes</del> (30.4.1.4 [thread.sharedmutex.requirements]). It shall be a standard-layout class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.1.5 [thread.sharedtimedmutex.requirements] as indicated: [<i>Drafting note</i>: The reference to the
timed mutex types requirements has been moved <em>after</em> introducing the new requirement set to ensure that 
<tt>SharedTimedMutexType</tt> <em>refines</em> <tt>TimedMutexType</tt> and <tt>SharedMutexType</tt>.]</p>

<blockquote>
<p>
-1- The standard library type <tt>std::shared_timed_mutex</tt> is a <em>shared timed mutex type</em>. Shared timed mutex
types shall meet the <ins><tt><em>SharedTimedMutexType</em></tt></ins> requirements <del>of timed mutex types 
(30.4.1.3 [thread.timedmutex.requirements]), shared mutex types (30.4.1.4 [thread.sharedmutex.requirements]), 
and additionally shall meet the requirements</del> set out below. In this description, <tt>m</tt> denotes an object of 
a shared timed mutex type, <tt>rel_type</tt> denotes an object of an instantiation of <tt>duration</tt> (20.12.5), and 
<tt>abs_time</tt> denotes an object of an instantiation of <tt>time_point</tt> (20.12.6).
<p/>
<ins>-?- The shared timed mutex types shall meet the <tt>TimedMutexType</tt> requirements (30.4.1.3 [thread.timedmutex.requirements])
and the <tt>SharedMutexType</tt> requirements (30.4.1.4 [thread.sharedmutex.requirements]).</ins>
</p>
</blockquote>
</li>

<li><p>Change 30.4.1.5.1 [thread.sharedtimedmutex.class] as indicated:</p>

<blockquote><p>
-2- The class <tt>shared_timed_mutex</tt> shall satisfy all of the <ins><tt>SharedTimedMutexType</tt></ins> requirements 
<del>for shared timed mutexes</del> (30.4.1.5 [thread.sharedtimedmutex.requirements]). It shall be a standard-layout 
class (Clause 9).
</p></blockquote>
</li>

<li><p>Change 30.4.2.3 [thread.lock.shared] as indicated:</p>

<blockquote><p>
-1- [&hellip;] The supplied <tt>Mutex</tt> type shall meet the <del>shared mutex</del><ins><tt>SharedMutexType</tt></ins> requirements 
(<del>30.4.1.5 [thread.sharedtimedmutex.requirements]</del><ins>30.4.1.4 [thread.sharedmutex.requirements]</ins>).
<p/>
-2- [<i>Note</i>: <tt>shared_lock&lt;Mutex&gt;</tt> meets the <tt>TimedLockable</tt> requirements 
(30.2.5.4). &mdash; <i>end note</i>]
</p></blockquote>
</li>

<li><p>Change 30.4.2.3.1 [thread.lock.shared.cons] as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration&gt;
  shared_lock(mutex_type&amp; m,
              const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote>
<p>
-14- <i>Requires</i>: <ins>The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).</ins> 
The calling thread does not own the mutex for any ownership mode.
<p/>
-15- <i>Effects</i>: Constructs an object of type <tt>shared_lock</tt> and calls <tt>m.try_lock_shared_until(abs_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class Rep, class Period&gt;
  shared_lock(mutex_type&amp; m,
              const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p>
-17- <i>Requires</i>: <ins>The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).</ins> 
The calling thread does not own the mutex for any ownership mode.
<p/>
-18- <i>Effects</i>: Constructs an object of type <tt>shared_lock</tt> and calls <tt>m.try_lock_shared_for(rel_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Change 30.4.2.3.2 [thread.lock.shared.locking] as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration&gt;
  bool
  try_lock_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).</ins>
<p/>
-8- <i>Effects</i>: <tt>pm-&gt;try_lock_shared_until(abs_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class Rep, class Period&gt;
  bool try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: The supplied <tt>Mutex</tt> type shall meet the <tt>SharedTimedMutexType</tt> requirements 
(30.4.1.5 [thread.sharedtimedmutex.requirements]).</ins>
<p/>
-12- <i>Effects</i>: <tt>pm-&gt;try_lock_shared_for(rel_time)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2366" href="#2366">2366.</a> <tt>istreambuf_iterator</tt> end-of-stream equality</h3>
<p><b>Section:</b> 24.6.3 [istreambuf.iterator] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hyman Rosen <b>Opened:</b> 2014-02-19 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istreambuf.iterator">issues</a> in [istreambuf.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given the following code,
</p>
<blockquote><pre>
#include &lt;sstream&gt;

std::stringbuf buf;
std::istreambuf_iterator&lt;char&gt; begin(&amp;buf);
std::istreambuf_iterator&lt;char&gt; end;
</pre></blockquote>
<p>
it is not clear from the wording of the Standard whether <tt>begin.equal(end)</tt>
must be true. In at least one implementation it is not (CC: Sun C++ 5.10 SunOS_sparc Patch 128228-25 2013/02/20) and in at least
one implementation it is (gcc version 4.3.2 x86_64-unknown-linux-gnu).
<p/>
24.6.3 [istreambuf.iterator] says that <tt>end</tt> is an end-of-stream iterator since it was default
constructed. It also says that an iterator becomes equal to an end-of-stream
iterator when end of stream is reached by <tt>sgetc()</tt> having returned <tt>eof()</tt>.
24.6.3.5 [istreambuf.iterator::equal] says that <tt>equal()</tt> returns true iff both iterators are end of stream
or not end of stream. But there seems to be no requirement that <tt>equal</tt> check for end-of-stream by calling <tt>sgetc()</tt>. 
<p/>
Jiahan Zi at BloombergLP discovered this issue through his code failing to
work correctly. Dietmar K&uuml;hl has opined in a private communication that
the iterators should compare equal.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2368" href="#2368">2368.</a> Replacing global <tt>operator new</tt></h3>
<p><b>Section:</b> 18.6.2 [new.delete] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephen Clamage <b>Opened:</b> 2014-02-20 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete">issues</a> in [new.delete].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 18.6.2 [new.delete] and subsections shows:
</p>
<blockquote><pre>
void* operator new(std::size_t size);
void* operator new[](std::size_t size);
</pre></blockquote>
<p>
That is, without exception-specifications. (Recall that C++03 specified these functions with <tt>throw(std::bad_alloc)</tt>.)
<p/>
Section 17.6.5.12 [res.on.exception.handling] the end of paragraph 4 says:
</p>
<blockquote><p>
Any other functions defined in the C++ standard library that do not have an exception-specification may throw implementation-defined 
exceptions unless otherwise specified. An implementation may strengthen this implicit exception-specification by adding an explicit one.
</p></blockquote>
<p>
For example, an implementation could provide C++03-compatible declarations of <tt>operator new</tt>.
<p/>
Programmers are allowed to replace these <tt>operator new</tt> functions. But how can you write the definition of these functions when 
the exception specification can vary among implementations? For example, the declarations
</p>
<blockquote><pre>
void* operator new(std::size_t size) throw(std::bad_alloc);
void* operator new(std::size_t size);
</pre></blockquote>
<p>
are not compatible.
<p/>
From what I have been able to determine, gcc has a hack for the special case of <tt>operator new</tt> to ignore the differences in 
(at least) the two cases I show above. But can users expect all compilers to quietly ignore the incompatibility?
<p/>
The blanket permission to add any explicit exception specification could cause a problem for any user-overridable function. 
Different implementations could provide incompatible specifications, making portable code impossible to write.
</p>

<p><i>[2016-03, Jacksonville]</i></p>

<p>
STL: Core changes to remove dynamic exception specs would make this moot<br/>
Room: This is on track to be resolved by <a href="http://wg21.link/P0003">P0003</a>, or may be moot.<br/>
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2370" href="#2370">2370.</a> Operations involving type-erased allocators should not be <tt>noexcept</tt> in <tt>std::function</tt></h3>
<p><b>Section:</b> 20.14.12.2 [func.wrap.func] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2014-02-27 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following constructors in 20.14.12.2 [func.wrap.func] are declared <tt>noexcept</tt>, even
though it is not possible for an implementation to guarantee that they will not throw:
</p>

<blockquote><pre>
template &lt;class A&gt; function(allocator_arg_t, const A&amp;) noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) noexcept;
</pre></blockquote>

<p>
In addition, the following functions are guaranteed not to throw if the target
is a function pointer or a <tt>reference_wrapper</tt>:
</p>

<blockquote><pre>
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);
template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);
</pre></blockquote>

<p>
In all of the above cases, the function object might need to allocate memory
(an operation that can throw) in order to hold a copy of the type-erased
allocator itself. The first two constructors produce an empty function
object, but the allocator is still needed in case the object is later assigned
to. In this case, we note that the propagation of allocators on assignment is
underspecified for <tt>std::function</tt>. There are three possibilities:
</p>

<ol>
<li><p>The allocator is never copied on copy-assignment, moved on move-assignment, or swapped on swap.</p>
</li>

<li><p>The allocator is always copied on copy-assignment, moved on move-assignment, and swapped on swap.</p>
</li>

<li><p>Whether or not the allocator is copied, moved, or swapped is determined at
   run-time based on the <tt>propagate_on_container_copy_assignment</tt> and
   <tt>propagate_on_container_move_assignment</tt> traits of the allocators at
   construction of the source function, the target function, or both.</p>
</li>
</ol>

<p>
Although the third option seems to be the most consistent with existing
wording in the containers section of the standard, it is problematic in a
number of respects. To begin with, the propagation behavior is determined at
run time based on a pair of type-erased allocators, instead of at compile
time. Such run-time logic is <em>not</em> consistent with the rest of the standard
and is hard to reason about. Additionally, there are two allocator types
involved, rather than one. Any set of rules that attempts to rationally
interpret the propagation traits of both allocators is likely to be arcane
at best, and subtly wrong for some set of codes at worst.
</p>

<p>
The second option is a non-starter. Historically, and in the vast majority of
existing code, an allocator does not change after an object is constructed.
The second option, if adopted, would undermine the programmer's ability to
construct, e.g., an array of function objects, all using the same allocator.
</p>

<p>
The first option is (in Pablo's opinion) the simplest and best. It is
consistent with historical use of allocators, is easy to understand, and
requires minimal wording. It is also consistent with the wording in N3916,
which formalizes type-erased allocators.
</p>

<p>
For cross-referencing purposes: The resolution of this issue should be
harmonized with any resolution to LWG <a href="lwg-active.html#2062">2062</a>, which questions the <tt>noexcept</tt>
specification on the following member functions of std::function:
</p>

<blockquote><pre>
template &lt;class F&gt; function&amp; operator=(reference_wrapper&lt;F&gt;) noexcept;
void swap(function&amp;) noexcept;
</pre></blockquote>

<p><i>[2015-05 Lenexa]</i></p>

<p>
MC: change to P3 and status to open.
<p/>
STL: note that <tt>noexcept</tt> is an issue and large chunks of allocator should be destroyed.
</p>

<p><i>[2015-12-16, Daniel comments]</i></p>

<p>
See <a href="lwg-active.html#2564">2564</a> for a corresponding issue addressing library fundamentals v2.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 20.14.12.2 [func.wrap.func], class template <tt>function</tt> synopsis, as indicated:</p>

<blockquote><pre>
template &lt;class A&gt; function(allocator_arg_t, const A&amp;) <del>noexcept</del>;
template &lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) <del>noexcept</del>;
</pre></blockquote>
</li>

<li><p>Change 20.14.12.2.1 [func.wrap.func.con] as indicated:</p>

<blockquote>
<p>
-1- When any function constructor that takes a first argument of type <tt>allocator_arg_t</tt> is invoked, the second
argument shall have a type that conforms to the requirements for <tt>Allocator</tt> (Table 17.6.3.5). A copy of the
allocator argument is used to allocate memory, if necessary, for the internal data structures of the constructed
function object. <ins> For the remaining constructors, an instance of <tt>allocator&lt;T&gt;</tt>, for some suitable type
<tt>T</tt>, is used to allocate memory, if necessary, for the internal data structures of the constructed function object.</ins>
</p>

<pre>
function() noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp;) <del>noexcept</del>;
</pre>

<blockquote>
<p>
-2- <i>Postconditions</i>: <tt>!*this</tt>.
</p>
</blockquote>

<pre>
function(nullptr_t) noexcept;
template &lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) <del>noexcept</del>;
</pre>

<blockquote><p>
-3- <i>Postconditions</i>: <tt>!*this</tt>.
</p></blockquote>

<pre>
function(const function&amp; f);
<del>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);</del>
</pre>

<blockquote><p>
-4- <i>Postconditions</i>: <tt>!*this</tt> if <tt>!f</tt>; otherwise, <tt>*this</tt> targets a copy of <tt>f.target()</tt>.
</p>

<p>
-5- <i>Throws</i>: shall not throw exceptions if <tt>f</tt>'s target is a callable object passed
via <tt>reference_wrapper</tt> or a function pointer. Otherwise, may throw <tt>bad_alloc</tt>
or any exception thrown by the copy constructor of the stored callable
object. [<i>Note</i>: Implementations are encouraged to avoid the use of
dynamically allocated memory for small callable objects, for example, where
<tt>f</tt>'s target is an object holding only a pointer or reference to an object and
a member function pointer. &mdash; <i>end note</i>]
</p></blockquote>

<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);</ins>
</pre>

<blockquote><p>
<ins>-?- <i>Postconditions</i>: <tt>!*this</tt> if <tt>!f</tt>; otherwise, <tt>*this</tt> targets a copy of <tt>f.target()</tt>.</ins>
</p></blockquote>

<pre>
function(function&amp;&amp; f);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, function&amp;&amp; f);
</pre>

<blockquote><p>
-6- <i>Effects</i>: If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, move-constructs the target
of <tt>f</tt> into the target of <tt>*this</tt>, leaving <tt>f</tt> in a valid state with an
unspecified value. <ins>If an allocator is not specified, the constructed function will use the same allocator as <tt>f</tt>.</ins>
</p></blockquote>

<pre>
template&lt;class F&gt; function(F f);
template &lt;class F, class A> function(allocator_arg_t, const A&amp; a, F f);
</pre>

<blockquote>
<p>
-7- <i>Requires</i>: <tt>F</tt> shall be <tt>CopyConstructible</tt>. 
<p/>
-8- <i>Remarks</i>: These constructors shall not participate in overload resolution unless <tt>f</tt> is Callable (20.9.11.2)
for argument types <tt>ArgTypes...</tt> and return type <tt>R</tt>.
</p>

<p>
-9- <i>Postconditions</i>: <tt>!*this</tt> if any of the following hold:
</p>
<ul>
<li><p><tt>f</tt> is a null function pointer value.</p></li>
<li><p><tt>f</tt> is a null member pointer value.</p></li>
<li><p><tt>F</tt> is an instance of the function class template, and <tt>!f</tt></p></li>
</ul>

<p>
-10- Otherwise, <tt>*this</tt> targets a copy of <tt>f</tt> initialized with <tt>std::move(f)</tt>.
[<i>Note</i>: Implementations are encouraged to avoid the use of dynamically
allocated memory for small callable objects, for example, where <tt>f</tt>'s target
is an object holding only a pointer or reference to an object and a member
function pointer. &mdash; <i>end note</i>]
</p>

<p>
-11- <i>Throws</i>: shall not throw exceptions when <ins>an allocator is not specified
and</ins> <tt>f</tt> is a function pointer or a <tt>reference_wrapper&lt;T&gt;</tt> for some
<tt>T</tt>. Otherwise, may throw <tt>bad_alloc</tt> or any exception thrown by <tt>F</tt>'s copy or
move constructor<ins> or by <tt>A</tt>'s allocate function</ins>.
</p>
</blockquote>

</blockquote>
</li>

</ol>
</blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a></p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by acceptance of <a href="http://wg21.link/p0302r1">P0302R1</a>.
</p>





<hr>
<h3><a name="2375" href="#2375">2375.</a> Is [iterator.requirements.general]/9 too broadly applied?</h3>
<p><b>Section:</b> 24.2.1 [iterator.requirements.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2014-03-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.2.1 [iterator.requirements.general] p9 says:
</p>
<blockquote><p>
Destruction of an iterator may invalidate pointers and references previously obtained from that iterator.
</p></blockquote>
<p>
But the resolution of LWG issue <a href="lwg-defects.html#2360">2360</a> specifically advocates returning <tt>*--temp;</tt> where <tt>temp</tt> is a 
local variable.
<p/>
And 24.2.5 [forward.iterators] p6 says:
</p>
<blockquote><p>
If <tt>a</tt> and <tt>b</tt> are both dereferenceable, then <tt>a == b</tt> if and only if <tt>*a</tt> and <tt>*b</tt> are bound 
to the same object.
</p></blockquote>
<p>
which disallows "stashing" iterators (i.e, iterators that refer to data inside themselves).
<p/>
So, I suspect that the restriction in p9 should only apply to input iterators, and can probably be moved into 
24.2.3 [input.iterators] instead of 24.2.1 [iterator.requirements.general].
</p>

<p><i>[2014-05-22, Daniel comments]</i></p>


<p>
Given that forward iterators (and beyond) are refinements of input iterator, moving this constraint to input iterators won't help
much because it would still hold for all refined forms. 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2381" href="#2381">2381.</a> Inconsistency in parsing floating point numbers</h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2014-04-30 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 22.4.2.1.2 [facet.num.get.virtuals] we have:
</p>
<blockquote><p>
Stage 3: The sequence of chars accumulated in stage 2 (the field) is converted to a numeric value by the
rules of one of the functions declared in the header <tt>&lt;cstdlib&gt;</tt>:
</p>
<ul>
<li><p>For a signed integer value, the function <tt>strtoll</tt>.</p></li>
<li><p>For an unsigned integer value, the function <tt>strtoull</tt>.</p></li>
<li><p>For a floating-point value, the function <tt>strtold</tt>.</p></li>
</ul>
</blockquote>
<p>
This implies that for many cases, this routine should return true:
</p>
<blockquote><pre>
bool is_same(const char* p) 
{
  std::string str{p};
  double val1 = std::strtod(str.c_str(), nullptr);
  std::stringstream ss(str);
  double val2;
  ss &gt;&gt; val2;
  return std::isinf(val1) == std::isinf(val2) &amp;&amp;                 // either they're both infinity
         std::isnan(val1) == std::isnan(val2) &amp;&amp;                 // or they're both NaN
         (std::isinf(val1) || std::isnan(val1) || val1 == val2); // or they're equal
}
</pre></blockquote>
<p>
and this is indeed true, for many strings:
</p>
<blockquote><pre>
assert(is_same("0"));
assert(is_same("1.0"));
assert(is_same("-1.0"));
assert(is_same("100.123"));
assert(is_same("1234.456e89"));
</pre></blockquote>
<p>
but not for others
</p>
<blockquote><pre>
assert(is_same("0xABp-4")); // hex float
assert(is_same("inf"));
assert(is_same("+inf"));
assert(is_same("-inf"));
assert(is_same("nan"));
assert(is_same("+nan"));
assert(is_same("-nan"));

assert(is_same("infinity"));
assert(is_same("+infinity"));
assert(is_same("-infinity"));
</pre></blockquote>
<p>
These are all strings that are correctly parsed by <tt>std::strtod</tt>, but not by the stream extraction operators.
They contain characters that are deemed invalid in stage 2 of parsing.
<p/>
If we're going to say that we're converting by the rules of <tt>strtold</tt>, then we should accept all the things that 
<tt>strtold</tt> accepts.
</p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
People are much more interested in round-tripping hex floats than handling <tt>inf</tt> and <tt>nan</tt>. Priority changed to P2.
</p>
<p>
Marshall says he'll try to write some wording, noting that this is a very closely specified part of the standard, and has remained unchanged for a long time. Also, there will need to be a sample implementation.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Zhihao provides wording</p>
<p>The <tt>src</tt> array in Stage 2 does narrowing only.  The actual
input validation is delegated to <tt>strtold</tt> (independent from
the parsing in Stage 3 which is again being delegated
to <tt>strtold</tt>) by saying:</p>

<p>  [...] If it is not discarded, then a check is made to determine
  if c is allowed as the next character of an input field of the
  conversion specifier returned by Stage 1.</p>

<p>So a conforming C++11 <tt>num_get</tt> is supposed to magically
accept an hexfloat without an exponent</p>

<p>  0x3.AB</p>

<p>because we refers to C99, and the fix to this issue should be
just expanding the <tt>src</tt> array.</p>

<p>Support for Infs and NaNs are not proposed because of the
complexity of nan(n-chars).</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Tues PM: Move to Open</p>

<p><i>[2016-09-08, Zhihao Yuan comments and updates proposed wording]</i></p>

<p>
Examples added.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol> 
<li><p>Change 22.4.2.1.2 [facet.num.get.virtuals]/3 Stage 2 as indicated:</p>

<blockquote>
<p><tt>static const char src[] = "0123456789abcdef<ins>p</ins>xABCDEF<ins>P</ins>X+-";</tt></p>
</blockquote>
</li>

<li><p>Append the following examples to 22.4.2.1.2 [facet.num.get.virtuals]/3 Stage 2 as indicated:</p>
<blockquote>
<p>
<ins>[<i>Example:</i></ins>
</p>
<blockquote>
<p>
<ins>Given an input sequence of <tt>"0x1a.bp+07p"</tt>,</ins>
</p>
<ul>
<li><p><ins>if Stage 1 returns <tt>%d</tt>, <tt>"0"</tt> is accumulated;</ins></p></li>
<li><p><ins>if Stage 1 returns <tt>%i</tt>, <tt>"0x1a"</tt> are accumulated;</ins></p></li>
<li><p><ins>if Stage 1 returns <tt>%g</tt>, <tt>"0x1a.bp+07"</tt> are accumulated.</ins></p></li>
</ul>
<p>
<ins>In all cases, leaving the rest in the input.</ins>
</p>
</blockquote>
<p><ins>&mdash; end example]</ins></p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2383" href="#2383">2383.</a> Overflow cannot be ill-formed for chrono::duration integer literals</h3>
<p><b>Section:</b> 20.17.5.8 [time.duration.literals] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-05-16 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.17.5.8 [time.duration.literals] p3 says:
</p>
<blockquote><p>
If any of these suffixes are applied to an integer literal and the
resulting <tt>chrono::duration</tt> value cannot be represented in the result
type because of overflow, the program is ill-formed.
</p></blockquote>
<p>
Ill-formed requires a diagnostic at compile-time, but there is no way
to  detect the overflow from <tt>unsigned long long</tt> to the <tt>signed
duration&lt;&gt;::rep</tt> type.
<p/>
Overflow could be detected if the duration integer literals were
literal operator templates, otherwise overflow can either be undefined
or a run-time error, not ill-formed.
</p>

<p><i>[Urbana 2014-11-07: Move to Open]</i></p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2391" href="#2391">2391.</a> <tt>basic_string</tt> is missing non-<tt>const</tt> <tt>data()</tt></h3>
<p><b>Section:</b> 21.3.1 [basic.string] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Michael Bradshaw <b>Opened:</b> 2014-05-27 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#basic.string">active issues</a> in [basic.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#basic.string">issues</a> in [basic.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Regarding 21.3.1 [basic.string], <tt>std::basic_string&lt;charT&gt;::data()</tt> returns a <tt>const charT*</tt> 
21.3.1.7.1 [string.accessors]. While this method is convenient, it doesn't quite match <tt>std::array&lt;T&gt;::data()</tt> 
23.3.7.5 [array.data] or <tt>std::vector&lt;T&gt;::data()</tt> 23.3.11.4 [vector.data], both of which provide two 
versions (that return <tt>T*</tt> or <tt>const T*</tt>). An additional <tt>data()</tt> method can be added to 
<tt>std::basic_string</tt> that returns a <tt>charT*</tt> so it can be used in similar situations that <tt>std::array</tt> and 
<tt>std::vector</tt> can be used. Without a non-<tt>const</tt> <tt>data()</tt> method, <tt>std::basic_string</tt> has to be treated 
specially in code that is otherwise oblivious to the container type being used.
<p/>
Adding a <tt>charT*</tt> return type to <tt>data()</tt> would be equivalent to doing <tt>&amp;str[0]</tt> or <tt>&amp;str.front()</tt>.
<p/>
Small discussion on the issue can be found <a href="http://stackoverflow.com/questions/7518732/why-are-stdvectordata-and-stdstringdata-different">here</a>
and in the <a href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/ll9HuEML6zo/discussion">std-discussion thread</a>  
(which didn't get too much attention).
<p/>
This requires a small change to <tt>std::basic_string</tt>'s definition in 21.3.1 [basic.string] to add the method to 
<tt>std::basic_string</tt>, and another small change in 21.3.1.7.1 [string.accessors] to define the new method.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Back to LEWG.
</p>

<p><i>[2016-05-22]</i></p>

<p>
Marshall says: this issue has been resolved by P0272R1.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change class template <tt>basic_string</tt> synopsis, 21.3.1 [basic.string], as indicated:</p>
<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
  class Allocator = allocator&lt;charT&gt; &gt;
  class basic_string {
  public:
    [&hellip;]
    <i>// 21.4.7, string operations:</i>
    const charT* c_str() const noexcept;
    const charT* data() const noexcept;
    <ins>charT* data() noexcept;</ins>
    allocator_type get_allocator() const noexcept;
    [&hellip;]
  };
}
</pre>
</blockquote>

</li>

<li><p>Add the following sequence of paragraphs following 21.3.1.7.1 [string.accessors] p3, as indicated:</p>
<blockquote>
<pre>
<ins>charT* data() noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: A pointer <tt>p</tt> such that <tt>p + i == &amp;operator[](i)</tt> for each <tt>i</tt> in <tt>[0,size()]</tt>.</ins>
<p/>
<ins>-?- <i>Complexity</i>: Constant time.</ins>
<p/>
<ins>-?- <i>Requires</i>: The program shall not alter the value stored at <tt>p + size()</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2392" href="#2392">2392.</a> "character type" is used but not defined</h3>
<p><b>Section:</b> 17.3.16 [defns.ntcts], 22.3.1.1.1 [locale.category], 27.2.2 [iostreams.limits.pos], 27.7.3.6.1 [ostream.formatted.reqmts], 27.7.3.6.4 [ostream.inserters.character] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jeffrey Yasskin <b>Opened:</b> 2014-06-01 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The term "character type" is used in 17.3.16 [defns.ntcts], 22.3.1.1.1 [locale.category],
27.2.2 [iostreams.limits.pos], 27.7.3.6.1 [ostream.formatted.reqmts], and
27.7.3.6.4 [ostream.inserters.character], but the core language only defines
"narrow character types" (3.9.1 [basic.fundamental]).
<p/>
"wide-character type" is used in 22.5 [locale.stdcvt], but the core
language only defines a "wide-character set" and "wide-character literal".
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2394" href="#2394">2394.</a> <tt>locale::name</tt> specification unclear &mdash; what is implementation-defined?</h3>
<p><b>Section:</b> 22.3.1.3 [locale.members] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-06-09 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.members">issues</a> in [locale.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
22.3.1.3 [locale.members] p5 says:
</p>
<blockquote><p>
<i>Returns</i>: The name of <tt>*this</tt>, if it has one; otherwise, the string <tt>"*"</tt>. If <tt>*this</tt> has a name, then
<tt>locale(name().c_str())</tt> is equivalent to <tt>*this</tt>. Details of the contents of the resulting string are
otherwise implementation-defined.
</p></blockquote>
<p>
So&hellip; what is implementation-defined here, exactly? The first sentence <em>completely</em> defines the behavior of this function 
in all cases.
<p/>
Also, the second sentence says (effectively) that all locales with the same name are equivalent: given <tt>L1</tt> and <tt>L2</tt> 
that have the same name <tt>N</tt>, they are both equivalent to <tt>locale(N)</tt>, and since there is no definition of 
"equivalent" specific to <tt>locale</tt>, I assume it's the normal transitive equivalence property, which would imply that 
<tt>L1</tt> is equivalent to <tt>L2</tt>. I'm not sure why this central fact is in the description of <tt>locale::name</tt>, nor 
why it's written in this roundabout way.
</p>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Walter, Nevin, and Jason provide initial Proposed Resolution.
</p>
<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 22.3.1.3 [locale.members] as indicated:</p>

<blockquote>
<pre>
basic_string&lt;char&gt; name() const;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> The name of <tt>*this</tt>, if it has one; otherwise, the string <tt>"*"</tt>. 
<del>If <tt>*this</tt> has a name, then <tt>locale(name().c_str())</tt> is equivalent to <tt>*this</tt>. 
Details of the contents of the resulting string are
otherwise implementation-defined.</del>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2398" href="#2398">2398.</a> <tt>type_info</tt>'s destructor shouldn't be required to be virtual</h3>
<p><b>Section:</b> 18.7.2 [type.info] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-06-14 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#type.info">issues</a> in [type.info].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>type_info</tt>'s destructor is depicted as being <tt>virtual</tt>, which is nearly unobservable to users (since they can't construct 
or copy this class, they can't usefully derive from it). However, it's technically observable (via <tt>is_polymorphic</tt> and 
<tt>has_virtual_destructor</tt>). It also imposes real costs on implementations, requiring them to store one vptr per 
<tt>type_info</tt> object, when RTTI space consumption is a significant concern.
<p/>
Making this implementation-defined wouldn't affect users (who can observe this only if they're specifically looking for it) and 
wouldn't affect implementations who need <tt>virtual</tt> here, but it would allow other implementations to drop <tt>virtual</tt> 
and improve their RTTI space consumption.
<p/>
Richard Smith:
<p/>
It's observable in a few other ways.
</p>
<blockquote><pre>
std::map&lt;void*, something&gt; m;
m[dynamic_cast&lt;void*&gt;(&amp;typeid(blah))] = stuff;
</pre></blockquote>
<p>
... is broken by this change, because you can't <tt>dynamic_cast</tt> a non-polymorphic class type to <tt>void*</tt>.
</p>
<blockquote><pre>
type_info&amp; f();
typeid(f());
</pre></blockquote>
<p>
... evaluates <tt>f()</tt> at runtime without this change, and might not do so with this change.
<p/>
These are probably rare things, but I can imagine at least some forms of the latter being used in SFINAE tricks.
</p>

<p><i>[Lenexa 2015-05-05: Move to Open]</i></p>

<p>Marshall to poll LEWG for their opinion</p>

<p><i>[2016-06]</i></p>
 
<p>
On the <a href="http://lists.isocpp.org/lib-ext/2016/06/2451.php">reflector</a>, STL wrote:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;"><p>We'll prototype this change and report back with data in the future.</p></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>No update from STL. Set priority to P3</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 18.7.2 [type.info] as indicated:</p>

<blockquote>
<pre>
namespace std {
  class type_info {
  public:
    <del>virtual</del><ins><i>see below</i></ins> ~type_info();
    [&hellip;]
  };
}
</pre>
<p>
-1- The class <tt>type_info</tt> describes type information generated by the implementation. Objects of this class
effectively store a pointer to a name for the type, and an encoded value suitable for comparing two types for
equality or collating order. The names, encoding rule, and collating sequence for types are all unspecified
and may differ between programs. <ins>Whether <tt>~type_info()</tt> is <tt>virtual</tt> is implementation-defined.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2412" href="#2412">2412.</a> <tt>promise::set_value()</tt> and <tt>promise::get_future()</tt> should not race</h3>
<p><b>Section:</b> 30.6.5 [futures.promise], 30.6.9.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-06-23 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code has a data race according to the standard:
</p>
<blockquote>
<pre>
std::promise&lt;void&gt; p;
std::thread t{ []{
  p.get_future().wait();
}};
p.set_value();
t.join();
</pre>
</blockquote>
<p>
The problem is that both <tt>promise::set_value()</tt> and
<tt>promise::get_future()</tt> are non-const member functions which modify the
same object, and we only have wording saying that the <tt>set_value()</tt> and
<tt>wait()</tt> calls (i.e. calls setting and reading the shared state) are
synchronized.
<p/>
The calls don't actually access the same memory locations, so the
standard should allow it. My suggestion is to state that calling
<tt>get_future()</tt> does not conflict with calling the various functions that
make the shared state ready, but clarify with a note that this does
not imply any synchronization or "happens before", only being free
from data races.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Handed over to SG1.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 30.6.5 [futures.promise] around p12 as indicated:</p>

<blockquote>
<pre>
future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-12- <i>Returns</i>: A <tt>future&lt;R&gt;</tt> object with the same shared state as <tt>*this</tt>.
<p/>
<ins>-?- <i>Synchronization</i>: Calls to this function do not conflict (1.10 [intro.multithread]) 
with calls to <tt>set_value</tt>, <tt>set_exception</tt>, <tt>set_value_at_thread_exit</tt>, or
<tt>set_exception_at_thread_exit</tt>. [<i>Note</i>: Such calls need not be synchronized, but implementations 
must ensure they do not introduce data races. &mdash; <i>end note</i>]</ins>
<p/>
-13- <i>Throws</i>: <tt>future_error</tt> if <tt>*this</tt> has no shared state or if <tt>get_future</tt> has already been called on a
<tt>promise</tt> with the same shared state as <tt>*this</tt>.
<p/>
-14- <i>Error conditions</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 30.6.9.1 [futures.task.members] around p13 as indicated:</p>

<blockquote>
<pre>
future&lt;R&gt; get_future();
</pre>
<blockquote>
<p>
-13- <i>Returns</i>: A <tt>future&lt;R&gt;</tt> object that shares the same shared state as <tt>*this</tt>.
<p/>
<ins>-?- <i>Synchronization</i>: Calls to this function do not conflict (1.10 [intro.multithread]) 
with calls to <tt>operator()</tt> or <tt>make_ready_at_thread_exit</tt>. [<i>Note</i>: Such calls need not be 
synchronized, but implementations must ensure they do not introduce data races. &mdash; <i>end note</i>]</ins>
<p/>
-14- <i>Throws</i>: a <tt>future_error</tt> object if an error occurs.
<p/>
-15- <i>Error conditions</i>: [&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2413" href="#2413">2413.</a> <tt>assert</tt> macro is overconstrained</h3>
<p><b>Section:</b> 19.3 [assertions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2014-06-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#assertions">issues</a> in [assertions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When <tt>NDEBUG</tt> is defined, <tt>assert</tt> must expand exactly to the token sequence <tt>((void)0)</tt>, with no 
whitespace (C99 &sect;7.2/1 and also C11 &sect;7.2/1). This is a lost opportunity to pass the condition along to the optimizer.
<p/>
The user may observe the token sequence using the stringize operator or discriminate it by making a matching <tt>#define</tt> 
directive. There is little chance of practical code doing such things. It's reasonable to allow any expansion that is a <tt>void</tt> 
expression with no side effects or semantic requirements, for example, an extension keyword or an attribute-specifier finagled 
into the context.
<p/>
Conforming optimizations would still be limited to treating the condition as hint, not a requirement. Nonconformance on this 
point is quite reasonable though, given user preferences. Anyway, it shouldn't depend on preprocessor quirks.
<p/>
As for current practice, Darwin OS <tt>&lt;assert.h&gt;</tt> provides a GCC-style compiler hint <tt>__builtin_expect</tt> but only in 
debug mode. Shouldn't release mode preserve hints?
<p/>
Daniel:
<p/>
The corresponding resolution should take care not to conflict with the intention behind LWG <a href="lwg-defects.html#2234">2234</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2414" href="#2414">2414.</a> Member function reentrancy should be implementation-defined</h3>
<p><b>Section:</b> 17.6.5.8 [reentrancy] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2014-07-01 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reentrancy">issues</a> in [reentrancy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N3936 17.6.5.8 [reentrancy]/1 talks about "functions", but that doesn't address the scenario of calling different member 
functions of a single object. Member functions often have to violate and then re-establish invariants. For example, vectors 
often have "holes" during insertion, and element constructors/destructors/etc. shouldn't be allowed to observe the vector 
while it's in this invariant-violating state. The [reentrancy] Standardese should be extended to cover member functions, 
so that implementers can either say that member function reentrancy is universally prohibited, or selectively allowed for 
very specific scenarios.
<p/>
(For clarity, this issue has been split off from LWG <a href="lwg-closed.html#2382">2382</a>.)
</p>

<p><i>[2014-11-03 Urbana]</i></p>

<p>
AJM confirmed with SG1 that they had no special concerns with this issue, and LWG should retain ownership.
<p/>
AM: this is too overly broad as it also covers calling the exact same member function on a different object<br/>
STL: so you insert into a map, and copying the value triggers another insertion into a different map of the same type<br/>
GR: reentrancy seems to imply the single-threaded case, but needs to consider the multi-threaded case
<p/>
Needs more wording.
</p>
<p>
Move to Open
</p>

<p><i>[2015-07 Telecom Urbana]</i></p>

<p>
Marshall to ping STL for updated wording.<br/>
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3936.</p>

<ol>
<li><p>Change 17.6.5.8 [reentrancy] p1 as indicated:</p>
<blockquote>
<p>
-1- Except where explicitly specified in this standard, it is implementation-defined which functions <ins>(including different 
member functions called on a single object)</ins> in the Standard C++ library may be recursively reentered.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2417" href="#2417">2417.</a> [fund.ts.v2] <tt>std::experimental::optional::operator&lt;</tt> and <tt>LessThanComparable</tt> requirement</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.relops], 99 [fund.ts.v2::optional.comp_with_t] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-06-20 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
Currently, <tt>std::experimental::optional::operator==</tt> imposes the <tt>EqualityComparable</tt> requirement which provides
two guarantees: It ensures that <tt>operator!=</tt> can rely on the equivalence-relation property and more importantly, that
the <tt>BooleanTestable</tt> requirements suggested by issue <a href="lwg-active.html#2114">2114</a> are automatically implied.
<p/>
<tt>std::experimental::optional::operator&lt;</tt> doesn't provide a <tt>LessThanComparable</tt> requirement, but there was quite
an historic set of changes involved with that family of types: As of 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3527.html">N3527</a>
this operator was defined in terms of <tt>operator&lt;</tt> of the contained type <tt>T</tt> and imposed the <tt>LessThanComparable</tt> 
requirement. In the final acceptance step of <tt>optional</tt> by the committee, the definition was expressed in terms of <tt>std::less</tt>
and the <tt>LessThanComparable</tt> requirement had been removed.
<p/>
The inconsistency between <tt>operator==</tt> and <tt>operator&lt;</tt> should be removed. One possible course of action would be 
to add the <tt>LessThanComparable</tt> to <tt>std::experimental::optional::operator&lt;</tt>. The <tt>EqualityComparable</tt> requirement
of <tt>operator==</tt> could also be removed, but in that case both operators would at least need to require the <tt>BooleanTestable</tt> 
requirements (see <a href="lwg-active.html#2114">2114</a>) for the result type of <tt>T</tt>'s <tt>operator==</tt> and <tt>operator&lt;</tt>. 
<p/>
Arguably, corresponding operators for <tt>pair</tt> and <tt>tuple</tt> do not impose <tt>LessThanComparable</tt> (nor
<tt>EqualityComparable</tt>), albeit the definition of the "derived" relation functions depend on properties ensured by
<tt>LessThanComparable</tt>. According to the <a href="https://www.sgi.com/tech/stl/pair.html">SGI definition</a>, the intention was
to imposed both <tt>EqualityComparable</tt> and <tt>LessThanComparable</tt>. If this is not intended, the standard should clarify
this position.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
VV, DK, JY discuss why and when <tt>LessThanComparable</tt> was removed. AM: Move to LEWG. Please tell LWG when you look at it. 
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2419" href="#2419">2419.</a> Clang's libc++ extension to <tt>std::tuple</tt></h3>
<p><b>Section:</b> 20.5.2.1 [tuple.cnstr] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Akim Demaille <b>Opened:</b> 2014-07-11 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The issue has been submitted after exchanges with the clang++ team
as a consequence of two PR I sent:
<p/>
<a href="http://llvm.org/bugs/show_bug.cgi?id=20174">Issue 20174</a>
<p/>
<a href="http://llvm.org/bugs/show_bug.cgi?id=20175">Issue 20175</a>
<p/>
The short version is shown in the program below:
</p>
<blockquote>
<pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct base
{
  void out(const std::tuple&lt;char, char&gt;&amp; w) const
  {
    std::cerr &lt;&lt; "Tuple: " &lt;&lt; std::get&lt;0&gt;(w) &lt;&lt; std::get&lt;1&gt;(w) &lt;&lt; '\n';
  }
};

struct decorator
{
  base b_;

  template &lt;typename... Args&gt;
  auto
  out(Args&amp;&amp;... args)
    -> decltype(b_.out(args...))
  {
    return b_.out(args...);
  }

  void out(const char&amp; w)
  {
    std::cerr &lt;&lt; "char: " &lt;&lt; w &lt;&lt; '\n';
  }
};

int main()
{
  decorator d{base{}};
  char l = 'a';
  d.out(l);
}
</pre>
</blockquote>
<p>
This is a stripped down version of a real world case where I
wrap objects in decorators.  These decorators contributes some
functions, and forward all the rest of the API to the wrapped
object using perfect forwarding.  There can be overloaded names.
<p/>
Here the inner object provides an
</p>
<blockquote><pre>
out(const std::tuple&lt;char, char&gt;&amp;) -&gt; void
</pre></blockquote>
<p>
function, and the wrappers, in addition to perfect forwarding,
provides
</p>
<blockquote><pre>
out(const char&amp;) -&gt; void
</pre></blockquote>
<p>
The main function then call <tt>out(l)</tt> where <tt>l</tt> is a <tt>char</tt> lvalue.
<p/>
With (GCC's) libstdc++ I get the expected result: the <tt>char</tt>
overload is run.  With (clang++'s) libc++ it is the tuple
version which is run.
</p>
<blockquote><pre>
$ g++-mp-4.9 -std=c++11 bar.cc &amp;&amp; ./a.out
char: a
$ clang++-mp-3.5 -std=c++11 bar.cc -Wall &amp;&amp; ./a.out
Tuple: a
</pre></blockquote>
<p>
It turns out that this is the result of an extension of <tt>std::tuple</tt>
in libc++ where they accept constructors with fewer values that
tuple elements.
<p/>
The purpose of this issue is to ask the standard to forbid
that this extension be allowed to participate in overload resolution.
</p>

<p><i>[2014-10-05, Daniel comments]</i></p>

<p>
This issue is closely related to LWG <a href="lwg-defects.html#2312">2312</a>.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>
Moved to LEWG.
</p>
<p>
Extensions to <tt>tuple</tt>'s design are initially a question for LEWG.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2421" href="#2421">2421.</a> Non-specification of handling zero size in <tt>std::align</tt> [ptr.align]</h3>
<p><b>Section:</b> 20.10.5 [ptr.align] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Melissa Mears <b>Opened:</b> 2014-08-06 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ptr.align">issues</a> in [ptr.align].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>std::align</tt> does not appear to specify what happens when the value of the <tt>size</tt> 
parameter is 0. (The question of what happens when <tt>alignment</tt> is 0 is mentioned in another Defect Report, <a href="lwg-defects.html#2377">2377</a>; 
it would change the behavior to be undefined rather than potentially implementation-defined.)
<p/>
The case of <tt>size</tt> being 0 is interesting because the result is ambiguous. Consider the following code's output:
</p>
<blockquote>
<pre>
#include &lt;cstdio&gt;
#include &lt;memory&gt;

int main()
{
  alignas(8) char buffer[8];
  void *ptr = &amp;buffer[1];
  std::size_t space = sizeof(buffer) - sizeof(char[1]);

  void *result = std::align(8, 0, ptr, space);

  std::printf("%d %td\n", !!result, result ? (static_cast&lt;char*&gt;(result) - buffer) : std::ptrdiff_t(-1));
}
</pre>
</blockquote>
<p>
There are four straightforward answers as to what the behavior of <tt>std::align</tt> with size 0 should be:
</p>
<ol>
<li><p>The behavior is undefined because the size is invalid.</p></li>
<li><p>The behavior is implementation-defined. This seems to be the status quo, with current implementations using #3.</p></li>
<li><p>Act the same as <tt>size == 1</tt>, except that if <tt>size == 1</tt> would fail but would be defined and succeed 
if space were exactly 1 larger, the result is a pointer to the byte past the end of the <tt>ptr</tt> buffer. That is, the 
"aligned" version of a 0-byte object can be one past the end of an allocation. Such pointers are, of course, valid when not 
dereferenced (and a "0-byte object" shouldn't be), but whether that is desired is not specified in the Standard's definition 
of <tt>std::align</tt>, it appears. The output of the code sample is "<tt>1 8</tt>" in this case.</p></li>
<li><p>Act the same as <tt>size == 1</tt>; this means that returning "one past the end" is not a possible result. In this case, 
the code sample's output is "<tt>0 -1</tt>".</p></li>
</ol>
<p>
The two compilers I could get working with <tt>std::align</tt>, Visual Studio 2013 and Clang 3.4, implement #3. (Change <tt>%td</tt> to 
<tt>%Id</tt> on Visual Studio 2013 and earlier. 2014 and later will have <tt>%td</tt>.)
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2423" href="#2423">2423.</a> Missing specification <tt>slice_array</tt>, <tt>gslice_array</tt>, <tt>mask_array</tt>, <tt>indirect_array</tt> copy constructor</h3>
<p><b>Section:</b> 26.7.5 [template.slice.array], 26.7.7 [template.gslice.array], 26.7.8 [template.mask.array], 26.7.9 [template.indirect.array] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Akira Takahashi <b>Opened:</b> 2014-08-12 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#template.slice.array">issues</a> in [template.slice.array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I found a missing specification of the copy constructor of the following class templates:
</p>
<ul>
<li><p><tt>slice_array</tt> (26.7.5 [template.slice.array])</p></li>
<li><p><tt>gslice_array</tt> (26.7.7 [template.gslice.array])</p></li>
<li><p><tt>mask_array</tt> (26.7.8 [template.mask.array])</p></li>
<li><p><tt>indirect_array</tt> (26.7.9 [template.indirect.array])</p></li>
</ul>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Before 26.7.5.2 [slice.arr.assign] insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>slice_array</tt> constructors [slice.arr.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>slice_array(const slice_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 26.7.7.2 [gslice.array.assign] insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>gslice_array</tt> constructors [gslice.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>gslice_array(const gslice_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 26.7.8.2 [mask.array.assign] insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>mask_array</tt> constructors [mask.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>mask_array(const mask_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>

<li><p>Before 26.7.9.2 [indirect.array.assign] insert a new sub-clause as indicated:</p>

<p>
<ins><b>-?- <tt>indirect_array</tt> constructors [indirect.array.cons]</b></ins>
</p>
<blockquote>
<pre>
<ins>indirect_array(const indirect_array&amp;);</ins>
</pre>
<p>
<ins>-?- <i>Effects</i>: The constructed slice refers to the same <tt>valarray&lt;T&gt;</tt> object to which
the argument slice refers.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2424" href="#2424">2424.</a> 29.5 should state that atomic types are not trivially copyable</h3>
<p><b>Section:</b> 29.5 [atomics.types.generic] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jens Maurer <b>Opened:</b> 2014-08-14 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.generic">active issues</a> in [atomics.types.generic].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Otherwise, one could use <tt>memcpy</tt> to save and restore the value according to 3.9p2.
<p/>
It seems the core language rules in 9 [class]p6 with 12.8 [class.copy]p12 
(trivial copy constructor) etc. and 8.4.2 [dcl.fct.def.default]p5 (user-provided) say 
that the atomic types are trivially copyable, which is bad. We shouldn't rely on future core 
changes in that area and simply say in the library section 29.5 [atomics.types.generic] 
that these very special types are not trivially copyable.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>
Lawrence:Definition of "trivially copyable" has been changing.
</p>
<p>
Doesn't hurt to add proposed change, even if the sentence is redundant
</p>
<p>
Move to Review.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
GR has a minor problem with the style of the wording. VV has major issues with implementability.
</p>

<p><i>[2015-03-22, Jens Maurer responses to Cologne discussion]</i></p>

<p>
A library implementation could provide a partial specialization for <tt>is_trivially_copyable&lt;atomic&lt;T&gt;&gt;</tt>, 
to ensure that any such type query would return <tt>false</tt>.
<p/>
Assuming such a specialization would be provided, how could a conforming program observe that per 
language rules an <tt>atomic</tt> specialization would actually be trivially copyable if there 
is no way to call the (deleted) copy constructor or copy assignment operator?
<p/>
The sole effect of the suggested addition of the constraining sentence is that it would make a user program
non-conforming that attempts to invoke <tt>memcpy</tt> (and the like) on <tt>atomic</tt> types, since that
would invoke undefined behaviour.
</p>

<p><i>[2015-05 Lenexa, SG1 response]</i></p>

<p>
SG1 is fine with P/R (and agrees it's needed), but LWG may want to
check the details; it's not entirely an SG1 issue.
</p>

<p><i>[2015-05-05 Lenexa]</i></p>

<p>Marshall: This was discussed on the telecon. Alisdair was going to write something to Mike and send it to Core.</p>
<p>Hwrd: Core says that deleted copies are trivially copyable, which makes no sense to Library people.</p>
<p>STL: There doesn't appear to be a Core issue about it.</p>

<p><i>[2015-09-11 Telecom]</i></p>

<p>Howard: currently std::is_trivially_copyable&lt;std::atomic&gt; is true, so this resolution would contradict reality</p>
<p>Jonathan: changing that is good, we don't want it to be trivially copyable, otherwise users can memcpy them, which we really don't want</p>
<p>Howard: is it reasonable to memcpy something that isn't trivially copy constructible or trivially assignable?</p>
<p>Jonathan: no, it's not, but Core says you can, so this resolution is needed to stop people memcpying atomic</p>
<p>Howard: we should fix the core rule</p>
<p>Marshall: there is a separate issue of whether trivially-copyable makes sense, but this resolution is a net good purely because it stops memcpy of atomics</p>
<p>Howard: so should implementations specialize is_trivially_copyable the trait to meet this?</p>
<p>Jonathan: or add an empty, user-defined destructor.</p>
<p>Howard: should the spec specify that then?</p>
<p>Over-specification.</p>
<p>Howard: without that I fear implementation divergence.</p>
<p>Ville and Jonathan to investigate potential implementation options.</p>
<p>Ville: request a note on the issue saying we need review other types such as condition_variable to see if they are also unintentionally trivially-copyable. N4460 mentions some such types.</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
We think there is something coming from Core to resolve that, and that this will be NAD.<br/>
Until then, defer. <br/>
</p>

<p><i>[2016-03 Jacksonville]</i></p>

<p>This was resolved by Core Issue 1496</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Change 29.5 [atomics.types.generic]p3 as indicated:</p>

<blockquote>
<p>
Specializations and instantiations of the <tt>atomic</tt> template shall have a deleted copy constructor, a deleted
copy assignment operator, and a constexpr value constructor. <ins>They are not trivially copyable 
types (3.9 [basic.types]).</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2430" href="#2430">2430.</a> Heterogeneous container lookup should be enabled using meta-function instead of nested type</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2014-07-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the heterogeneous lookup in associative container are
enabled by presence of <tt>is_transparent</tt> nested type in the comparator
type (23.2.4 [associative.reqmts]). This complicates the definition
of call wrapper types that want to define <tt>is_transparent</tt> if they wrap
a callable type that defines <tt>is_transparent</tt>, and requires the target
to be a complete type in cases where an incomplete type would otherwise be ok.
<p/>
Another problem is that users cannot add the <tt>is_transparent</tt> member to
a third-party comparison type that they do not control, even if they
know it supports heterogeneous comparisons.
<p/>
If the associative containers used a trait instead of checking for an
<tt>is_transparent</tt> member type then it would avoid the requirement for
complete types, and would allow customization of the trait without
modifying the comparator type. This would also be consistent with the
traits <tt>is_placeholder</tt> and <tt>is_bind_expression</tt>.
<p/>
For backward compatibility with the existing design, the default
implementation of the <tt>is_transparent</tt> trait could depend on the
presence of the <tt>is_transparent</tt> nested type.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Move to LEWG</p>
<p>
Request for a new metafunction should first be responded to by LEWG.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2431" href="#2431">2431.</a> Missing regular expression traits requirements</h3>
<p><b>Section:</b> 28.3 [re.req] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-09-30 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements on the traits class in 28.3 [re.req] do not say whether a
regular expression traits class is required to be <tt>DefaultConstructible</tt>, 
<tt>CopyConstructible</tt>, <tt>CopyAssignable</tt> etc.
<p/>
The <tt>std::regex_traits</tt> class appears to be all of the above, but can
<tt>basic_regex</tt> assume that for user-defined traits classes?
<p/>
Should the following statements all leave <tt>u</tt> in equivalent states?
</p>
<blockquote><pre>
X u{v};
X u; u = v;
X u; u.imbue(v.getloc();
</pre></blockquote>
<p>
Whether they are equivalent has implications for <tt>basic_regex</tt> copy construction and 
assignment.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2432" href="#2432">2432.</a> <tt>initializer_list</tt> assignability</h3>
<p><b>Section:</b> 18.9 [support.initlist] <b>Status:</b> <a href="lwg-active.html#EWG">EWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2014-09-30 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::initializer_list::operator=</tt> 18.9 [support.initlist] is horribly broken and it needs deprecation:
</p>
<blockquote><pre>
std::initializer_list&lt;foo&gt; a = {{1}, {2}, {3}};
a = {{4}, {5}, {6}};
// New sequence is already destroyed.
</pre></blockquote>
<p>
Assignability of <tt>initializer_list</tt> isn't explicitly specified, but most implementations supply a default assignment 
operator. I'm not sure what 17.5 [description] says, but it probably doesn't matter.
</p>

<p><i>[Lenexa 2015-05-05: Send to EWG as discussed in Telecon]</i></p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Edit 18.9 [support.initlist] p1, class template <tt>initializer_list</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class E&gt; class initializer_list {
  public:
    [&hellip;]
    constexpr initializer_list() noexcept;
  
    <ins>initializer_list(const initializer_list&amp;) = default;</ins>
    <ins>initializer_list(initializer_list&amp;&amp;) = default;</ins>
    <ins>initializer_list&amp; operator=(const initializer_list&amp;) = delete;</ins>
    <ins>initializer_list&amp; operator=(initializer_list&amp;&amp;) = delete;</ins>
    
    constexpr size_t size() const noexcept;
    [&hellip;]
  };
  [&hellip;]
}
</pre>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2443" href="#2443">2443.</a> <tt>std::array</tt> member functions should be <tt>constexpr</tt></h3>
<p><b>Section:</b> 23.3.7 [array] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Peter Sommerlad <b>Opened:</b> 2014-10-06 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#array">active issues</a> in [array].</p>
<p><b>View all other</b> <a href="lwg-index.html#array">issues</a> in [array].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When experimenting with C++14 relaxed <tt>constexpr</tt> functions I made the observation that I couldn't 
use <tt>std::array</tt> to create a table of data at compile time directly using loops in a function. 
However, a simple substitute I could use instead:
</p>
<blockquote>
<pre>
template &lt;typename T, size_t n&gt;
struct ar {
  T a[n];
  constexpr ar() : a{{}}{}
  constexpr auto data() const { return &amp;a[0];}
  constexpr T const &amp; operator[](size_t i) const { return a[i]; }
  constexpr T &amp; operator[](size_t i) { return a[i]; }
};

template &lt;size_t n&gt;
using arr = ar&lt;size_t, n&gt;; // std::array&lt;size_t, n&gt;;

template &lt;size_t n&gt;
constexpr auto make_tab(){
  arr&lt;n&gt; result;
  for(size_t i=0; i &lt; n; ++i)
    result[i] = (i+1)*(i+1); // cannot define operator[] for mutable array...
  return result;
}

template &lt;size_t n&gt;
constexpr auto squares=make_tab&lt; n&gt;();

int main() {
  int dummy[squares&lt;5&gt;[3]];
}
</pre>
</blockquote>
<p>
Therefore, I suggest that all member functions of <tt>std::array</tt> should be made <tt>constexpr</tt> 
to make the type usable in <tt>constexpr</tt> functions.
<p/>
Wording should be straight forward, may be with the exception of <tt>fill</tt>, which would require 
<tt>fill_n</tt> to be <tt>constexpr</tt> as well.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Move to LEWG</p>
<p>
The extent to which <tt>constexpr</tt> becomes a part of the Library design is a policy
matter best handled initially by LEWG.
</p>

<p><i>[08-2016, Post-Chicago]</i></p>

<p>Move to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>This functionality is provided by <a href="http://wg21.link/P0031R0">P0031R0</a></p>





<hr>
<h3><a name="2444" href="#2444">2444.</a> Inconsistent complexity for <tt>std::sort_heap</tt></h3>
<p><b>Section:</b> 25.5.6.4 [sort.heap] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Fran&ccedil;ois Dumont <b>Opened:</b> 2014-10-07 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
While creating complexity tests for the GNU libstdc++ implementation <a href="https://gcc.gnu.org/ml/libstdc++/2014-10/msg00048.html">I 
stumbled</a> across a surprising requirement for the <tt>std::sort_heap</tt> algorithm.
<p/>
In 25.5.6.4 [sort.heap] p3 the Standard states:
</p>
<blockquote><p>
<i>Complexity</i>: At most <tt><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>
<p>
As stated on the libstdc++ mailing list by Marc Glisse <tt>sort_heap</tt> can be implemented by <tt><i>N</i></tt> calls to 
<tt>pop_heap</tt>. As max number of comparisons of <tt>pop_heap</tt> is <tt>2 * log(<i>N</i>)</tt> then <tt>sort_heap</tt> 
max limit should be <tt>2 * log(1) + 2 * log(2) + .... + 2 * log(<i>N</i>)</tt> that is to say <tt>2 * log(<i>N</i>!)</tt>. 
In terms of <tt>log(<i>N</i>)</tt> we can also consider that this limit is also cap by <tt>2 * <i>N</i> * log(<i>N</i>)</tt> 
which is surely what the Standard wanted to set as a limit.
<p/>
This is why I would like to propose to replace paragraph 3 by:
</p>
<blockquote><p>
<i>Complexity</i>: At most <tt><ins>2</ins><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>

<p><i>[2015-02 Cologne]</i></p>

<p>
Marshall will research the maths and report back in Lenexa.
</p>

<p><i>[2015-05-06 Lenexa]</i></p>

<p>STL: I dislike exact complexity requirements, they prevent one or two extra checks in debug mode. Would it be better to say O(N log(N)) not at most?</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol><li>
<p>
In 25.5.6.4 [sort.heap] p3 the Standard states:
</p>
<blockquote>
<pre>
template&lt;class RandomAccessIterator&gt;
  void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
template&lt;class RandomAccessIterator, class Compare&gt;
  void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                 Compare comp);
</pre>
<blockquote><p>
[&hellip;]
<p/>
-3- <i>Complexity</i>: At most <tt><ins>2</ins><i>N</i> log(<i>N</i>)</tt> comparisons (where <tt><i>N</i> == last - first</tt>).
</p></blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2445" href="#2445">2445.</a> "Stronger" memory ordering</h3>
<p><b>Section:</b> 20.11.2.6 [util.smartptr.shared.atomic], 29.6.5 [atomics.types.operations.req] <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> JF Bastien <b>Opened:</b> 2014-10-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.atomic">issues</a> in [util.smartptr.shared.atomic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definitions of compare and exchange in 20.11.2.6 [util.smartptr.shared.atomic] p32 and 
29.6.5 [atomics.types.operations.req] p20 state:
</p>
<blockquote><p>
<i>Requires</i>: The failure argument shall not be <tt>memory_order_release</tt> nor <tt>memory_order_acq_rel</tt>. 
The <tt>failure</tt> argument shall be no stronger than the <tt>success</tt> argument.
</p></blockquote>
<p>
The term "stronger" isn't defined by the standard.
<p/>
It is hinted at by 29.6.5 [atomics.types.operations.req] p21:
</p>
<blockquote><p>
When only one <tt>memory_order</tt> argument is supplied, the value of <tt>success</tt> is <tt>order</tt>, and the 
value of <tt>failure</tt> is <tt>order</tt> except that a value of <tt>memory_order_acq_rel</tt> shall be replaced 
by the value <tt>memory_order_acquire</tt> and a value of <tt>memory_order_release</tt> shall be replaced by the 
value <tt>memory_order_relaxed</tt>.
</p></blockquote>
<p>
Should the standard define a partial ordering for memory orders, where consume and acquire are incomparable with release?
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>
Move to SG1.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2446" href="#2446">2446.</a> Unspecialized <tt>std::tuple_size</tt> should be defined</h3>
<p><b>Section:</b> 20.5.1 [tuple.general] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2014-10-10 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.general">active issues</a> in [tuple.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.general">issues</a> in [tuple.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.5.1 [tuple.general] paragraph 2, the unspecialized <tt>std::tuple_size</tt> is undefined. It would 
be a lot more useful with SFINAE if it were defined as an empty struct; that way, it can be used with <tt>enable_if</tt> 
for determining whether or not it is valid to use <tt>tuple_size</tt>, <tt>tuple_element</tt> and get on the 
corresponding data structure.
</p>

<p><i>[2014-11 Urbana]</i></p>

<p>Moved to LEWG 42.</p>
<p>
This request goes beyond simply making an API respond well to SFINAE, but coupling that with an
implication for other tuple APIs.  The proper place for such design discussions is LEWG.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N3936.
</p>

<ol>
<li><p>Change 20.5.1 [tuple.general] p2, header <tt>&lt;tuple&gt;</tt> synopsis, as indicated</p>
<blockquote>
<pre>
[&hellip;]
// <i>20.4.2.5, tuple helper classes</i>:
template &lt;class T&gt; class tuple_size; <del>// undefined</del>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 20.5.2.6 [tuple.helper] as indicated</p>
<blockquote>
<pre>
[&hellip;]
template &lt;class T&gt; struct tuple_size <ins>{ }</ins>;
[&hellip;]
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2449" href="#2449">2449.</a> <tt>vector::insert</tt> invalidates <tt>end()</tt>?</h3>
<p><b>Section:</b> 23.3.11.5 [vector.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Marc Glisse <b>Opened:</b> 2014-10-21 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.modifiers">active issues</a> in [vector.modifiers].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.modifiers">issues</a> in [vector.modifiers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
this issue is based on the discussion <a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/oYvKscnl280/discussion">here</a>.
<p/>
23.3.11.5 [vector.modifiers] says about <tt>vector::insert</tt>: "If no reallocation happens, all the iterators and references 
before the insertion point remain valid." This doesn't seem to guarantee anything about the iterator <em>at</em> the point of insertion.
<p/>
The question comes from people asking if the following is valid, assuming a sufficient call to <tt>reserve()</tt> was done first:
</p>
<blockquote><pre>
v.insert(v.end(), v.begin(), v.end());
</pre></blockquote>
<p>
It could fail for an implementation using a sentinel for the end of the vector, but I don't know of any (it would be quite 
inconvenient). And for any implementation using a simple position as iterator (pointer (possibly in a wrapper), or base+offset), 
this is needlessly restrictive. The fact that this alternative:
</p>
<blockquote><pre>
v.insert(v.end(), &amp;v[0], &amp;v[0]+v.size())
</pre></blockquote>
<p>
is arguably valid (again assuming a large enough <tt>reserve()</tt>) makes it a bit confusing that the first version isn't 
(23.2.3 [sequence.reqmts] has a precondition that iterator arguments to <tt>insert()</tt> do not point into the sequence, 
but <tt>vector::insert</tt> is more refined and seems to give enough guarantees that it cannot fail).
<p/>
Then we might as well say that <tt>vector</tt> iterators act as positions, and that after a reallocation-free operation an 
iterator points to the same position, whatever may be there now&hellip;
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2452" href="#2452">2452.</a> <tt>is_constructible</tt>, etc. and default arguments</h3>
<p><b>Section:</b> 20.15 [meta] <b>Status:</b> <a href="lwg-active.html#Core">Core</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2014-11-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta">active issues</a> in [meta].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>Discussion:</b></p>
<p>
The <tt>BaseCharacteristic</tt> for <tt>is_constructible</tt> is defined in terms of the well-formedness 
of a declaration for an invented variable. The well-formedness of the described declaration itself may 
change for the same set of arguments because of the introduction of default arguments.
<p/>
In the following program, there appears to be conflicting definitions of a specialization of 
<tt>std::is_constructible</tt>; however, it seems that this situation is caused without a user violation 
of the library requirements or the ODR. There is a similar issue with <tt>is_convertible</tt>, <tt>result_of</tt>
and others.
<p/>
a.cc:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
struct A { A(int, int); };
const std::false_type&amp; x1 = std::is_constructible&lt;A, int&gt;();

int main() { }
</pre></blockquote>
<p>
b.cc:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
struct A { A(int, int); };

inline A::A(int, int = 0) { }

const std::true_type&amp; x2 = std::is_constructible&lt;A, int&gt;();
</pre></blockquote>
<p>
Presumably this program should invoke undefined behaviour, but the Library specification doesn't
say that.
</p>

<p><i>[2015-02 Cologne]</i></p>

<p>
Core wording should say "this kind of thing is ill-formed, no diagnostic required"
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2453" href="#2453">2453.</a> &sect;[iterator.range] and now [iterator.container] aren't available via <tt>&lt;initializer_list&gt;</tt></h3>
<p><b>Section:</b> 18.9 [support.initlist], 24.7 [iterator.range], 24.8 [iterator.container] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-11-11 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
These sections define helper functions, some of which apply to <tt>initializer_list&lt;T&gt;</tt>. And they're 
available if you include one of a long list of header files, many of which include <tt>&lt;initializer_list&gt;</tt>. 
But they are not available if you include <tt>&lt;initializer_list&gt;</tt>. This seems very odd.
</p>
<blockquote><pre>
#include &lt;initializer_list&gt;
auto x = {1, 2, 3};
const int *p = data(x); // error, undeclared
#include &lt;vector&gt;
const int *q = data(x); // ok
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2457" href="#2457">2457.</a> <tt>std::begin()</tt> and <tt>std::end()</tt> do not support multi-dimensional arrays correctly</h3>
<p><b>Section:</b> 24.7 [iterator.range] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Janez &#x17d;emva <b>Opened:</b> 2014-11-16 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.range">issues</a> in [iterator.range].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following code:
</p>
<blockquote><pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

int main() 
{
  int a[2][3][4] = { { { 1,  2,  3,  4}, { 5,  6,  7,  8}, { 9, 10, 11, 12} },
                     { {13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24} } };
  int b[2][3][4];

  assert(std::distance(std::begin(a), std::end(a)) == 2 * 3 * 4);
  std::copy(std::begin(a), std::end(a), std::begin(b));
  std::copy(std::begin(b), std::end(b), std::ostream_iterator&lt;int&gt;(std::cout, ","));
}
</pre></blockquote>
<p>
does not compile. 
<p/>
A possible way to remedy this would be to add the following overloads of
<tt>begin</tt>, <tt>end</tt>, <tt>rbegin</tt>, and <tt>rend</tt> to 24.7 [iterator.range], 
relying on recursive evaluation:
</p>
<blockquote><pre>
namespace std {

  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  begin(T (&amp;array)[M][N])
  {
    return begin(*array);
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  constexpr remove_all_extents_t&lt;T&gt;*
  end(T (&amp;array)[M][N])
  {
    return end(array[M - 1]);
  }

  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rbegin(T (&amp;array)[M][N])
  {
    return decltype(rbegin(array))(end(array[M - 1]));
  }
  
  template &lt;typename T, size_t M, size_t N&gt;
  reverse_iterator&lt;remove_all_extents_t&lt;T&gt;*&gt;
  rend(T (&amp;array)[M][N])
  {
    return decltype(rend(array))(begin(*array));
  }

}
</pre></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2460" href="#2460">2460.</a> LWG issue 2408 and value categories</h3>
<p><b>Section:</b> 20.15.7.6 [meta.trans.other], 24.4.1 [iterator.traits] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2014-11-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.trans.other">active issues</a> in [meta.trans.other].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG issue <a href="lwg-defects.html#2408">2408</a> changes the meat of the specification of <tt>common_type</tt> to compute:
</p>
<blockquote><p>
[&hellip;] the type, if any, of an unevaluated conditional expression (5.16) whose first operand is an 
arbitrary value of type <tt>bool</tt>, whose second operand is an <tt>xvalue</tt> of type <tt>T1</tt>, 
and whose third operand is an xvalue of type <tt>T2</tt>.
</p></blockquote>
<p>
This has an effect on the specification that I think was unintended. It used to be the case that 
<tt>common_type&lt;T&amp;, U&amp;&amp;&gt;</tt> would consider the type of a conditional between an 
lvalue of type <tt>T</tt> and an xvalue of type <tt>U</tt>. It's now either invalid (because there is 
no such thing as an xvalue of reference type) or considers the type of a conditional between an xvalue 
of type <tt>T</tt> and an xvalue of type <tt>U</tt>, depending on how you choose to read it.
<p/>
Put another way, this has the effect of changing the usual definition from:
</p>
<blockquote><pre>
typedef decay_t&lt;decltype(true ? declval&lt;T&gt;() : declval&lt;U&gt;())&gt; type;
</pre></blockquote>
<p>
to:
</p>
<blockquote><pre>
typedef decay_t&lt;decltype(true ? declval&lt;remove_reference_t&lt;T&gt;&gt;() : declval&lt;remove_reference_t&lt;U&gt;&gt;())&gt; type;
</pre></blockquote>
<p>
It also makes <tt>common_type</tt> underspecified in the case where one of the operands is of type <tt>void</tt>; 
in that case, the resulting type depends on whether the expression is a throw-expression, which is not 
specified (but used to be).
<p/>
Also on the subject of this wording: the changes to 24.4.1 [iterator.traits] say that 
<tt>iterator_traits&lt;T&gt;</tt> "shall have no members" in some cases. That's wrong. It's a class type; 
it always has at least a copy constructor, a copy assignment operator, and a destructor. Plus this 
removes the usual library liberty to add additional members with names that don't collide with normal 
usage (for instance, if a later version of the standard adds members, they can't be present here as a 
conforming extension). Perhaps this should instead require that the class doesn't have members with any 
of those five names? That's what <a href="lwg-defects.html#2408">2408</a> does for <tt>common_type</tt>'s type member.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>This issue has two parts, one dealing with <tt>common_type</tt>, the other with <tt>iterator_traits</tt>. 
The first of these is resolved by <a href="lwg-active.html#2465">2465</a>.  See below for the proposed resolution for the other one.</p>
<p>Wed PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>Change 24.4.1 [iterator.traits] p.2:</p>

<p>[&hellip;] as publicly accessible members <del>and no other members</del>:</p>

<p>[&hellip;]</p>

<p>Otherwise, <tt>iterator_traits&lt;Iterator&gt;</tt> shall have no members <ins>by any of the above names</ins>.</p>





<hr>
<h3><a name="2461" href="#2461">2461.</a> Interaction between allocators and container exception safety guarantees</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements], 23.3.11.3 [vector.capacity], 23.3.11.5 [vector.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> dyp <b>Opened:</b> 2014-12-06 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When resizing a <tt>vector</tt>, the accessibility and exception specification of the value type's 
constructors determines whether the elements are copied or moved to the new buffer.
However, the copy/move is performed via the allocator's <tt>construct</tt> member function, which is 
assumed, but not required, to call the copy/move constructor and propagate only exceptions 
from the value type's copy/move constructor. The issue might also affect other classes. 
<p/>
The current wording in N4296 relevant here is from Table 28 &mdash; "Allocator requirements" in 
17.6.3.5 [allocator.requirements]: 
</p>
<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.construct(c, args)</tt>
</td>
<td>
(not used)
</td>
<td>
<i>Effect</i>: Constructs an object of type <tt>C</tt> at <tt>c</tt>
</td>
<td>
<tt>::new ((void*)c) C(forward&lt;Args&gt;(args)...)</tt>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
<p>
and from 17.6.3.5 [allocator.requirements] p9:
</p>
<blockquote><p>
An allocator may constrain the types on which it can be instantiated and the arguments for which its
<tt>construct</tt> member may be called. If a type cannot be used with a particular allocator, the allocator class
or the call to <tt>construct</tt> may fail to instantiate.
</p></blockquote>
<p>
I conclude the following from the wording:
</p>
<ol>
<li><p>The allocator is not required to call the copy constructor if the
arguments (args) is a single (potentially const) lvalue of the value
type. Similarly for a non-const rvalue + move constructor. See also
23.2.1 [container.requirements.general] p15 which seems to try to require
this, but is not sufficient:
That paragraph specifies the semantics of the allocator's operations,
but not which constructors of the value type are used, if any.
</p></li>
<li>
<p>The allocator may throw exceptions in addition to the exceptions propagated by
the constructors of the value type; it can also propagate exceptions from constructors
other than a copy/move constructor.
</p>
</li>
</ol>
<p>
This leads to an issue with the wording of the exception safety guarantees for vector modifiers in
23.3.11.5 [vector.modifiers] p1:
</p>
<blockquote>
<p>
[&hellip;]
</p>
<pre>
void push_back(const T&amp; x);
void push_back(T&amp;&amp; x);
</pre>
<blockquote>
<p>
<i>Remarks</i>: Causes reallocation if the new size is greater than the old capacity. If no 
reallocation happens, all the iterators and references before the insertion point remain valid. 
If an exception is thrown other than by the copy constructor, move constructor, assignment 
operator, or move assignment operator of <tt>T</tt> or by any InputIterator operation there are 
no effects.
<span  style="color:#C80000;font-weight:bold">
If an exception is thrown while inserting a single element at the end and <tt>T</tt> 
is <tt>CopyInsertable</tt> or <tt>is_nothrow_move_constructible&lt;T&gt;::value</tt>
is true, there are no effects. Otherwise, if an exception is thrown by the move constructor of a
non-<tt>CopyInsertable</tt> <tt>T</tt>, the effects are unspecified.
</span>
</p>
</blockquote>
</blockquote>
<p>
The wording leads to the following problem:
Copy and move assignment are invoked directly from <tt>vector</tt>.
For intermediary objects (see <a href="lwg-active.html#2164">2164</a>),
<tt>vector</tt> also directly invokes the copy and move constructor of the value type.
However, construction of the actual element within the buffer is invoked via the allocator abstraction.
As discussed above, the allocator currently is not required to call a copy/move constructor.
If <tt>is_nothrow_move_constructible&lt;T&gt;::value</tt> is <tt>true</tt> for some value type <tt>T</tt>,
but the allocator uses modifying operations for <tt>MoveInsertion</tt> that do throw,
the implementation is required to ensure that "there are no effects",
even if the source buffer has been modified.
<p/>
Similarly, the <tt>vector</tt> capacity functions specify exception safety guarantees
referring to the move constructor of the value type. For example, <tt>vector::resize</tt> in 23.3.11.3 [vector.capacity] p14:
</p>
<blockquote>
<i>Remarks</i>: If an exception is thrown other than by the move constructor of a
non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects.
</blockquote>
<p>
The wording leads to the same issue as described above.
<p/>
Code example:
</p>
<blockquote>
<pre>
template&lt;class T&gt;
class allocator;

class pot_reg_type // a type which creates
                   // potentially registered instances
{
private:
  friend class allocator&lt;pot_reg_type&gt;;
  struct register_t {};

  static std::set&lt;pot_reg_type*&gt;&amp; get_registry()
  {
    static std::set&lt;pot_reg_type*&gt; registry;
    return registry;
  }
  void enregister() noexcept(false)
  {
    get_registry().insert(this);
  }
  void deregister()
  {
    get_registry().erase(this);
  }

public:
  pot_reg_type(void               ) noexcept(true) {}
  pot_reg_type(pot_reg_type const&amp;) noexcept(true) {}
  pot_reg_type(pot_reg_type&amp;&amp;     ) noexcept(true) {}

private:
  pot_reg_type(register_t                     ) noexcept(false)
  { enregister(); }
  pot_reg_type(register_t, pot_reg_type const&amp;) noexcept(false)
  { enregister(); }
  pot_reg_type(register_t, pot_reg_type&amp;&amp;     ) noexcept(false)
  { enregister(); }
};

template&lt;class T&gt;
class allocator
{
public:
  using value_type = T;

  value_type* allocate(std::size_t p)
  { return (value_type*) ::operator new(p); }

  void deallocate(value_type* p, std::size_t)
  { ::operator delete(p); }

  void construct(pot_reg_type* pos)
  {
    new((void*)pos) pot_reg_type((pot_reg_type::register_t()));
  }
  void construct(pot_reg_type* pos, pot_reg_type const&amp; source)
  {
    new((void*)pos) pot_reg_type(pot_reg_type::register_t(), source);
  }

  template&lt;class... Args&gt;
  void construct(T* p, Args&amp;&amp;... args)
  {
    new((void*)p) T(std::forward&lt;Args&gt;(args)...);
  }
}; 
</pre>
</blockquote>
<p>
The <tt>construct</tt> member function template is only required for rebinding,
which can be required e.g. to store additional debug information in
the allocated memory (e.g. VS2013).
<p/>
Even though the value type has an accessible and <tt>noexcept(true)</tt> move
constructor, this allocator won't call that constructor for rvalue arguments.
In any case, it does not call a constructor for which vector has formulated its 
requirements. An exception thrown by a constructor called by this allocator is not
covered by the specification in 23.3.11.5 [vector.modifiers] and therefore is
guaranteed not to have any effect on the vector object when resizing.
<p/>
For an example how this might invalidate the exception safety
guarantees, see <a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/BcM7ya8JeqY/discussion">this post on the std-discussion mailing list</a>.
<p/>
Another problem arises for value types whose constructors are private,
but may be called by the allocator e.g. via friendship.
Those value types are not <tt>MoveConstructible</tt> 
(<tt>is_move_constructible</tt> is false), yet they can be <tt>MoveInsertable</tt>.
It is not possible for <tt>vector</tt> to create intermediary objects (see <a href="lwg-active.html#2164">2164</a>) of such a type
by directly using the move constructor.
Current implementations of the single-element forms of <tt>vector::insert</tt> and <tt>vector::emplace</tt>
do create intermediary objects by directly calling one of the value type's constructors,
probably to allow inserting objects from references that alias other elements of the container.
As far as I can see, Table 100 &mdash; "Sequence container requirements" in 23.2.3 [sequence.reqmts]
does not require that the creation of such intermediare objects can be performed
by containers using the value type's constructor directly.
It is unclear to me if the allocator's construct function could be used to create those
intermediary objects, given that they have not been allocated by the allocator.
<p/>
Two possible solutions:
</p>
<ol>
<li><p>
Add the following requirement to the <tt>allocator_traits::construct</tt> function:
If the parameter pack <tt>args</tt> consists of a single parameter of the type
<tt>value_type&amp;&amp;</tt>,
the function may only propagate exceptions if <tt>is_nothrow_move_constructible&lt;value_type&gt;::value</tt>
is <tt>false</tt>.
<p/>
Requiring <tt>alloctor_traits::construct</tt> to call a true copy/move constructor
of the value type breaks <tt>std::scoped_allocator_adapter</tt>,
as pointed out by <a href="https://groups.google.com/a/isocpp.org/d/msg/std-discussion/0yxikZInp-E/Lxj-msFT22cJ">Casey Carter in a post on the std-discussion mailing list</a>.
</p></li>
<li>
<p>
Change vector's criterion whether to move or copy when resizing:
<p/>
Instead of testing the value type's constructors via
<tt>is_move_constructible</tt>, check the value of
<tt>noexcept( allocator_traits&lt;Allocator&gt;::construct(alloc, ptr, rval) )</tt>
where
<tt>alloc</tt> is an lvalue of type <tt>Allocator</tt>,
<tt>ptr</tt> is an expression of type <tt>allocator_traits&lt;Allocator&gt;::pointer</tt>
and
<tt>rval</tt> is a non-const rvalue of type <tt>value_type</tt>.
</p>
</li>
</ol>
<p>
A short discussion of the two solutions:
<p/>
Solution 1 allows keeping <tt>is_nothrow_move_constructible&lt;value_type&gt;</tt>
as the criterion for <tt>vector</tt> to decide between copying and moving when resizing.
It restricts what can be done inside the <tt>construct</tt> member function of allocators,
and requires implementers of allocators to pay attention to the value types used.
One could conceive allocators checking the following with a <tt>static_assert</tt>:
If the value type <tt>is_nothrow_move_constructible</tt>,
then the constructor actually called for <tt>MoveInsertion</tt> within the <tt>construct</tt>
member function is also declared as noexcept.
<p/>
Solution 2 requires changing both the implementation of the default
allocator (add a conditional <tt>noexcept</tt>) and <tt>vector</tt> (replace
<tt>is_move_constructible</tt> with an allocator-targeted check).
It does not impose additional restrictions on the allocator (other than
23.2.1 [container.requirements.general] p15),
and works nicely even if the move constructor of a <tt>MoveInsertable</tt> type is private or deleted
(the allocator might be a friend of the value type).
<p/>
In both cases, an addition might be required to provide the basic exception safety guarantee.
A short discussion on this topic can be found
<a href="https://groups.google.com/a/isocpp.org/d/topic/std-discussion/yZLnYy_y2z0/discussion">
in the std-discussion mailing list</a>.
Essentially, if <tt>allocator_traits&lt;Allocator&gt;::construct</tt> throws an exception,
the object may or may not have been constructed.
Two solutions are mentioned in that discussion:
</p>
<ol>
<li><p>
<tt>allocator_traits&lt;Allocator&gt;::construct</tt> needs to tell its caller
whether or not the construction was successful, in case of an exception.
</p></li>
<li><p>
If <tt>allocator_traits&lt;Allocator&gt;::construct</tt> propagates an exception,
it shall either not have constructed an object at the specified location,
or that object shall have been destroyed
(or it shall ensure otherwise that no resources are leaked).
</p></li>
</ol>

<p><i>[2015-05-23, Tomasz Kami&nacute;ski comments]</i></p>

<p>
Solution 1 discussed in this issue also breaks support for the <tt>polymorphic_allocator</tt> proposed in the part 
of the Library Fundamentals TS v1, in addition to already mentioned <tt>std::scoped_allocator_adapter</tt>. Furthermore 
there is unknown impact on the other user-defined state-full allocators code written in the C++11.
<p/>
In addition the library resolution proposed in the LWG issues <a href="lwg-active.html#2089">2089</a> and 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4462.html">N4462</a>, 
will break the relation between the <tt>std::allocator_trait::construct</tt> method and 
copy/move constructor even for the standard <tt>std::allocator</tt>. As example please consider following class:
</p>
<blockquote><pre>
struct NonCopyable
{
  NonCopyable() = default;
  NonCopyable(NonCopyable const&amp;) = delete;
  NonCopyable(NonCopyable&amp;&amp;) = delete;
};

struct InitListConstructor : NonCopyable
{
  InitListConstructor() = default;
  InitListConstructor(std::initializer_list&lt;int&gt;);
  operator int() const;
};
</pre></blockquote>
<p>
For the above declarations following expression are ill-formed:
</p>
<blockquote><pre>
InitListConstructor copy(std::declval&lt;InitListConstructor const&amp;&gt;());
InitListConstructor move(std::declval&lt;InitListConstructor&amp;&amp;&gt;());
</pre></blockquote>
<p>
So the class is not <tt>CopyConstructible</tt> nor <tt>MoveConstructible</tt>. However the following are well formed:
</p>
<blockquote><pre>
InitListConstructor copy{std::declval&lt;InitListConstructor const&amp;&gt;()};
InitListConstructor move{std::declval&lt;InitListConstructor&amp;&amp;&gt;()};
</pre></blockquote>
<p>
And will be used by <tt>std::allocator&lt;InitListConstructor&gt;::construct</tt> in case of move-insertion 
and copy-insertion, after appliance of the resolution proposed in mentioned papers:
</p>
<blockquote>
<p>
The gist of the proposed library fix is simple:
</p>
<ul>
<li><p>if <tt>is_constructible_v&lt;TargetType, Args...&gt;</tt>, use direct-nonlist-initialization</p></li>
<li><p>otherwise, use brace-initialization.</p></li>
</ul>
</blockquote>
<p>
As consequence the requirement proposed in the Solution 1:
</p>
<blockquote><p>
If the parameter pack <tt>args</tt> consists of a single parameter of the type <tt>value_type&amp;&amp;</tt>, 
the function may only propagate exceptions if <tt>is_nothrow_move_constructible&lt;value_type&gt;::value</tt> is false. 
</p></blockquote>
<p>
Will no longer hold for the <tt>std::allocator</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2465" href="#2465">2465.</a> SFINAE-friendly <tt>common_type</tt> is nearly impossible to specialize
correctly and regresses key functionality</h3>
<p><b>Section:</b> 20.15.7.6 [meta.trans.other] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Niebler <b>Opened:</b> 2015-01-12 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.trans.other">active issues</a> in [meta.trans.other].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think there's a defect regarding <tt>common_type</tt> and its specializations.
Unless I've missed it, there is nothing preventing folks from
instantiating <tt>common_type</tt> with <i>cv</i>-qualified types or reference types. In
fact, the wording in N3797 explicitly mentions <i>cv</i> <tt>void</tt>, so presumably at
least <i>cv</i> qualifications are allowed.
<p/>
Users are given license to specialize <tt>common_type</tt> when at least of of
the types is user-defined. (A separate issue is the meaning of
user-defined. In core, I believe this is any class/struct/union/enum,
but in lib, I think it means any type not defined in std, right?) There
is at least one place in the standard that specializes <tt>common_type</tt>
(time.traits.specializations) on time_point and duration. But the
specializations are only for non-<i>cv</i>-qualified and non-reference
specializations of <tt>time_point</tt> and <tt>duration</tt>.
<p/>
If the user uses, say, <tt>common_type&lt;duration&lt;X,Y&gt; const, duration&lt;A,B&gt;
const&gt;</tt>, they're not going to get the behavior they expect.
<p/>
Suggest we clarify the requirements of <tt>common_type</tt>'s template
parameters. Also, perhaps we can add blanket wording that <tt>common_type&lt;A
[<i>cv</i>][&amp;], B [<i>cv</i>][&amp;]&gt;</tt> is required to be equivalent to 
<tt>common_type&lt;A,B&gt;</tt> (if that is in fact the way we intent this to work).
<p/>
Also, the change to make <tt>common_type</tt> SFINAE-friendly regressed key
functionality, as noted by Agust&iacute;n K-ballo Berg&eacute; in 
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=37178">c++std-lib-37178</a>.
Since <tt>decay_t</tt> is not applied until the very end of the type computation,
user specializations are very likely to to be found.
<p/>
Agust&iacute;n says:
</p>
<blockquote class="note">
<p>
Consider the following snippet:
</p>
<blockquote>
<pre>
struct X {};
struct Y { explicit Y(X){} };

namespace std {
  template&lt;> struct common_type&lt;X, Y> { typedef Y type; };
  template&lt;> struct common_type&lt;Y, X> { typedef Y type; };
}

static_assert(is_same&lt;common_type_t&lt;X, Y>, Y>()); // (A)
static_assert(is_same&lt;common_type_t&lt;X, Y, Y>, Y>()); // (B)
static_assert(is_same&lt;common_type_t&lt;X, X, Y>, Y>()); // (C)
</pre>
</blockquote>
<p>
Under the original wording, all three assertion holds. Under the current wording,
</p>
<ul>
<li><p>(A) picks the user-defined specialization, so the assertion holds.</p></li>

<li><p>(B) goes to the third bullet and, ignoring the user-defined specialization, looks for 
<tt>decltype(true ? declval&lt;X&gt;() : declval&lt;Y&gt;())</tt>; since it is ill-formed 
there is no common type.</p></li>

<li><p>(C) goes to the third bullet and yields <tt>common_type_t&lt;X&amp;&amp;, Y&gt;</tt>, which again misses 
the user-defined specialization.</p></li>
</ul>
</blockquote>
<p>
The discussion following <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=35636">c++std-lib-35636</a> 
seemed to cohere around the idea that the primary <tt>common_type</tt> specialization should have the effect
of stripping top-level ref and <i>cv</i> qualifiers by applying <tt>std::decay_t</tt> to its arguments and, 
if any of them change as a result of that transformation, re-dispatching to <tt>common_type</tt> on those transformed
arguments, thereby picking up any user-defined specializations. This change to <tt>common_type</tt> would make 
the specializations in time.traits.specializations sufficient.
<p/>
<b>Suggested wording</b>:
<p/>
I'm afraid I don't know enough to suggest wording. But for exposition,
the following is my best shot at implementing the suggested resolution.
I believe it also fixes the regression noted by Agust&iacute;n K-ballo Berg&eacute; in
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=37178">c++std-lib-37178</a>.
</p>
<blockquote>
<pre>
namespace detail
{
    template&lt;typename T, typename U&gt;
    using default_common_t =
        decltype(true? std::declval&lt;T&gt;() : std::declval&lt;U&gt;());

    template&lt;typename T, typename U, typename Enable = void&gt;
    struct common_type_if
    {};

    template&lt;typename T, typename U&gt;
    struct common_type_if&lt;T, U,
      void_t&lt;default_common_t&lt;T, U&gt;&gt;&gt;
    {
      using type = decay_t&lt;default_common_t&lt;T, U&gt;&gt;;
    };

    template&lt;typename T, typename U,
       typename TT = decay_t&lt;T&gt;, typename UU = decay_t&lt;U&gt;&gt;
    struct common_type2
      : common_type&lt;TT, UU&gt; // Recurse to catch user specializations
    {};

    template&lt;typename T, typename U&gt;
    struct common_type2&lt;T, U, T, U&gt;
      : common_type_if&lt;T, U&gt;
    {};

    template&lt;typename Meta, typename Enable = void&gt;
    struct has_type
      : std::false_type
    {};

    template&lt;typename Meta&gt;
    struct has_type&lt;Meta, void_t&lt;typename Meta::type&gt;&gt;
      : std::true_type
    {};

    template&lt;typename Meta, typename...Ts&gt;
    struct common_type_recurse
      : common_type&lt;typename Meta::type, Ts...&gt;
    {};

    template&lt;typename Meta, typename...Ts&gt;
    struct common_type_recurse_if
      : std::conditional&lt;
          has_type&lt;Meta>::value,
          common_type_recurse&lt;Meta, Ts...&gt;,
          empty
        >::type
    {};
}

template&lt;typename ...Ts&gt;
struct common_type
{};

template&lt;typename T>
struct common_type&lt;T>
{
  using type = std::decay_t&lt;T&gt;;
};

template&lt;typename T, typename U&gt;
struct common_type&lt;T, U&gt;
  : detail::common_type2&lt;T, U&gt;
{};

template&lt;typename T, typename U, typename... Vs&gt;
struct common_type&lt;T, U, Vs...&gt;
  : detail::common_type_recurse_if&lt;common_type&lt;T, U&gt;, Vs...&gt;
{};
</pre>
</blockquote>
<p><i>[2016-08 Chicago]</i></p>

<p>Walter and Nevin provide wording.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p><i>[This also resolves the first part of <a href="lwg-active.html#2460">2460</a>]</i></p>


<p>In Table 46 of N4604, entry for <tt>common_type</tt>:</p>

<blockquote><p>
... may specialize this trait if at least one template parameter in the specialization is a user-defined type <ins>and no template parameter is cv-qualified</ins>.
</p></blockquote>

<p>In [meta.trans.other] bullet 3.3:</p>

<blockquote><p>
... whose second operand is an xvalue of type <del><tt>T1</tt></del><ins><tt>decay_t&lt;T1&gt;</tt></ins>, and whose third operand is an xvalue of type <del><tt>T2</tt></del><ins><tt>decay_t&lt;T2&gt;</tt></ins>.  If ...
</p></blockquote>
</blockquote>

<p><i>[2016-08-02, Chicago: Walt, Nevin, Rob, and Hal provide revised wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<p><i>[This also resolves the first part of LWG <a href="lwg-active.html#2460">2460</a>]</i></p>


<ol>
<li><p>In Table 46 &mdash; "Other transformations" edit the entry for <tt>common_type</tt>:</p>

<blockquote>
<table border="1">
<caption>Table 46 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class... T&gt;<br/>
struct common_type;</tt>
</td>

<td>
The member typedef <tt>type</tt> shall be defined or omitted as specified below.<br/>
If it is omitted, there shall be no member <tt>type</tt>. All types in the<br/>
parameter pack <tt>T</tt> shall be complete or (possibly <i>cv</i>) <tt>void</tt>.<br/> 
A program may specialize this trait <ins>for two <i>cv</i>-unqualified non-reference types</ins><br/> 
if at least one <del>template parameter in the specialization</del><ins>of them</ins><br/> 
is a user-defined type. [<i>Note:</i> Such specializations are<br/>
needed when only explicit conversions are desired among the template<br/>
arguments. &mdash; <i>end note</i>]
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Edit 20.15.7.6 [meta.trans.other] p3 (and its subbullets) as shown below</p>

<blockquote>
<p>
For the <tt>common_type</tt> trait applied to a parameter pack <tt>T</tt> of types, the member <tt>type</tt> 
shall be either defined or not present as follows:
</p>
<ul>
<li><p>If <tt>sizeof...(T)</tt> is zero, there shall be no member <tt>type</tt>.</p></li>
<li><p>If <tt>sizeof...(T)</tt> is one, let <tt>T0</tt> denote the sole type in the pack <tt>T</tt>. 
The member typedef <tt>type</tt> shall denote the same type as <tt>decay_t&lt;T0&gt;</tt>.</p></li>
<li><p><ins>If <tt>sizeof...(T)</tt> is two, let <code>T1</code> and <code>T2</code>, respectively,
denote the first and second types comprising <code>T</code>, and let <code>D1</code> and <code>D2</code>, 
respectively, denote <code>decay_t&lt;T1&gt;</code> and <code>decay_t&lt;T2&gt;</code>.</ins></p>
<ul>
<li><p><ins>If <code>is_same_v&lt;T1, D1&gt;</code>
and <code>is_same_v&lt;T2, D2&gt;</code>,
and if there is no specialization
<code>common_type&lt;T1, T2&gt;</code>,
let <code>C</code> denote the type, if any,
of an unevaluated conditional expression (5.16 [expr.cond])
whose first operand is an arbitrary value of type <code>bool</code>,
whose second operand is an xvalue of type <code>D1</code>,
and whose third operand is an xvalue of type <code>D2</code>.
If there is such a type <code>C</code>,
the member typedef <code>type</code>
shall denote <code>C</code>.
Otherwise, there shall be no member <code>type</code>.</ins></p></li>
<li><p><ins>If <code>not is_same_v&lt;T1, D1&gt;</code>
or <code>not is_same_v&lt;T2, D2&gt;</code>,
the member typedef <code>type</code>
shall denote the same type, if any, as <tt>common_type_t&lt;D1, D2&gt;</tt>.
Otherwise, there shall be no member <code>type</code>.</ins></p></li>
</ul>
</li>
<li><p>If <tt>sizeof...(T)</tt> is greater than <del>one</del><ins>two</ins>, let <tt>T1</tt>, <tt>T2</tt>, and <tt>R</tt>, 
respectively, denote the first, second, and (pack of) remaining types comprising <tt>T</tt>. 
<del>[<i>Note:</i> <tt>sizeof...(R)</tt> may be zero. &mdash; <i>end note</i>] Let <tt>C</tt> denote the
type, if any, of an unevaluated conditional expression (5.16 [expr.cond]) whose first operand is an arbitrary value
of type <tt>bool</tt>, whose second operand is an xvalue of type <tt>T1</tt>, and whose third operand is 
an xvalue of type <tt>T2</tt>.</del> <ins>Let <code>C</code> denote <code>common_type_t&lt;T1, T2&gt;</code>.</ins> 
If there is such a type <tt>C</tt>, the member typedef <tt>type</tt> 
shall denote the same type, if any, as <tt>common_type_t&lt;C, R...&gt;</tt>. Otherwise, there shall 
be no member <tt>type</tt>.</p></li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
LWG asks for minor wording tweaks and for an added Note.
Walter revises the Proposed Resolution accordingly.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<p><i>[This also resolves the first part of LWG <a href="lwg-active.html#2460">2460</a>]</i></p>


<ol>
<li><p>In Table 46 &mdash; "Other transformations" edit the entry for <tt>common_type</tt>:</p>

<blockquote>
<table border="1">
<caption>Table 46 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class... T&gt;<br/>
struct common_type;</tt>
</td>

<td>
The member typedef <tt>type</tt> shall be defined or omitted as specified below.<br/>
If it is omitted, there shall be no member <tt>type</tt>. All types in the<br/>
parameter pack <tt>T</tt> shall be complete or (possibly <i>cv</i>) <tt>void</tt>.<br/> 
A program may specialize this trait <ins>for two <i>cv</i>-unqualified non-reference types</ins><br/> 
if at least one <del>template parameter in the specialization</del><ins>of them</ins><br/> 
is a user-defined type. [<i>Note:</i> Such specializations are<br/>
needed when only explicit conversions are desired among the template<br/>
arguments. &mdash; <i>end note</i>]
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Edit 20.15.7.6 [meta.trans.other] p3 (and its subbullets) as shown below</p>

<blockquote>
<p>
For the <tt>common_type</tt> trait applied to a parameter pack <tt>T</tt> of types, the member <tt>type</tt> 
shall be either defined or not present as follows:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If <tt>sizeof...(T)</tt> is zero, there shall be no member <tt>type</tt>.</p></li>
<li><p>(3.2) &mdash; If <tt>sizeof...(T)</tt> is one, let <tt>T0</tt> denote the sole type in the pack <tt>T</tt>. 
The member typedef <tt>type</tt> shall denote the same type as <tt>decay_t&lt;T0&gt;</tt>.</p></li>
<li><p>(3.3) &mdash; <ins>If <tt>sizeof...(T)</tt> is two, let <code>T1</code> and <code>T2</code>, respectively,
denote the first and second types comprising <code>T</code>, and let <code>D1</code> and <code>D2</code>, 
respectively, denote <code>decay_t&lt;T1&gt;</code> and <code>decay_t&lt;T2&gt;</code>.</ins></p>
<ol style="list-style-type: none">
<li><p>(3.3.1) &mdash; <ins>If <code>is_same_v&lt;T1, D1&gt;</code> and <code>is_same_v&lt;T2, D2&gt;</code>,
let <code>C</code> denote the type of an unevaluated conditional expression (5.16 [expr.cond])
whose first operand is an arbitrary value of type <code>bool</code>,
whose second operand is an xvalue of type <code>D1</code>,
and whose third operand is an xvalue of type <code>D2</code>.
[<i>Note:</i> This will not apply if there is a specialization <code>common_type&lt;D1, D2&gt;</code>. &mdash; 
<i>end note</i>]</ins></p></li>
<li><p>(3.3.2) &mdash; <ins>Otherwise, let <code>C</code> denote the type
<code>common_type_t&lt;D1, D2&gt;</code>.</ins></p></li>
</ol>
<p><ins> In either case, if there is such a type <code>C</code>,
the member typedef <code>type</code> shall denote <code>C</code>.
Otherwise, there shall be no member <code>type</code>.</ins></p>
</li>
<li><p>(3.4) &mdash; If <tt>sizeof...(T)</tt> is greater than <del>one</del><ins>two</ins>, let <tt>T1</tt>, <tt>T2</tt>, and <tt>R</tt>, 
respectively, denote the first, second, and (pack of) remaining types comprising <tt>T</tt>. 
<del>[<i>Note:</i> <tt>sizeof...(R)</tt> may be zero. &mdash; <i>end note</i>] Let <tt>C</tt> denote the
type, if any, of an unevaluated conditional expression (5.16 [expr.cond]) whose first operand is an arbitrary value
of type <tt>bool</tt>, whose second operand is an xvalue of type <tt>T1</tt>, and whose third operand is 
an xvalue of type <tt>T2</tt>.</del> <ins>Let <code>C</code> denote <code>common_type_t&lt;T1, T2&gt;</code>.</ins> 
If there is such a type <tt>C</tt>, the member typedef <tt>type</tt> 
shall denote the same type, if any, as <tt>common_type_t&lt;C, R...&gt;</tt>. Otherwise, there shall 
be no member <tt>type</tt>.</p></li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-04 Chicago LWG]</i></p>

<p>
Alisdair notes that 17.6.4.2.1 [namespace.std] p.1 seems to prohibit some kinds of specializations that we want to 
permit here and asks that the Table entry be augmented so as to specify the precise rules that a specialization 
is required to obey.
Walter revises Proposed Resolution accordingly.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri PM: Move to Tentatively Ready</p>

<p><i>[2016-08-11 Daniel comments]</i></p>

<p>
LWG <a href="lwg-active.html#2763">2763</a> presumably provides a superiour resolution that also fixes another bug in the Standard.
</p>

<p><i>[2016-08-12]</i></p>

<p>
Howard request to reopen this issue because of the problem pointed out by LWG <a href="lwg-active.html#2763">2763</a>.
</p>


<p><i>[2016-08-13 Tim Song comments]</i></p>

<p>
In addition to the issue pointed out in LWG <a href="lwg-active.html#2763">2763</a>, the current P/R no longer decays the type
of the conditional expression. However, that seems harmless since 5 [expr]/5 means that the 
"type of an expression" is never a reference type, and 5.16 [expr.cond]'s rules appear to ensure that
the type of the conditional expression will never be "decay-able" when fed with two xvalues of cv-unqualified
non-array object type. Nonetheless, a note along the lines of "[<i>Note:</i> <code>C</code> is never a reference,
function, array, or cv-qualified type. &mdash; <i>end note</i>]" may be appropriate, similar to the note 
at the end of 8.5 [dcl.decomp]/1.
</p>

<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<p><i>[This also resolves the first part of LWG <a href="lwg-active.html#2460">2460</a>]</i></p>


<ol>
<li><p>In Table 46 &mdash; "Other transformations" edit the entry for <tt>common_type</tt>:</p>

<blockquote>
<table border="1">
<caption>Table 46 &mdash; Other transformations</caption>
<tr>
<th align="center">Template</th>
<th align="center">Comments</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class... T&gt;<br/>
struct common_type;</tt>
</td>

<td>
<ins>Unless this trait is specialized (as specified in Note B, below), t</ins><del>T</del>he<br/>
member typedef <tt>type</tt> shall be defined or omitted as specified <ins>in Note A,</ins> below.<br/>
If it is omitted, there shall be no member <tt>type</tt>. All types in the<br/>
parameter pack <tt>T</tt> shall be complete or (possibly <i>cv</i>) <tt>void</tt>.<br/> 
<del>A program may specialize this trait<br/> 
if at least one template parameter in the specialization<br/> 
is a user-defined type. [<i>Note:</i> Such specializations are<br/>
needed when only explicit conversions are desired among the template<br/>
arguments. &mdash; <i>end note</i>]</del>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Edit 20.15.7.6 [meta.trans.other] p3 (and its subbullets) as shown below</p>

<blockquote>
<p>
-3- <ins>Note A:</ins> For the <tt>common_type</tt> trait applied to a parameter pack <tt>T</tt> of types, the 
member <tt>type</tt> shall be either defined or not present as follows:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If <tt>sizeof...(T)</tt> is zero, there shall be no member <tt>type</tt>.</p></li>
<li><p>(3.2) &mdash; If <tt>sizeof...(T)</tt> is one, let <tt>T0</tt> denote the sole type in the pack <tt>T</tt>. 
The member typedef <tt>type</tt> shall denote the same type as <tt>decay_t&lt;T0&gt;</tt>.</p></li>
<li><p>(3.3) &mdash; <ins>If <tt>sizeof...(T)</tt> is two, let <code>T1</code> and <code>T2</code>, respectively,
denote the first and second types comprising <code>T</code>, and let <code>D1</code> and <code>D2</code>, 
respectively, denote <code>decay_t&lt;T1&gt;</code> and <code>decay_t&lt;T2&gt;</code>.</ins></p>
<ol style="list-style-type: none">
<li><p>(3.3.1) &mdash; <ins>If <code>is_same_v&lt;T1, D1&gt;</code> and <code>is_same_v&lt;T2, D2&gt;</code>,
let <code>C</code> denote the type of an unevaluated conditional expression (5.16 [expr.cond])
whose first operand is an arbitrary value of type <code>bool</code>,
whose second operand is an xvalue of type <code>D1</code>,
and whose third operand is an xvalue of type <code>D2</code>.
[<i>Note:</i> This will not apply if there is a specialization <code>common_type&lt;D1, D2&gt;</code>. &mdash; 
<i>end note</i>]</ins></p></li>
<li><p>(3.3.2) &mdash; <ins>Otherwise, let <code>C</code> denote the type
<code>common_type_t&lt;D1, D2&gt;</code>.</ins></p></li>
</ol>
<p><ins> In either case, if there is such a type <code>C</code>,
the member typedef <code>type</code> shall denote <code>C</code>.
Otherwise, there shall be no member <code>type</code>.</ins></p>
</li>
<li><p>(3.4) &mdash; If <tt>sizeof...(T)</tt> is greater than <del>one</del><ins>two</ins>, let <tt>T1</tt>, <tt>T2</tt>, and <tt>R</tt>, 
respectively, denote the first, second, and (pack of) remaining types comprising <tt>T</tt>. 
<del>[<i>Note:</i> <tt>sizeof...(R)</tt> may be zero. &mdash; <i>end note</i>] Let <tt>C</tt> denote the
type, if any, of an unevaluated conditional expression (5.16 [expr.cond]) whose first operand is an arbitrary value
of type <tt>bool</tt>, whose second operand is an xvalue of type <tt>T1</tt>, and whose third operand is 
an xvalue of type <tt>T2</tt>.</del> <ins>Let <code>C</code> denote <code>common_type_t&lt;T1, T2&gt;</code>.</ins> 
If there is such a type <tt>C</tt>, the member typedef <tt>type</tt> 
shall denote the same type, if any, as <tt>common_type_t&lt;C, R...&gt;</tt>. Otherwise, there shall 
be no member <tt>type</tt>.</p></li>
</ol>
<p>
<ins>-?- Note B: A program may specialize the <code>common_type</code> trait for two <i>cv</i>-unqualified 
non-reference types if at least one of them is a user-defined type. [<i>Note:</i> Such specializations are
needed when only explicit conversions are desired among the template
arguments. &mdash; <i>end note</i>] Such a specialization need not have a member named <code>type</code>,
but if it does, that member shall be a <i>typedef-name</i> for a <i>cv</i>-unqualified non-reference type
that need not otherwise meet the specification set forth in Note A, above.</ins>
<p/>
-4- [<i>Example:</i> Given these definitions: [&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2468" href="#2468">2468.</a> Self-move-assignment of library types</h3>
<p><b>Section:</b> 17.6.4.9 [res.on.arguments], 17.6.3.1 [utility.arg.requirements], 17.6.5.15 [lib.types.movedfrom], 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2015-01-22 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#res.on.arguments">issues</a> in [res.on.arguments].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Suppose we write
</p>
<blockquote>
<pre>
vector&lt;string&gt; v{"a", "b", "c", "d"};
v = move(v);
</pre>
</blockquote>
<p>
What should be the state of <tt>v</tt> be? The standard doesn't say anything specific about self-move-assignment. 
There's relevant text in several parts of the standard, and it's not clear how to reconcile them.
<p/>
17.6.4.9 [res.on.arguments] writes that, for all functions in the standard library, unless explicitly stated 
otherwise, "If a function argument binds to an rvalue reference parameter, the implementation may assume that this 
parameter is a unique reference to this argument." The <tt>MoveAssignable</tt> requirements table in 
17.6.3.1 [utility.arg.requirements] writes that, given <tt>t = rv</tt>, <tt>t</tt>'s state is equivalent to 
<tt>rv</tt>'s from before the assignment and <tt>rv</tt>'s state is unspecified (but valid). For containers 
specifically, the requirements table in 23.2.1 [container.requirements.general] says that, given <tt>a = rv</tt>, 
<tt>a</tt> becomes equal to what <tt>rv</tt> was before the assignment (and doesn't say anything about <tt>rv</tt>'s 
state post-assignment).
<p/>
Taking each of these pieces in isolation, without reference to the other two:
</p>
<ul>
<li><p>17.6.4.9 [res.on.arguments] would clearly imply that the effect of <tt>v = move(v)</tt> is undefined.</p></li>
<li><p>17.6.3.1 [utility.arg.requirements] would clearly imply that <tt>v = move(v)</tt> has defined behavior. 
It might be read to imply that this is a no-op, or might be read to imply that it leaves <tt>v</tt> in a valid but 
unspecified state; I'm not sure which reading is more natural.</p></li>
<li><p>23.2.1 [container.requirements.general] would clearly imply that <tt>v = move(v)</tt> is a no-op.</p></li>
</ul>
<p>
It's not clear from the text how to put these pieces together, because it's not clear which one takes precedence.  
Maybe 17.6.4.9 [res.on.arguments] wins (it imposes an implicit precondition that isn't mentioned in the 
<tt>MoveAssignable</tt> requirements, so <tt>v = move(v)</tt> is undefined), or maybe 
23.2.1 [container.requirements.general] wins (it explicitly gives additional guarantees for 
<tt>Container::operator=</tt> beyond what's guaranteed for library functions in general, so <tt>v = move(v)</tt> 
is a no-op), or maybe something else.
<p/>
On the existing implementations that I checked, for what it's worth, <tt>v = move(v)</tt> appeared to clear the vector; 
it didn't leave the vector unchanged and it didn't cause a crash.
<p/>
<em>Proposed wording</em>:
<p/>
Informally: change the <tt>MoveAssignable</tt> and Container requirements tables (and any other requirements tables 
that mention move assignment, if any) to make it explicit that <tt>x = move(x)</tt> is defined behavior and it leaves 
<tt>x</tt> in a valid but unspecified state. That's probably not what the standard says today, but it's probably what 
we intended and it's consistent with what we've told users and with what implementations actually do.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>JW: So far, the library forbids self-assignment since it assumes that anything bound to an rvalue reference has no aliases. But self-assignment can happen in real code, and it can be implemented. So I want to add an exception to the Standard that this should be allowed and leave the object in a valid-but-unspecified state.</p>
<p>STL: When this is resolved, I want to see a) VBU for library types after self-move, but also b) requirements on user types for self-moves. E.g. should algorithms be required to avoid self-assignments (since a user-defined type might blow up)? HH: In other words, should we require that you can assign from moved-from values.</p>
<p>WEB: What can one generally do with moved-from values?</p>
<p>VV: Call any member function that has no preconditions.</p>
<p>JW: That's certainly the library requirement, and it's also good guidance for user types.</p>
<p>JW: I'm writing wording. I care about this.</p>
<p>Move to Open; Jonathan to provide wording</p>

<p><i>[2016-08-01, Howard provided wording]</i></p>


<p><i>[2016-08 Chicago]</i></p>

<p>Tuesday AM: Move to Tentatively Ready</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
In 17.6.3.2 [swappable.requirements], modify Table 23 &mdash; <code>MoveAssignable</code> requirements [moveassignable]:
</p>

<blockquote>

<table border="1">
<caption>Table 23 &mdash; <tt>MoveAssignable</tt> requirements [moveassignable]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Return value</th>
<th>Post-condition</th>
</tr>

<tr>
<td><tt>t = rv</tt></td>
<td><tt>T&amp;</tt></td>
<td><tt>t</tt></td>
<td><ins>If <tt>addressof(t) != addressof(rv)</tt>,</ins> <tt>t</tt> is
equivalent to the value of <tt>rv</tt> before the assignment</td>
</tr>

<tr>
<td colspan="4">
<tt>rv</tt>'s state is unspecified. [<i>Note:</i> <tt>rv</tt> must
still meet the requirements of the library component that is using it<ins>,
whether or not <tt>addressof(t) == addressof(rv)</tt></ins>. The
operations listed in those requirements must work as specified whether
<tt>rv</tt> has been moved from or not. &mdash; <i>end note</i>] </td>
</tr>

</table>

</blockquote>

</blockquote>

<p><i>[2016-08-07, Daniel reopens]</i></p>

<p>
With the acceptance of LWG <a href="lwg-active.html#2598">2598</a>, the proposed wording is invalid code, because it attempts to
call <code>std::addressof</code> with an rvalue argument. It should be pointed out that the new restriction 
caused by <a href="lwg-active.html#2598">2598</a> doesn't affect real code, because any identity test within a move assignment
operator (or any comparable function) would act on the current function argument, which is an lvalue in the
context of the function body. The existing wording form of the issue could still be kept, if a helper variable
would be introduced such as:
</p>
<blockquote><p>
<ins>Let <code>refrv</code> denote a reference initialized as if by <code>const T&amp; refrv = rv;</code>. Then 
if <code>addressof(t) != addressof(refrv)</code>,</ins> <code>t</code> is equivalent to the value of <code>rv</code> 
before the assignment
</p></blockquote>
<p>
But it seems to me that the same effect could be much easier realized by replacing the code form by 
a non-code English phrase that realizes the same effect.
</p>

<p><i>[2016-09-09 Issues Resolution Telecon]</i></p>

<p>Move to Tentatively Ready</p>

<p><i>[2016-10-05, Tim Song comments]</i></p>

<p>
The current P/R of LWG 2468 simply adds to <tt>MoveAssignable</tt> the requirement to tolerate self-move-assignment, 
but that doesn't actually do much about self-move-assignment of library types. Very few types in the library are 
explicitly required to satisfy <tt>MoveAssignable</tt>, so as written the restriction in 17.6.4.9 [res.on.arguments] 
would seem to still apply for any type that's not explicitly required to be <tt>CopyAssignable</tt> or <tt>MoveAssignable</tt>.
<p/>
The current P/R also doesn't address the issue with 23.2.1 [container.requirements.general] noted in the issue discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p> In 17.6.3.2 [swappable.requirements], modify Table 23 &mdash; <code>MoveAssignable</code> 
requirements [moveassignable]:</p>

<blockquote>

<table border="1">
<caption>Table 23 &mdash; <tt>MoveAssignable</tt> requirements [moveassignable]</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Return value</th>
<th>Post-condition</th>
</tr>

<tr>
<td><tt>t = rv</tt></td>
<td><tt>T&amp;</tt></td>
<td><tt>t</tt></td>
<td><ins>If <code>t</code> and <code>rv</code> do not refer to the same object,</ins> <tt>t</tt> is
equivalent to the value of <tt>rv</tt> before the assignment</td>
</tr>

<tr>
<td colspan="4">
<tt>rv</tt>'s state is unspecified. [<i>Note:</i> <tt>rv</tt> must
still meet the requirements of the library component that is using it<ins>,
whether or not <code>t</code> and <code>rv</code> refer to the same object</ins>. The
operations listed in those requirements must work as specified whether
<tt>rv</tt> has been moved from or not. &mdash; <i>end note</i>] </td>
</tr>

</table>

</blockquote>
</li>
</ol>





<hr>
<h3><a name="2471" href="#2471">2471.</a> <tt>copy_n</tt>'s number of <tt>InputIterator</tt> increments unspecified</h3>
<p><b>Section:</b> 25.4.1 [alg.copy] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-01-28 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.copy">active issues</a> in [alg.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.copy">issues</a> in [alg.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It's unspecified how many times <tt>copy_n</tt> increments the <tt>InputIterator</tt>.
<tt>uninitialized_copy_n</tt> is specified to increment it exactly <tt>n</tt> times,
which means if an <tt>istream_iterator</tt> is used then the next character
after those copied is read from the stream and then discarded, losing data.
<p/>
I believe all three of Dinkumware, libc++ and libstdc++ implement
<tt>copy_n</tt> with <tt>n - 1</tt> increments of the <tt>InputIterator</tt>, which avoids reading
and discarding a character when used with <tt>istream_iterator</tt>, but is
inconsistent with <tt>uninitialized_copy_n</tt> and causes surprising behaviour
with <tt>istreambuf_iterator</tt> instead, because <tt>copy_n(in, 2, copy_n(in, 2,
out))</tt> is not equivalent to <tt>copy_n(in, 4, out)</tt>
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: refer to LEWG</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2472" href="#2472">2472.</a> Heterogeneous comparisons in the standard library can result in ambiguities</h3>
<p><b>Section:</b> 20.5.2.8 [tuple.rel], 20.10.9.2 [allocator.globals], 20.11.1.5 [unique.ptr.special], 20.11.2.2.7 [util.smartptr.shared.cmp], 20.17.5.6 [time.duration.comparisons], 20.17.6.6 [time.point.comparisons], 20.13.5 [scoped.adaptor.operators], 24.5.1.3.13 [reverse.iter.op==], 24.5.3.3.13 [move.iter.op.comp] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-02-07 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.rel">active issues</a> in [tuple.rel].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.rel">issues</a> in [tuple.rel].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard library specifies a lot of heterogeneous comparison operators. For instance:
</p>
<blockquote>
<pre>
template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);
</pre>
</blockquote>
<p>
This has an unfortunate consequence:
</p>
<blockquote>
<pre>
#include &lt;tuple&gt;
#include &lt;utility&gt;

using namespace std::rel_ops;
std::tuple&lt;int&gt; a(0);
bool b = a != a;
</pre>
</blockquote>
<p>
The last line here is ill-formed due to ambiguity: it might be <tt>rel_ops::operator!=</tt>, and it might be the 
heterogeneous tuple <tt>operator!=</tt>. These are not partially ordered, because they have different constraints: 
<tt>rel_ops</tt> requires the types to match, whereas the tuple comparison requires both types to be tuples (but not 
to match). The same thing happens for user code that defines its own unconstrained 
'<tt>template&lt;typename T&gt; operator!=(const T&amp;, const T&amp;)</tt>' rather than using <tt>rel_ops</tt>.
<p/>
One straightforward fix would be to add a homogeneous overload for each heterogeneous comparison:
</p>
<blockquote>
<pre>
template&lt;class... TTypes&gt;
constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;TTypes...&gt;&amp;);
</pre>
<p>
This is then unambiguously chosen over the other options in the preceding case. FWIW, libstdc++ already does this 
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.4/libstdc++/api/a01065_source.html#l00788">in some cases</a>.
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2475" href="#2475">2475.</a> Allow overwriting of <tt>std::basic_string</tt> terminator with <tt>charT()</tt> to allow 
cleaner interoperation with legacy APIs</h3>
<p><b>Section:</b> 21.3.1.5 [string.access] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Matt Weber <b>Opened:</b> 2015-02-21 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.access">issues</a> in [string.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is often desirable to use a <tt>std::basic_string</tt> object as a buffer when interoperating with libraries 
that mutate null-terminated arrays of characters. In many cases, these legacy APIs write a null terminator at 
the specified end of the provided buffer. Providing such a function with an appropriately-sized 
<tt>std::basic_string</tt> results in undefined behavior when the <tt>charT</tt> object at the <tt>size()</tt> 
position is overwritten, even if the value remains unchanged.
<p/>
Absent the ability to allow for this, applications are forced into pessimizations such as: providing 
appropriately-sized <tt>std::vectors</tt> of <tt>charT</tt> for interoperating with the legacy API, and then 
copying the <tt>std::vector</tt> to a <tt>std::basic_string</tt>; providing an oversized <tt>std::basic_string</tt> 
object and then calling <tt>resize()</tt> later.
<p/>
A trivial example:
</p>
<blockquote>
<pre>
#include &lt;string&gt;
#include &lt;vector&gt;

void legacy_function(char *out, size_t count) {
  for (size_t i = 0; i &lt; count; ++i) {
    *out++ = '0' + (i % 10);
  }
  *out = '\0'; // <span style="color:#C80000;font-weight:bold">if size() == count, this results in undefined behavior</span>
}

int main() {
  std::string s(10, '\0');
  legacy_function(&amp;s[0], s.size()); // <span style="color:#C80000;font-weight:bold">undefined behavior</span>

  std::vector&lt;char&gt; buffer(11);
  legacy_function(&amp;buffer[0], buffer.size() - 1);
  std::string t(&amp;buffer[0], buffer.size() - 1); // potentially expensive copy

  std::string u(11, '\0');
  legacy_function(&amp;u[0], u.size() - 1);
  u.resize(u.size() - 1); // needlessly complicates the program's logic
}
</pre>
</blockquote>
<p>
A slight relaxation of the requirement on the returned object from the element access operator would 
allow for this interaction with no semantic change to existing programs.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: This should also apply to non-const <tt>data()</tt>. Billy to update wording.</p>
<p>Fri PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4296.</p>

<ol>
<li>
<p>Edit 21.3.1.5 [string.access] as indicated:</p>
<blockquote>
<pre>
const_reference operator[](size_type pos) const;
reference operator[](size_type pos);
</pre>
<blockquote>
<p>
-1- <i>Requires</i>: [&hellip;]
<p/>
-2- <i>Returns</i>: <tt>*(begin() + pos)</tt> if <tt>pos &lt; size()</tt>. Otherwise, returns a reference to an object of type
<tt>charT</tt> with value <tt>charT()</tt>, where modifying the object <ins>to any value other than <tt>charT()</tt></ins> 
leads to undefined behavior.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2478" href="#2478">2478.</a> Unclear how <tt>wstring_convert</tt> uses <tt>cvtstate</tt></h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
How do <tt>wstring_convert::from_bytes</tt> and <tt>wstring_convert::to_bytes</tt> use
the <tt>cvtstate</tt> member?
<p/>
Is it passed to the <tt>codecvt</tt> member functions? Is a copy of it passed
to the member functions? "Otherwise it shall be left unchanged"
implies a copy is used, but if that's really what's intended there are
simpler ways to say so.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2479" href="#2479">2479.</a> Unclear how <tt>wbuffer_convert</tt> uses <tt>cvtstate</tt></h3>
<p><b>Section:</b> 22.3.3.2.3 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.buffer">active issues</a> in [conversions.buffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.buffer">issues</a> in [conversions.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
How does <tt>wbuffer_convert</tt> use the <tt>cvtstate</tt> member?
<p/>
Is the same conversion state object used for converting both the get
and put areas? That means a read which runs out of bytes halfway 
through a multibyte character will leave some shift state in cvtstate, 
which would then be used by a following write, even though the shift 
state of the get area is unrelated to the put area.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2480" href="#2480">2480.</a> Error handling of <tt>wbuffer_convert</tt> unclear</h3>
<p><b>Section:</b> 22.3.3.2.3 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.buffer">active issues</a> in [conversions.buffer].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.buffer">issues</a> in [conversions.buffer].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If a <tt>codecvt</tt> conversion returns <tt>codecvt_base::error</tt> should that be
treated as <tt>EOF</tt>? An exception? Should all the successfully converted
characters before a conversion error be available to the users of the
<tt>wbuffer_convert</tt> and/or the internal <tt>streambuf</tt>, or does a conversion
error lose information?
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2481" href="#2481">2481.</a> <tt>wstring_convert</tt> should be more precise regarding "byte-error string" etc.</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-03-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 4 of 22.3.3.2.2 [conversions.string] introduces <tt>byte_err_string</tt> 
as "a byte string to display on errors". What does display mean? The string is returned 
on error, it's not displayed anywhere.
<p/>
Paragraph 14 says "Otherwise, if the object was constructed with a
byte-error string, the member function shall return the byte-error
string." The term byte-error string is not used anywhere else.
<p/>
Paragraph 17 talks about storing "default values in <tt>byte_err_string</tt>".
What default value? Is "Hello, world!" allowed? If it means
default-construction it should say so. If paragraph 14 says it won't
be used what does it matter how it's initialized? The end of the
paragraph refers to storing "<tt>byte_err</tt> in <tt>byte_err_string</tt>". This should
be more clearly related to the wording in paragraph 14.
<p/>
It might help if the constructor (and destructor) was specified before
the other member functions, so it can more formally define the
difference between being "constructed with a byte-error string" and
not.
<p/>
All the same issues apply to the <tt>wide_err_string</tt> member.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2490" href="#2490">2490.</a> <tt>&lt;regex&gt;</tt> needs lots of <tt>noexcept</tt></h3>
<p><b>Section:</b> 28 [re] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2015-03-27 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re">active issues</a> in [re].</p>
<p><b>View all other</b> <a href="lwg-index.html#re">issues</a> in [re].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Only 4 functions are marked <tt>noexcept</tt> in all of Clause 28. Many more need to be marked &mdash; for example, 
<tt>regex_error::code()</tt>, <tt>basic_regex::swap()</tt>, and <tt>sub_match::length()</tt>.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2491" href="#2491">2491.</a> <tt>std::less&lt;T*&gt;</tt> in constant expression</h3>
<p><b>Section:</b> 20.14.6 [comparisons] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-04-01 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is not entirely clear if and when the specializations of <tt>std::less</tt> (and friends) for pointer types 
can be used in a constant expression. Consider the following code:
</p>
<blockquote><pre>
#include &lt;functional&gt;

struct foo {};
foo x, y;
constexpr bool b = std::less&lt;foo*&gt;{}(&amp;x, &amp;y); // [1]

foo z[] = {{}, {}};
constexpr bool ba = std::less&lt;foo*&gt;{}(&amp;z[0], &amp;z[1]); // [2]
</pre></blockquote>
<p>
Comparing the address of unrelated objects is not a constant expression since the result is unspecified, so 
it could be expected for [1] to fail and [2] to succeed. However, <tt>std::less</tt> specialization for pointer 
types is well-defined and yields a total order, so it could just as well be expected for [1] to succeed. Finally, 
since the implementation of such specializations is not mandated, [2] could fail as well (This could happen, if
an implementation would provide such a specialization and if that would use built-in functions that would not be
allowed in constant expressions, for example). In any case, the standard should be clear so as to avoid 
implementation-defined <tt>constexpr</tt>-ness.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2493" href="#2493">2493.</a> <tt>initializer_list</tt> supports incomplete classes</h3>
<p><b>Section:</b> 18.9 [support.initlist] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-04-27 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#support.initlist">active issues</a> in [support.initlist].</p>
<p><b>View all other</b> <a href="lwg-index.html#support.initlist">issues</a> in [support.initlist].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The typical use-case of <tt>std::initializer_list&lt;T&gt;</tt> is for a pass-by-value parameter of <tt>T</tt>'s constructor. 
However, this contravenes 17.6.4.8 [res.on.functions]/2.5 because <tt>initializer_list</tt> doesn't specifically allow 
incomplete types (as do for example <tt>std::unique_ptr</tt> (20.11.1 [unique.ptr]/5) and 
<tt>std::enable_shared_from_this</tt> (20.11.2.5 [util.smartptr.enab]/2)).
<p/>
A resolution would be to copy-paste the relevant text from such a paragraph.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2496" href="#2496">2496.</a> Certain hard-to-avoid errors not in the immediate context are not allowed to be triggered by 
the evaluation of type traits</h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-07 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I do not believe that the wording in 20.15.4.3 [meta.unary.prop] paragraph 3 allows for the following program to be ill-formed:
</p>
<blockquote>
<pre>
#include &lt;type_traits&gt;

template &lt;typename T&gt; struct B : T { };
template &lt;typename T&gt; struct A { A&amp; operator=(const B&lt;T&gt;&amp;); };

std::is_assignable&lt;A&lt;int&gt;, int&gt; q;
</pre>
</blockquote>
<p>
In particular, I do not see where the wording allows for the "compilation of the expression" 
<tt>declval&lt;T&gt;() = declval&lt;U&gt;()</tt> to occur as a consequence of instantiating <tt>std::is_assignable&lt;T, U&gt;</tt> 
(where <tt>T</tt> and <tt>U</tt> are, respectively, <tt>A&lt;int&gt;</tt> and <tt>int</tt> in the example code).
<p/>
Instantiating <tt>A&lt;int&gt;</tt> as a result of requiring it to be a complete type does not trigger the instantiation of 
<tt>B&lt;int&gt;</tt>; however, the "compilation of the expression" in question does.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2497" href="#2497">2497.</a> Use of <tt>uncaught_exception()</tt></h3>
<p><b>Section:</b> 27.7.3.4 [ostream::sentry] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Roger Orr <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream::sentry">issues</a> in [ostream::sentry].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the current 27.7.3.4 [ostream::sentry], p4 refers to the now deprecated <tt>std::uncaught_exception()</tt>: 
D.9 [depr.uncaught].
</p>
<blockquote>
<p>
If <tt>((os.flags() &amp; ios_base::unitbuf) &amp;&amp; !uncaught_exception() &amp;&amp; os.good())</tt> is true, calls
<tt>os.rdbuf()->pubsync()</tt>.
</p>
</blockquote>
<p>
This needs to be changed, for example to use <tt>std::uncaught_exceptions()</tt> and to capture the value on entry and 
compare with the saved value on exit.
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>
JW: I already added an 's' here to make it use the new function, but that doesn't resolve Roger's suggestion to capture the value on entry and check it.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2498" href="#2498">2498.</a> <tt>operator&gt;&gt;(basic_istream&amp;&amp;, T&amp;&amp;)</tt> returns <tt>basic_istream&amp;</tt>, but should probably return 
<tt>basic_istream&amp;&amp;</tt></h3>
<p><b>Section:</b> 27.7.2.6 [istream.rvalue] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.rvalue">issues</a> in [istream.rvalue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote>
<pre>
auto&amp; is = make_istream() &gt;&gt; x; // oops, istream object is already gone
</pre>
</blockquote>
<p>
With a <tt>basic_istream&amp;&amp;</tt> return type, the above would be ill-formed, and generally we'd 
preserve the value category properly.
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>
JW: think this needs proper consideration, it would make <pre>stream() &gt;&gt; x &gt;&gt; y &gt;&gt; z</pre> go from 3 operator&gt;&gt; calls to 6 operator&gt;&gt; calls, and wouldn't prevent dangling references (change the example to auto&amp;&amp;) <br/>
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2499" href="#2499">2499.</a> <tt>operator&gt;&gt;(basic_istream&amp;, CharT*)</tt> makes it hard to avoid buffer overflows</h3>
<p><b>Section:</b> 27.7.2.2.3 [istream::extractors] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-05-08 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#istream::extractors">issues</a> in [istream::extractors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We removed <tt>gets()</tt> (due to an NB comment and C11 &mdash; bastion of backwards compatibility &mdash; doing the same). 
Should we remove this too?
<p/>
Unlike <tt>gets()</tt>, there are legitimate uses:
</p>
<blockquote>
<pre>
char buffer[32];
char text[32] = // ...
ostream_for_buffer(text) &gt;&gt; buffer; // ok, can't overrun buffer
</pre>
</blockquote>
<p>
&hellip; but the risk from constructs like "<tt>std::cin &gt;&gt; buffer</tt>" seems to outweigh the benefit.
<p/>
The issue had been discussed on the library reflector starting around 
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=35541">c++std-lib-35541</a>.
</p>

<p><i>[2015-06, Telecom]</i></p>

<p>VV: Request a paper to deprecate / remove anything<br/></p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>STL: This overload is evil and should probably die. </p>
<p>VV: I agree with that, even though I don't care.</p>
<p>STL: Say that we either remove it outright following the gets() rationale, or at least deprecate it.</p>
<p>Move to Open; needs a paper.</p>

<p><i>[2016-08, Chicago: Zhihao Yuan comments and provides wording]</i></p>

<p>
Rationale:
</p>
<ol>
<li><p>I would like to keep some reasonable code working;</p></li>
<li><p>Reasonable code includes two cases:</p>
<ol style="list-style-type:lower-alpha">
<li><p><tt>width() &gt; 0</tt>, any pointer argument</p></li>
<li><p><tt>width() &gt;= 0</tt>, array argument</p></li>
</ol>
</li>
<li><p>For a), banning bad code will become a silent behavior change at runtime; 
for b), it breaks at compile time.</p></li>
</ol>
<p>
I propose to replace these signatures with references to arrays.
An implementation may want to ship the old instantiatations in the
binary without exposing the old signatures.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Tues PM: General agreement on deprecating the unsafe call, but no consensus for the P/R.</p>
<p>General feeling that implementation experience would be useful.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 27.7.2.2.3 [istream::extractors] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;charT, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; in,
                                           <del>charT* s</del><ins>charT (&amp;s)[N]</ins>);
template&lt;class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;char, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char, traits&gt;&amp; in,
                                          <del>unsigned char* s</del><ins>unsigned char (&amp;s)[N]</ins>);
template&lt;class traits<ins>, size_t N</ins>&gt;
  basic_istream&lt;char, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;char, traits&gt;&amp; in,
                                          <del>signed char* s</del><ins>signed char (&amp;s)[N]</ins>);
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> Behaves like a formatted input member (as described in 27.7.2.2.1 [istream.formatted.reqmts]) 
of <tt>in</tt>. After a <tt>sentry</tt> object is constructed, <tt>operator&gt;&gt;</tt> extracts characters and 
stores them into <del>successive locations of an array whose first element is designated by</del> <tt>s</tt>. If <tt>width()</tt> 
is greater than zero, <tt>n</tt> is <tt><del>width()</del><ins>min(size_t(width()), N)</ins></tt>. Otherwise 
<tt>n</tt> is <del>the number of elements of the largest 
array of <tt>char_type</tt> that can store a terminating <tt>charT()</tt></del><ins><tt>N</tt></ins>. <tt>n</tt> is the 
maximum number of characters stored.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2501" href="#2501">2501.</a> <tt>std::function</tt> requires POCMA/POCCA</h3>
<p><b>Section:</b> 20.14.12.2 [func.wrap.func] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-05-20 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The idea behind <tt>propagate_on_container_move_assignment</tt> is that you can keep an allocator attached to a container. 
But it's not really designed to work with polymorphism, which introduces the condition where the current allocator is non-POCMA 
and the RHS of assignment, being POCMA, wants to replace it. If function were to respect the literal meaning, any would-be 
attached allocator is at the mercy of every assignment operation. So, <tt>std::function</tt> is inherently POCMA, and passing 
a non-POCMA allocator should be ill-formed.
<p/>
The other alternative, and the status quo, is to ignore POCMA and assume it is true. This seems just dangerous enough to outlaw. 
It is, in theory, possible to properly support POCMA as far as I can see, albeit with difficulty and brittle results. It would 
require function to keep a throwing move constructor, which otherwise can be <tt>noexcept</tt>.
<p/>
The same applies to <tt>propagate_on_container_copy_assignment</tt>. This presents more difficulty because <tt>std::allocator</tt> 
does not set this to true. Perhaps it should. For function to respect this would require inspecting the POCCA of the source allocator, 
slicing the target from the erasure of the source, slicing the allocation from the erasure of the destination, and performing a 
copy with the destination's allocator with the source's target. This comes out of the blue for the destination allocator, which 
might not support the new type anyway. Theoretically possible, but brittle and not very practical. Again, current implementations 
quietly ignore the issue but this isn't very clean.
<p/>
The following code example is intended to demonstrate the issue here:
</p>
<blockquote><pre>
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
struct diag_alloc 
{
  std::string name;

  T* allocate(std::size_t n) const 
  {
    std::cout &lt;&lt; '+' &lt;&lt; name &lt;&lt; '\n';
    return static_cast&lt;T*&gt;(::operator new(n * sizeof(T)));
  }
  
  void deallocate(T* p, std::size_t) const 
  {
    std::cout &lt;&lt; '-' &lt;&lt; name &lt;&lt; '\n';
    return ::operator delete(p);
  }

  template &lt;typename U&gt;
  operator diag_alloc&lt;U&gt;() const { return {name}; }

  friend bool operator==(const diag_alloc&amp; a, const diag_alloc&amp; b)
  { return a.name == b.name; }
  
  friend bool operator!=(const diag_alloc&amp; a, const diag_alloc&amp; b)
  { return a.name != b.name; }

  typedef T value_type;
  
  template &lt;typename U&gt;
  struct rebind { typedef diag_alloc&lt;U&gt; other; };
};

int main() {
  std::cout &lt;&lt; "VECTOR\n";
  std::vector&lt;int, diag_alloc&lt;int&gt;&gt; foo({1, 2}, {"foo"}); // +foo
  std::vector&lt;int, diag_alloc&lt;int&gt;&gt; bar({3, 4}, {"bar"}); // +bar

  std::cout &lt;&lt; "move\n";
  foo = std::move(bar); // no message

  std::cout &lt;&lt; "more foo\n";
  foo.reserve(40); // +foo -foo
  std::cout &lt;&lt; "more bar\n";
  bar.reserve(40); // +bar -bar

  std::cout &lt;&lt; "\nFUNCTION\n";
  int bigdata[100];
  auto bigfun = [bigdata]{};
  typedef decltype(bigfun) ft;
  std::cout &lt;&lt; "make fizz\n";
  std::function&lt;void()&gt; fizz(std::allocator_arg, diag_alloc&lt;ft&gt;{"fizz"}, bigfun); // +fizz
  std::cout &lt;&lt; "another fizz\n";
  std::function&lt;void()&gt; fizz2;
  fizz2 = fizz; // +fizz as if POCCA
  std::cout &lt;&lt; "make buzz\n";
  std::function&lt;void()&gt; buzz(std::allocator_arg, diag_alloc&lt;ft&gt;{"buzz"}, bigfun); // +buzz
  std::cout &lt;&lt; "move\n";
  buzz = std::move(fizz); // -buzz as if POCMA

  std::cout &lt;&lt; "\nCLEANUP\n";
}
</pre></blockquote>

<p><i>[2016-08, Chicago]</i></p>

<p>Tues PM: Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a>.
</p>





<hr>
<h3><a name="2502" href="#2502">2502.</a> <tt>std::function</tt> does not use <tt>allocator::construct</tt></h3>
<p><b>Section:</b> 20.14.12.2 [func.wrap.func] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-05-20 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#func.wrap.func">active issues</a> in [func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func">issues</a> in [func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is impossible for <tt>std::function</tt> to construct its target object using the <tt>construct</tt> method of a type-erased 
allocator. More confusingly, it is possible when the allocator and the target are created at the same time. The means 
of target construction should be specified.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a>.</p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by <a href="http://wg21.link/p0302r1">P0302R1</a>.
</p>






<hr>
<h3><a name="2503" href="#2503">2503.</a> multiline option should be added to <tt>syntax_option_type</tt></h3>
<p><b>Section:</b> 28.5.1 [re.synopt] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nozomu Kat&#x14d; <b>Opened:</b> 2015-05-22 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.synopt">active issues</a> in [re.synopt].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.synopt">issues</a> in [re.synopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of ECMAScript defines the Multiline property for its
RegExp and the regular expressions ^ and $ behave differently according
to the value of this property. Thus, this property should be available
also in the ECMAScript compatible engine in <tt>std::regex</tt>.
</p>

<p><i>[2015-05-22, Daniel comments]</i></p>

<p>
This issue interacts somewhat with LWG <a href="lwg-active.html#2343">2343</a>.
</p>

<p><i>[Telecom 2015-07]</i></p>

<p>
Set the priority to match LWG <a href="lwg-active.html#2343">2343</a>.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Moved to Tentatively Ready. This also resolves <a href="lwg-active.html#2343">2343</a></p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4431.</p>

<ol>
<li><p>Change 28.5.1 [re.synopt] as indicated:</p>

<blockquote><pre>
namespace std::regex_constants {
  typedef T1 syntax_option_type;
  constexpr syntax_option_type icase = <i>unspecified</i> ;
  constexpr syntax_option_type nosubs = <i>unspecified</i> ;
  constexpr syntax_option_type optimize = <i>unspecified</i> ;
  constexpr syntax_option_type collate = <i>unspecified</i> ;
  constexpr syntax_option_type ECMAScript = <i>unspecified</i> ;
  constexpr syntax_option_type basic = <i>unspecified</i> ;
  constexpr syntax_option_type extended = <i>unspecified</i> ;
  constexpr syntax_option_type awk = <i>unspecified</i> ;
  constexpr syntax_option_type grep = <i>unspecified</i> ;
  constexpr syntax_option_type egrep = <i>unspecified</i> ;
  <ins>constexpr syntax_option_type multiline = <i>unspecified</i> ;</ins>
}
</pre></blockquote>
</li>

<li><p>Change 28.5.2 [re.matchflag], Table 138 &mdash; "<tt>syntax_option_type</tt> effects" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 138 &mdash; <tt>syntax_option_type</tt> effects</caption>
<tr>
<th align="center">Element</th>
<th align="center">Effect(s) if set</th>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<ins><tt>multiline</tt></ins>
</td>
<td>
<ins>Specifies that <tt>^</tt> shall match the beginning of a line
and <tt>$</tt> shall match the end of a line, if the ECMAScript engine is
selected.</ins>
</td>
</tr>

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2504" href="#2504">2504.</a> <tt>basic_streambuf</tt> is not an abstract class</h3>
<p><b>Section:</b> 27.6.3 [streambuf] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-05-28 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#streambuf">active issues</a> in [streambuf].</p>
<p><b>View all other</b> <a href="lwg-index.html#streambuf">issues</a> in [streambuf].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.6.3 [streambuf] p1 says:
</p>
<blockquote><p>
The class template <tt>basic_streambuf&lt;charT, traits&gt;</tt> serves as an abstract base class for deriving various
stream buffers whose objects each control two character sequences: [&hellip;]
</p></blockquote>
<p>
The term "abstract base class" is not defined in the standard, but "abstract class" is (10.4 [class.abstract]).
<p/>
According to the synopsis <tt>basic_streambuf</tt> has no pure virtual
functions so is not an abstract class and none of libstdc++, libc++, or
dinkumware implement it as an abstract class. I don't believe the wording was
ever intended to require it to be an abstract class, but it could be
read that way.
<p/>
I suggest the wording be changed to "polymorphic base class" or
something else that can't be seen to imply a normative requirement to
make it an abstract class.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2505" href="#2505">2505.</a> <tt>auto_ptr_ref</tt> creation requirements underspecified</h3>
<p><b>Section:</b> 99 [auto.ptr.conv] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-28 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#auto.ptr.conv">issues</a> in [auto.ptr.conv].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++14 sub-clause 99 [auto.ptr.conv], there appears to be no requirement that the formation of an 
<tt>auto_ptr_ref&lt;Y&gt;</tt> from an <tt>auto_ptr&lt;X&gt;</tt> is done only when <tt>X*</tt> can be implicitly 
converted to <tt>Y*</tt>.
<p/>
For example, I expect formation of the <tt>auto_ptr_ref&lt;A&gt;</tt> from the prvalue of type <tt>auto_ptr&lt;B&gt;</tt> 
to be invalid in the case below (but the wording does not seem to be there):
</p>
<blockquote><pre>
#include &lt;memory&gt;

struct A { };
struct B { } b;

std::auto_ptr&lt;B&gt; apB() { return std::auto_ptr&lt;B&gt;(&amp;b); }
int main() {
  std::auto_ptr&lt;A&gt; apA(apB());
  apA.release();
}
</pre></blockquote>
<p>
The behaviour of the implementation in question on the case presented above is to compile and execute it successfully 
(which is what the C++14 wording implies). The returned value from <tt>apA.release()</tt> is essentially 
<tt>reinterpret_cast&lt;A*&gt;(&amp;b)</tt>.
<p/>
There is nothing in the specification of
</p>
<blockquote><pre>
template &lt;class X&gt;
template &lt;class Y&gt; operator auto_ptr&lt;X&gt;::auto_ptr_ref&lt;Y&gt;() throw();
</pre></blockquote>
<p>
which implies that <tt>X*</tt> should be implicitly convertible to <tt>Y*</tt>.
<p/>
The implementation in question uses the <tt>reinterpret_cast</tt> interpretation even when <tt>Y</tt> is an accessible, 
unambiguous base class of <tt>X</tt>; the result thereof is that no offset adjustment is performed.
</p>

<p><i>[2015-07, Telecon]</i></p>

<p>
Marshall to resolve.
</p>

<p><i>[2016-03-16, Alisdair Meredith comments]</i></p>

<p>
This issue is a defect in a component we have actively removed
from the standard. I can't think of a clearer example of something
that is no longer a defect!
</p>

<p><i>[2016-08-03, Alisdair Meredith comments]</i></p>

<p>
As C++17 removes <tt>auto_ptr</tt>, I suggest closing this issue as closed by paper 
<a href="http://wg21.link/n4190">N4190</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to ISO/IEC 14882:2014(E).
</p>

<ol>
<li><p>Change 99 [auto.ptr.conv] as indicated:</p>

<blockquote>
<pre>
template&lt;class Y&gt; operator auto_ptr_ref&lt;Y&gt;() throw();
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>X*</tt> can be implicitly converted to <tt>Y*</tt>.</ins>
<p/>
-3- <i>Returns</i>: An <tt>auto_ptr_ref&lt;Y&gt;</tt> that holds <tt>*this</tt>.
<p/>
<ins>-?- <i>Notes</i>: Because <tt>auto_ptr_ref</tt> is present for exposition only, the only way to invoke this function 
is by calling one of the <tt>auto_ptr</tt> conversions which take an <tt>auto_ptr_ref</tt> as an argument. Since all 
such conversions will call <tt>release()</tt> on <tt>*this</tt> (in the form of the <tt>auto_ptr</tt> that the 
<tt>auto_ptr_ref</tt> holds a reference to), an implementation of this function may cause instantiation of said 
<tt>release()</tt> function without changing the semantics of the program.</ins>
</p>
</blockquote>
<pre>
template&lt;class Y&gt; operator auto_ptr&lt;Y&gt;() throw();
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>X*</tt> can be implicitly converted to <tt>Y*</tt>.</ins>
<p/>
-4- <i>Effects</i>: Calls <tt>release()</tt>.
<p/>
-5- <i>Returns</i>: An <tt>auto_ptr&lt;Y&gt;</tt> that holds the pointer returned from <tt>release()</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by acceptance of <a href="http://wg21.link/n4190">N4190</a>.
</p>





<hr>
<h3><a name="2506" href="#2506">2506.</a> Underspecification of atomics</h3>
<p><b>Section:</b> 1.10 [intro.multithread], 29.5 [atomics.types.generic], 18.10 [support.runtime] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Geoffrey Romer <b>Opened:</b> 2015-05-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#intro.multithread">issues</a> in [intro.multithread].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The concurrency libraries specified in clauses 29 and 30 do not adequately specify how they relate to the concurrency model 
specified in 1.10 [intro.multithread]. In particular:
<p/>
1.10 [intro.multithread] specifies "atomic objects" as having certain properties. I can only assume that instances 
of the classes defined in Clause 29 are intended to be "atomic objects" in this sense, but I can't find any wording to 
specify that, and it's genuinely unclear whether Clause 30 objects are atomic objects. In fact, on a literal reading the 
C++ Standard doesn't appear to provide <em>any</em> portable way to create an atomic object, or even determine whether an 
object is an atomic object.
<p/>
(It's not clear if the term "atomic object" is actually needed, given that atomic objects can have non-atomic operations, 
and non-atomic objects can have atomic operations. But even if the term itself goes away, there still needs to be some 
indication that Clause 29 objects have the properties currently attributed to atomic objects).
<p/>
Similarly, 1.10 [intro.multithread] uses "atomic operation" as a term of art, but the standard never unambiguously 
identifies any operation as an "atomic operation" (although in one case it unambiguously identifies an operation that is 
<em>not</em> atomic). It does come close in a few cases, but not close enough:
</p>
<ul>
<li><p>1.10 [intro.multithread]/p7 could be read to imply that "synchronization operations" in Clauses 29 and 30 
are also atomic operations. However, that's vague and indirect, and somewhat belied by 30.4.1.2 [thread.mutex.requirements.mutex]/p5, 
which specifies that mutex lock and unlock operations "behave as atomic operations", but only "for purposes of determining 
the existence of a data race". Furthermore, not a single operation in Clause 29 explicitly identifies itself as a 
"synchronization operation".</p></li>
<li><p>29.5 [atomics.types.generic]/p4 states in part that "There shall be a specialization <tt>atomic&lt;bool&gt;</tt> 
which provides the general atomic operations as specified in 29.6.1", but read in context, "general atomic operations" 
appears to be a loose synonym for "general operations on atomic types" as defined in 29.6.1 [atomics.types.operations.general], 
rather than a use of "atomic object" as Words of Power. Incidentally, "atomic type" is never satisfactorily defined either 
(although the <tt>&lt;atomic&gt;</tt> synopsis comes close).</p></li>
<li><p>18.10 [support.runtime]/p10 specifies exactly which operations are "plain lock-free atomic operations", but 
in a standard where an "integral constant expression" isn't necessarily a "constant expression", I do not feel safe assuming 
that a "plain lock-free atomic operation" is an "atomic operation".</p></li>
<li><p>Hans Boehm tells me the operations with "atomically" in the Effects element are intended to be atomic operations, 
but since "atomic operation" is a term of art (e.g. in 1.10 [intro.multithread]/p27.4), I think this needs to be 
spelled out rather than assumed. Furthermore, this does not help with 29.8 [atomics.fences], or anything in Clause 30.</p></li>
</ul>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2507" href="#2507">2507.</a> <tt>codecvt_mode</tt> should be a bitmask type</h3>
<p><b>Section:</b> 22.5 [locale.stdcvt] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-06-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.stdcvt">issues</a> in [locale.stdcvt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The enumeration type <tt>codecvt_mode</tt> is effectively a bitmask type
(17.5.2.1.3 [bitmask.types]) with three elements, but isn't defined as
such.
<p/>
This harms usability because bitmask types are required to work well
with bitwise operators, but <tt>codecvt_mode</tt> doesn't have overloaded
operators, making it very inconvenient to combine values:
</p>
<blockquote><pre>
std::codecvt_utf16&lt;char32_t, 0x10FFFF,
  static_cast&lt;std::codecvt_mode&gt;(std::little_endian|std::generate_header)&gt;
cvt;
</pre></blockquote>
<p>
The <tt>static_cast</tt> harms readability and should not be necessary.
<p/>
I suggest that either <tt>codecvt_mode</tt> is specified to be a bitmask type,
or as a minimal fix we provide an overloaded <tt>operator|</tt> that returns
the right type.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2508" href="#2508">2508.</a> &sect;[new.delete.dataraces] wording needs to be updated</h3>
<p><b>Section:</b> 18.6.2.4 [new.delete.dataraces] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2015-06-09 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.dataraces">issues</a> in [new.delete.dataraces].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
18.6.2.4 [new.delete.dataraces] uses obsolete wording.
<p/>
It should introduce a "synchronizes with" relationship. "Happens before" is too weak, since that may not composes 
with sequenced before.
<p/>
The "shall not introduce a data race" wording is probably not technically correct either. These may race with other 
(non-allocation/deallocation) concurrent accesses to the object being allocated or deallocated.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2510" href="#2510">2510.</a> Tag types should not be <tt>DefaultConstructible</tt></h3>
<p><b>Section:</b> 18.6 [support.dynamic], 20.2 [utility], 20.4.5 [pair.piecewise], 20.10.2 [memory.syn], 20.10.6 [allocator.tag], 30.4 [thread.mutex] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-06-13 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#support.dynamic">issues</a> in [support.dynamic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::experimental::optional</tt>, for certain reasons, specifies its <tt>nullopt</tt> type
to not be <tt>DefaultConstructible</tt>. It doesn't do so for its tag type <tt>in_place_t</tt>
and neither does the standard proper for any of its tag types. That turns
out to be very unfortunate, consider the following:
</p>
<blockquote><pre>
#include &lt;memory&gt;
#include &lt;array&gt;

void f(std::array&lt;int, 1&gt;, int) {} // #1
void f(std::allocator_arg_t, int) {} // #2

int main()
{
  f({}, 666); // #3
}
</pre></blockquote>
<p>
The call at #3 is ambiguous. What's even worse is that if the overload #1
is removed, the call works just fine. The whole point of a tag type is that
it either needs to mentioned in a call or it needs to be a forwarded argument,
so being able to construct a tag type like that makes no sense.
<p/>
Making the types have an <em>explicit default constructor</em> might have helped, but 
<a href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#1518">CWG 1518</a>
is going against that idea.
<p/>
[optional.nullopt]/3 solves this problem for <tt>nullopt</tt>:
</p>
<blockquote>
<p>
Type <tt>nullopt_t</tt> shall not have a default constructor. It shall be a
literal type. Constant <tt>nullopt</tt> shall be initialized with an argument
of literal type.
</p>
</blockquote>

<p><i>[2015-06, Telecom]</i></p>

<p>
Move to Tentatively Ready.
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>Move back to Open</p>
<p>JW: The linked Core issue (CWG 1518) gives us a better tool to solve this (explicit default constructors). [The CWG Issue means that an explicit default constructor will no longer match "{}".] JW explains that it's important that tag types cannot be constructed from "{}" (e.g. the allocator tag in the tuple constructors).</p>
<p>WEB: Should we now go back and update our constructors? JW: For tag types, yes.</p>
<p>VV: The guideline is that anything that does not mention the type name explicitly should not invoke an explicit constructor.</p>
<p>Ville will provide wording.</p>
<p>Discussion about pair/tuple's default constructor - should they now be explicit?</p>

<p><i>[2016-01-31]</i></p>

<p>
Ville provides revised wording.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>In 18.6 [support.dynamic]/1, change the header <tt>&lt;new&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct nothrow_t <del>{}</del>; <ins><i>see below</i></ins>
extern const nothrow_t nothrow;
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 18.6 [support.dynamic]/1 (<em>following</em> the header <tt>&lt;new&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>nothrow_t</tt> shall not have a default constructor.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.2 [utility]/2, change the header <tt>&lt;utility&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.3.5, pair piecewise construction</i>
struct piecewise_construct_t <del>{ }</del>; <ins><i>see below</i></ins>
constexpr piecewise_construct_t piecewise_construct{ <ins><i>unspecified</i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 20.2 [utility]/2 (<em>following</em> the header <tt>&lt;utility&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>piecewise_construct_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>piecewise_construct</tt> shall be initialized with an argument of literal type.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.4.5 [pair.piecewise], apply the following edits:</p>

<blockquote><pre>
struct piecewise_construct_t <del>{ }</del>;
constexpr piecewise_construct_t piecewise_construct{ <ins><i>unspecified</i></ins> };
</pre></blockquote>
</li>
<li><p>In 20.10.2 [memory.syn]/1, change the header <tt>&lt;memory&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.7.6, allocator argument tag</i>
struct allocator_arg_t <del>{ }</del>; <ins><i>see below</i></ins>
constexpr allocator_arg_t allocator_arg{ <ins><i>unspecified</i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add a new paragraph after 20.10.2 [memory.syn]/1 (<em>following</em> the header <tt>&lt;memory&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>allocator_arg_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>allocator_arg</tt> shall be initialized with an
argument of literal type.</ins>
</p>
</blockquote>
</li>
<li><p>In 20.10.6 [allocator.tag], apply the following edits:</p>

<blockquote><pre>
namespace std {
  struct allocator_arg_t <del>{ }</del>;
  constexpr allocator_arg_t allocator_arg{ <ins><i>unspecified</i></ins> };
}
</pre></blockquote>
<blockquote class="note">
<p>
Editorial drive-by: <tt>piecewise_construct_t</tt> is written, in 20.4.5 [pair.piecewise] like
</p>
<blockquote><pre>
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
<p>
whereas other tag types such as <tt>allocator_construct_t</tt> are, in e.g.
20.10.6 [allocator.tag], written like
</p>
<blockquote><pre>
namespace std {
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<p>
We should decide whether or not to write out the <tt>std</tt> namespace in such
paragraphs. I would suggest not to write it out.
</p>
</blockquote>

</li>
<li><p>In 30.4 [thread.mutex]/1, change the header <tt>&lt;mutex&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct defer_lock_t <del>{ }</del>; <ins><i>see below</i></ins>
struct try_to_lock_t <del>{ }</del>; <ins><i>see below</i></ins>
struct adopt_lock_t <del>{ }</del>; <ins><i>see below</i></ins>

constexpr defer_lock_t defer_lock { <ins><i>unspecified </i></ins> };
constexpr try_to_lock_t try_to_lock { <ins><i>unspecified </i></ins> };
constexpr adopt_lock_t adopt_lock { <ins><i>unspecified </i></ins> };
[&hellip;]
</pre></blockquote>
</li>
<li><p>Add three new paragraphs after [thread.mutex]/1 (<em>following</em> the header <tt>&lt;mutex&gt;</tt> synopsis):</p>

<blockquote>
<p>
<ins>-?- Type <tt>defer_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>defer_lock</tt> shall be initialized with an
argument of literal type.</ins>
<p/>
<ins>-?- Type <tt>try_to_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>try_to_lock</tt> shall be initialized with an
argument of literal type.</ins>
<p/>
<ins>-?- Type <tt>adopt_lock_t</tt> shall not have a default constructor. It shall
be a literal type. Constant <tt>adopt_lock</tt> shall be initialized with an
argument of literal type.</ins>
</p>
</blockquote>

</li>
</ol>
</blockquote>

<p><i>[2016-03 Jacksonville]</i></p>

<p>
AM: should have note about compatibility in Annex C<br/>
HH: like this idiom well enough that I've started using it in my own code<br/>
AM: why are pair and tuple involved here?<br/>
GR: they are the only types which forward explicitness with EXPLICIT<br/>
AM: British spelling of behaviour<br/>
AM: happy to drop my issue about Annex C<br/>
</p>

<p><i>[2016-06 Oulu]</i></p>

<p>This is waiting on Core issue 1518</p>
<p>Saturday: Core 1518 was resolved in Oulu</p>

<p><i>[2016-07 Chicago]</i></p>

<p>This is related to <a href="lwg-active.html#2736">2736</a></p>
<p>Monday PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>In 18.6 [support.dynamic]/1, change the header <tt>&lt;new&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct nothrow_t { <ins>explicit nothrow_t() = default;</ins> };
extern const nothrow_t nothrow;
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.2 [utility]/2, change the header <tt>&lt;utility&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.3.5, pair piecewise construction</i>
struct piecewise_construct_t { <ins>explicit piecewise_construct_t() = default;</ins> };
constexpr piecewise_construct_t piecewise_construct{};
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.4.2 [pairs.pair], change the class template <tt>pair</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
pair(pair&amp;&amp;) = default;
<ins><i>EXPLICIT</i></ins> constexpr pair();
<i>EXPLICIT</i> constexpr pair(const T1&amp; x, const T2&amp; y);
[&hellip;]
</pre></blockquote>
</li>

<li><p>Around 20.4.2 [pairs.pair] p3, apply the following edits:</p>

<blockquote>
<pre>
<ins><i>EXPLICIT</i></ins> constexpr pair();
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: Value-initializes <tt>first</tt> and <tt>second</tt>.
<p/>
-4- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_default_constructible&lt;first_type&gt;::value</tt> is <tt>true</tt> and 
<tt>is_default_constructible&lt;second_type&gt;::value</tt> is <tt>true</tt>. 
[<i>Note</i>: This
behaviour can be implemented by a constructor template with default template arguments. &mdash; 
<i>end note</i>]
<ins>The constructor is explicit if and only if either <tt>first_type</tt> or <tt>second_type</tt> 
is not implicitly default-constructible. 
[<i>Note</i>: This behaviour can be implemented with a trait 
that checks whether a <tt>const first_type&amp;</tt> or a <tt>const second_type&amp;</tt> can be 
initialized with <tt>{}</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 20.4.5 [pair.piecewise], apply the following edits:</p>

<blockquote><pre>
struct piecewise_construct_t { <ins>explicit piecewise_construct_t() = default;</ins> };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
</li>

<li><p>In 20.5.2 [tuple.tuple], change the class template <tt>tuple</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
<i>// 20.4.2.1, tuple construction</i>
<ins><i>EXPLICIT</i></ins> constexpr tuple();
<i>EXPLICIT</i> constexpr tuple(const Types&amp;...); <i>// only if sizeof...(Types) &gt;= 1</i>
[&hellip;]
</pre></blockquote>
</li>

<li><p>Around 20.5.2.1 [tuple.cnstr] p4, apply the following edits:</p>

<blockquote>
<pre>
<ins><i>EXPLICIT</i></ins> constexpr tuple();
</pre>
<blockquote>
<p>
-4- <i>Effects</i>: Value initializes each element.
<p/>
-5- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_default_constructible&lt;<i>T<sub>i</sub></i>&gt;::value</tt> is <tt>true</tt> for all <i>i</i>. 
[<i>Note</i>: This
behaviour can be implemented by a constructor template with default template arguments. &mdash; 
<i>end note</i>]
<ins>The constructor is explicit if and only if <tt><i>T<sub>i</sub></i></tt> 
is not implicitly default-constructible for at least one <i>i</i>.
[<i>Note</i>: This behaviour can be implemented with a trait that checks whether
a <tt>const Ti&amp;</tt> can be initialized with <tt>{}</tt>. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 20.10.2 [memory.syn]/1, change the header <tt>&lt;memory&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
// <i>20.7.6, allocator argument tag</i>
struct allocator_arg_t { <ins>explicit allocator_arg_t() = default;</ins> };
constexpr allocator_arg_t allocator_arg{};
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 20.10.6 [allocator.tag], apply the following edits:</p>

<blockquote><pre>
namespace std {
  struct allocator_arg_t { <ins>explicit allocator_arg_t() = default;</ins> };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<blockquote class="note">
<p>
Editorial drive-by: <tt>piecewise_construct_t</tt> is written, in 20.4.5 [pair.piecewise] like
</p>
<blockquote><pre>
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct{};
</pre></blockquote>
<p>
whereas other tag types such as <tt>allocator_construct_t</tt> are, in e.g.
20.10.6 [allocator.tag], written like
</p>
<blockquote><pre>
namespace std {
  struct allocator_arg_t { };
  constexpr allocator_arg_t allocator_arg{};
}
</pre></blockquote>
<p>
We should decide whether or not to write out the <tt>std</tt> namespace in such
paragraphs. I would suggest not to write it out.
</p>
</blockquote>
</li>

<li><p>In 30.4 [thread.mutex]/1, change the header <tt>&lt;mutex&gt;</tt> synopsis:</p>

<blockquote><pre>
[&hellip;]
struct defer_lock_t { <ins>explicit defer_lock_t() = default;</ins> };
struct try_to_lock_t { <ins>explicit try_to_lock_t() = default;</ins> };
struct adopt_lock_t { <ins>explicit adopt_lock_t() = default;</ins> };

constexpr defer_lock_t defer_lock { };
constexpr try_to_lock_t try_to_lock { };
constexpr adopt_lock_t adopt_lock { };
[&hellip;]
</pre></blockquote>
</li>

</ol>





<hr>
<h3><a name="2511" href="#2511">2511.</a> <tt>scoped_allocator_adaptor</tt> piecewise construction does not require <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 20.13.4 [allocator.adaptor.members] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2015-06-16 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in [allocator.adaptor.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in [allocator.adaptor.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.13.4 [allocator.adaptor.members]/10 requires that the argument types in the piecewise-construction tuples 
all be <tt>CopyConstructible</tt>. These tuples are typically created by <tt>std::forward_as_tuple</tt>, such as in 
&para;13. So they will be a mix of lvalue and rvalue references, the latter of which are not <tt>CopyConstructible</tt>.
<p/>
My guess is that <tt>CopyConstructible</tt> was specified to feed the <tt>tuple_cat</tt>, before that function could 
handle rvalues. Since the argument tuple is already moved in &para;11, the requirement is obsolete. It should either 
be changed to <tt>MoveConstructible</tt>, or perhaps better, convert the whole tuple to references (i.e. form 
<tt>tuple&lt;Args1&amp;&amp;...&gt;</tt>) so nothing needs to be moved. After all, this is a facility for handling non-movable 
types.
<p/>
It appears that the resolution of DR <a href="lwg-defects.html#2203">2203</a>, which added <tt>std::move</tt> to &para;11, simply omitted the 
change to &para;10.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2512" href="#2512">2512.</a> Y2K bites; what is an "unambiguous year identifier"?</h3>
<p><b>Section:</b> 22.4.5.1.2 [locale.time.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.time.get.virtuals">issues</a> in [locale.time.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I recently encountered a failure related to questionable use of <tt>do_get_year</tt>. The platform where the code happened 
to work had an implementation which handled certain three-digit "year identifiers" as the number of years since 
1900 (<a href="http://www.drdobbs.com/cpp/remembering-y2k/228701726">this article</a> describes such an implementation).
<p/>
22.4.5.1.2 [locale.time.get.virtuals] makes it implementation defined whether two-digit years are accepted, etc., but does not 
say anything specifically about three-digit years.
<p/>
The implementation freedom to not report errors in 22.4.5.1 [locale.time.get] paragraph 1 also seems to be too broad.
<p/>
See also the discussion following <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=38042">c++std-lib-38042</a>.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed PM: This has been this way since C++98. Don't think it's a P2.</p>
<p>Change to P4, and move to Open.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2513" href="#2513">2513.</a> Missing requirements for <tt>basic_string::value_type</tt></h3>
<p><b>Section:</b> 21.1 [strings.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-06-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#strings.general">issues</a> in [strings.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The allocator-aware container requirements in Table 98 impose no
<tt>MoveAssignable</tt> requirements on the <tt>value_type</tt> when
<tt>propagate_on_container_move_assignment</tt> is true, because typically the
container's storage would be moved by just exchanging some pointers.
<p/>
However for a <tt>basic_string</tt> using the small string optimization move
assignment may need to assign individual characters into the small
string buffer, even when the allocator propagates.
<p/>
The only requirement on the char-like objects stored in a <tt>basic_string</tt>
are that they are non-array POD types and <tt>Destructible</tt>, which means
that a POD type with a deleted move assignment operator should be
usable in a <tt>basic_string</tt>, despite it being impossible to move assign:
</p>
<blockquote><pre>
#include &lt;string&gt;

struct odd_pod 
{
  odd_pod() = default;
  odd_pod&amp; operator=(odd_pod&amp;&amp;) = delete;
};

static_assert(std::is_pod&lt;odd_pod&gt;::value, "POD");

int main()
{
  using S = std::basic_string&lt;odd_pod&gt;;
  S s;
  s = S{};       // fails
}
</pre></blockquote>
<p>
Using libstdc++ <tt>basic_string&lt;odd_pod&gt;</tt> cannot even be
default-constructed because the constructor attempts to assign the
null terminator to the first element of the small string buffer.
<p/>
Similar problems exist with POD types with a deleted default constructor.
<p/>
I believe that <tt>basic_string</tt> should require its <tt>value_type</tt> to be at
least <tt>DefaultConstructible</tt> and <tt>MoveAssignable</tt>.
</p>

<p><i>[2016-06, Oulu]</i></p>

<p>This should be resolved by <a href="http://wg21.link/P0178">P0178</a></p>
<p>Note: P0178 was sent back to LEWG in Oulu.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2514" href="#2514">2514.</a> Type traits must not be <tt>final</tt></h3>
<p><b>Section:</b> 20.15.1 [meta.rqmts] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-07-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We should make it clear that all standard <tt>UnaryTypeTraits</tt>,
<tt>BinaryTypeTraits</tt> and <tt>TransformationTraits</tt> are not <tt>final</tt>.
<p/>
Otherwise it is not safe to use them as arguments to a template like this:
</p>
<blockquote><pre>
template&lt;typename C1, typename C2&gt;
struct conjunction
  : conditional_t&lt;C1::value, C2, C1&gt;
{ };
</pre></blockquote>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Walter, Nevin, and Jason provide initial Proposed Resolution.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.15.1 [meta.rqmts] as indicated:</p>

<blockquote>
<p>
-1- A <em>UnaryTypeTrait</em> describes a property of a type. It shall be a <ins>non-<code>final</code></ins> 
class template [&hellip;]
<p/>
-2- A <em>BinaryTypeTrait</em> describes a relationship between two types. It shall be a 
<ins>non-<code>final</code></ins> class template [&hellip;]
<p/>
-3- A <em>TransformationTrait</em> modifies a property of a type. It shall be a 
<ins>non-<code>final</code></ins> class template [&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-04 Chicago LWG]</i></p>

<p>
LWG discusses and expresses preference for a more general, Library-wide, resolution. Walter and Nevin 
provide a new Proposed Resolution consistent with such guidance.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Add a new paragraph add the end of 17.6.5.11 [derivation] as indicated:</p>

<blockquote>
<p>
<ins>-?- All types specified in the C++ standard library shall be non-<code>final</code>
types unless otherwise specified.</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2518" href="#2518">2518.</a> [fund.ts.v2] Non-member <tt>swap</tt> for <tt>propagate_const</tt> should call member <tt>swap</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::propagate_const.algorithms] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-07-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
For consistency with the rest of the standard library, the non-member <tt>swap</tt> for <tt>propagate_const</tt> should 
call member <tt>swap</tt>.
</p>

<p><i>[2015-07, Telecom]</i></p>

<p>
Both P3 and NAD were suggested.
</p>

<p><i>[2016-02-20, Ville comments]</i></p>

<p>
Feedback from an implementation:
<p/>
The implementation of <tt>propagate_const</tt> in libstdc++ calls <tt>propagate_const</tt>'s
member <tt>swap</tt> from the non-member <tt>swap</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit [propagate_const.algorithms] as indicated:</p>
<blockquote>
<pre>
-1- template &lt;class T&gt;
constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>)
</pre>
<blockquote>
<p>
-2- The constant-expression in the exception-specification is <tt>noexcept(<del>swap(pt1.t_, pt2.t_)</del><ins>pt1.swap(pt2)</ins>)</tt>.
<p/>
-3- <i>Effects</i>: <tt><del>swap(pt1.t_, pt2.t_)</del><ins>pt1.swap(pt2)</ins></tt>. 
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2519" href="#2519">2519.</a> Iterator <tt>operator-=</tt> has gratuitous undefined behaviour</h3>
<p><b>Section:</b> 24.2.7 [random.access.iterators] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hubert Tong  <b>Opened:</b> 2015-07-15 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#random.access.iterators">issues</a> in [random.access.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In subclause 24.2.7 [random.access.iterators], Table 110, the operational semantics for the expression "<tt>r -= n</tt>" 
are defined as
</p>
<blockquote><pre>
return r += -n;
</pre></blockquote>
<p>
Given a <tt>difference_type</tt> of a type <tt>int</tt> with range [-32768, 32767], if the value of <tt>n</tt> is -32768, 
then the evaluation of <tt>-n</tt> causes undefined behaviour (Clause 5 [expr] paragraph 4).
<p/>
The operational semantics may be changed such that the undefined behaviour is avoided.
<p/>
<b>Suggested wording:</b>
<p/>
Replace the operational semantics for "<tt>r -= n</tt>" with:
</p>
<blockquote><pre>
{ 
  difference_type m = n;
  if (m >= 0)
    while (m--)
      --r;
  else
    while (m++)
      ++r;
  return r; 
}
</pre></blockquote>
<p>
Jonathan Wakely:
<p/>
I'm now convinced we <em>don't</em> want to change the definition of <tt>-=</tt> and
instead we should explicitly state the (currently implicit)
precondition that <tt>n != numeric_limits&lt;difference_type&gt;::min()</tt>.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Change Table 110 "Random access iterator requirements (in addition to
bidirectional iterator)" as indicated:</p>
<blockquote>
<table border="1">
<caption>Table 110 &mdash; Random access iterator requirements (in addition to
bidirectional iterator)</caption>
<tr>
<th align="center">Expression</th>
<th align="center">Return type</th>
<th align="center">Operational<br/>semantics</th>
<th align="center">Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>r -= n</tt>
</td>

<td>
<tt>X&amp;</tt>
</td>

<td>
<tt>return r += -n;</tt>
</td>

<td>
<ins>pre: the absolute value of <tt>n</tt> is in the range of representable values of <tt>difference_type</tt>.</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2521" href="#2521">2521.</a> [fund.ts.v2] <tt>weak_ptr</tt>'s converting move constructor should be modified as well for array support</h3>
<p><b>Section:</b> 99 [fund.ts.v2::memory.smartptr.weak.const] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-07-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
[memory.smartptr.weak.const] altered the constraints on <tt>weak_ptr</tt>'s constructor from <tt>const weak_ptr&lt;Y&gt;&amp;</tt> 
and <tt>const shared_ptr&lt;Y&gt;&amp;</tt>. The constraints on the converting move constructor from <tt>weak_ptr&lt;Y&gt;&amp;&amp;</tt> 
was not, but should be, similarly modified.
</p>

<p><i>[2015-10-26]</i></p>

<p>
Daniel adjusts wording to lib. fund. v2. As link to the originating proposal: The discussion in this issue refers to 
wording changes that were requested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3920.html">N3920</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>At the end of [memory.smartptr.weak.const], add:<br/>
[<i>Drafting note</i>: The current paragraph [memory.smartptr.weak.const] p2 is incorrectly declared as <i>Requires</i> element,
but it does not describe a requirement, instead it describes a "template constraint" which are elsewhere always
specified within a <i>Remarks</i> element because it describes constraints that an implementation (and not the user) has to meet. 
See LWG <a href="lwg-active.html#2292">2292</a> for a suggestion to introduce a separate new specification element for this situation.
This has also been fixed in the current working draft. &mdash; 
<i>end drafting note</i>] 
</p>
<blockquote>
<pre>
<ins>weak_ptr(weak_ptr&amp;&amp; r) noexcept;
template&lt;class Y&gt; weak_ptr(weak_ptr&lt;Y&gt;&amp;&amp; r) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remark</i>: The second constructor shall not participate in overload resolution unless <tt>Y*</tt> is <i>compatible with</i> 
<tt>T*</tt>.</ins>
<p/>
<ins>-?- <i>Effects</i>: Move-constructs a <tt>weak_ptr</tt> instance from <tt>r</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>*this</tt> shall contain the old value of <tt>r</tt>. <tt>r</tt> shall be <i>empty</i>. 
<tt>r.use_count() == 0</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2524" href="#2524">2524.</a> <tt>generate_canonical</tt> can occasionally return 1.0</h3>
<p><b>Section:</b> 26.6.8.4.2 [rand.dist.pois.exp] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Michael Pr&auml;hofer <b>Opened:</b> 2015-08-20 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>Original title was: <tt>exponential_distribution&lt;float&gt;</tt> sometimes returns inf.</p>

<p>
The random number distribution class template <tt>exponential_distribution&lt;float&gt;</tt> may return "inf" as can be 
seen from the following example program:
</p>
<blockquote>
<pre>
// compiled with
// g++ -std=c++11 Error_exp_distr.cpp

#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;

int main(){
  unsigned long long h;
  std::mt19937_64 mt1(1);
  std::mt19937_64 mt2(1);
  mt1.discard(517517);
  mt2.discard(517517);
  std::exponential_distribution&lt;float&gt; dis(1.0);
  h = mt2();
  std::cout &lt;&lt; std::bitset&lt;64&gt;(h) &lt;&lt; " " &lt;&lt; (float) -log(1 - h/pow(2, 64)) &lt;&lt; " " 
            &lt;&lt; -log(1 - (float) h/pow(2, 64)) &lt;&lt; " " &lt;&lt; dis(mt1) &lt;&lt; std::endl;
  h = mt2();
  std::cout &lt;&lt; std::bitset&lt;64&gt;(h) &lt;&lt; " " &lt;&lt; (float) -log(1 - h/pow(2, 64)) &lt;&lt; " " 
            &lt;&lt; -log(1 - (float) h/pow(2, 64)) &lt;&lt; " " &lt;&lt; dis(mt1) &lt;&lt; std::endl;
}
</pre>
</blockquote>
<p>
output:
</p>
<blockquote>
<pre>
0110010110001001010011000111000101001100111110100001110011100001 0.505218 0.505218 0.505218
1111111111111111111111111101010011000110011110011000110101100110 18.4143 inf inf
</pre>
</blockquote>
<p>
The reason seems to be that converting a <tt>double x</tt> in the range <tt>[0, 1)</tt> to <tt>float</tt> may result in <tt>1.0f</tt> 
if <tt>x</tt> is close enough to <tt>1</tt>. I see two possibilities to fix that:
</p>
<ol>
<li><p>use internally <tt>double</tt> (or <tt>long double</tt>?) and then convert the result at the very end to <tt>float</tt>.</p></li>
<li><p>take only 24 random bits and convert them to a <tt>float x</tt> in the range <tt>[0, 1)</tt> and then return <tt>-log(1 - x)</tt>.</p></li>
</ol>

<p>
I have not checked if <tt>std::exponential_distribution&lt;double&gt;</tt> has the same problem:
For <tt>float</tt> on the average 1 out of 2<sup>24</sup> (~10<sup>7</sup>) draws returns "inf", which is easily confirmed.
For <tt>double</tt> on the average 1 out of 2<sup>53</sup> (~10<sup>16</sup>) draws might return "inf", which I have not tested.
</p>

<p><b>Marshall:</b><br/>
I don't think the problem is in <tt>std::exponential_distribution</tt>; but rather in <tt>generate_canonical</tt>.
</p>

<p>Consider:
<blockquote><pre>
std::mt19937_64 mt2(1);
mt2.discard(517517);
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
std::cout &lt;&lt; std::hexfloat &lt;&lt; std::generate_canonical&lt;float, std::numeric_limits&lt;float&gt;::digits&gt;(mt2) &lt;&lt; std::endl;
</pre></blockquote>
<p/>
which outputs:
<p/>
<blockquote><pre>
0x1.962532p-2
0x1p+0
0x1.20d0cap-3
</pre></blockquote>

but <tt>generate_canonical</tt> is defined to return a result in the range [0, 1).
</p>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>Options: </p>
<ul>
<li>1) NAD, make it work. E.g. nudge slightly, making the hightest result return the highest allowable value (next_after). This might change the distribution slightly.</li>
<li>2) Re-run the algorithm when you get a 1. This changes the specification in that it makes extra calls to the random engine.</li>
<li>3) Something else</li>
</ul>

<p>WEB: The one thing we cannot tolerate is any output range other than [0, 1).</p>
<p>WEB: I believe there may be a documented algorithm for the generator, and perhaps it's possible to discover en-route that the algorithm produces the wrong result and fix it.</p>
<p>MC: No. I analyzed this once, and here it is: the algorithm is in [rand.util.canonical], and it's all fine until p5. The expression <tt>S/R^k</tt> is mathematically less than one, but it may round to one.</p>
<p>GR: Could we change the rounding mode for the computation? </p>
<p>HH: No, because the rounding mode is global, not thread-local.</p>
<p>AM: SG1 wants to get rid of the floating point environment. </p>
<p>STL: The problem is that the standard specifies the implementation, and the implementation doesn't work.</p>
<p>MC: I'm not sure if nudging it down will introduce a subtle bias.</p>
<p>EF: I worry about how the user's choice of floating point environment affects the behaviour.</p>
<p>MS offers to run the topic past colleagues.</p>
<p>MC: Will set the status to open. STL wants to rename the issue. WEB wants to be able to find the issue by its original name still.</p>

<p>Mike Spertus to run the options past his mathematical colleagues, and report back.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2525" href="#2525">2525.</a> [fund.ts.v2] <tt>get_memory_resource</tt> should be <tt>const</tt> and <tt>noexcept</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::func.wrap.func], 99 [fund.ts.v2::futures.promise], 99 [fund.ts.v2::futures.task] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-08-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::func.wrap.func">active issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::func.wrap.func">issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
There doesn't seem to be any reason why this member function cannot be called on a <tt>const</tt> object, 
or why it would ever throw. I discussed this with Pablo Halpern, the author of N3916, and he agrees that 
this appears to have been an oversight.
</p>

<p><i>[2015-10-26]</i></p>

<p>
Daniel adjusts wording to lib. fund. v2.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit each of the synposes in 99 [func.wrap.func], 99 [futures.promise], and 
99 [futures.task] as indicated:</p>
<blockquote>
<pre>
pmr::memory_resource* get_memory_resource() <ins>const noexcept</ins>;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2527" href="#2527">2527.</a> [fund.ts.v2] <tt><i>ALLOCATOR_OF</i></tt> for <tt>function::operator=</tt> has incorrect default</h3>
<p><b>Section:</b> 99 [fund.ts.v2::func.wrap.func.con] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-08-04 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::func.wrap.func.con">issues</a> in [fund.ts.v2::func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
According to the table in  [memory.type.erased.allocator], if no allocator argument is specified at the time 
of construction, the memory resource pointer used is the value of <tt>experimental::pmr::get_default_resource()</tt> at 
the time of construction.
</p>
<p>
Yet in 99 [func.wrap.func.con], <tt><i>ALLOCATOR_OF</i></tt> is specified to return <tt>allocator&lt;char&gt;()</tt> 
if no allocator was specified at the time of construction, which seems incorrect, especially as the user can change the default
memory resource pointer to something other than <tt>new_delete_resource()</tt>.
</p>

<p><i>[2015-10-26]</i></p>

<p>
Daniel adjusts wording to lib. fund. v2.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4529.html">N4529</a>.
</p>

<ol>
<li><p>Edit 99 [func.wrap.func.con]/p2 as indicated:</p>
<blockquote>
<p>
-2- In the following descriptions, let <tt><i>ALLOCATOR_OF</i>(f)</tt> be the allocator specified in the construction of 
<tt>function</tt> <tt>f</tt>, or <del><tt>allocator&lt;char&gt;()</tt></del><ins>the value of <tt>experimental::pmr::get_default_resource()</tt> 
at the time of the construction of <tt>f</tt></ins> if no allocator was specified.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2528" href="#2528">2528.</a> Order of <tt>std::tuple</tt> construction unspecified</h3>
<p><b>Section:</b> 20.5.2.1 [tuple.cnstr] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Brian Rodriguez <b>Opened:</b> 2015-08-25 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.cnstr">active issues</a> in [tuple.cnstr].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.cnstr">issues</a> in [tuple.cnstr].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>std::tuple</tt> order of element construction is unspecified. It is either in the same order of the type list or in reverse. 
<p/>
Consider the following program:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;tuple&gt;

struct X 
{
  X(int) { std::cout &lt;&lt; "X constructor\n"; }
};

struct Y 
{
  Y(int) { std::cout &lt;&lt; "Y constructor\n"; }
};

int main()
{
  std::tuple&lt;X, Y&gt; t(1, 2);
}
</pre></blockquote>
<p>
Here is a <a href="http://coliru.stacked-crooked.com/a/764d0477523ba249">link</a> to two sample compilations. The first uses 
libstdc++ and constructs in reverse order, and the second uses libc++ and constructs in in-order. 
<p/>
A <tt>std::tuple</tt> mimics both a struct and type-generic container and should thus follow their standards. Construction is 
fundamentally different from a function call, and it has been historically important for a specific order to be guaranteed; 
namely: whichever the developer may decide. Mandating construction order will allow developers to reference younger elements 
later on in the chain as well, much like a struct allows you to do with its members.
<p/>
There are implementation issues as well. Reversed lists will require unnecessary overhead for braced-initializer-list initialization.  
Since lists are evaluated from left to right, the initializers must be placed onto the stack to respect the construction order. 
This issue could be significant for large tuples, deeply nested tuples, or tuples with elements that require 
many constructor arguments.
<p/>
I propose that the <tt>std::tuple&lt;A, B, ..., Y, Z&gt;</tt>'s constructor implementation be standardized, and made to construct 
in the same order as its type list e.g. <tt>A{}, B{}, ..., Y{}, Z{}</tt>.
</p>

<p>
<b>Daniel:</b>
<p/>
When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3140.html">N3140</a> became accepted, wording had been
added that gives at least an indication of requiring element initialization in the order of the declaration of the template
parameters. This argumentation can be based on 20.5.2.1 [tuple.cnstr] p3 (emphasize mine):
</p>
<blockquote><p>
-3- In the constructor descriptions that follow, let <tt><i>i</i></tt> be in the range <tt>[0,sizeof...(Types))</tt> 
<span style="color:#C80000;font-weight:bold">in order</span>, 
<tt><i>Ti</i></tt> be the <tt><i>i<sup>th</sup></i></tt> type in <tt>Types</tt>, and <tt><i>Ui</i></tt> be the 
<tt><i>i<sup>th</sup></i></tt> type in a template parameter pack named <tt>UTypes</tt>, where indexing is
zero-based.
</p></blockquote>
<p>
But the current wording needs to be improved to make that intention clearer and an issue like this one is necessary to be sure that
the committee is agreeing (or disagreeing) with that intention, especially because N3140 didn't really point out the relevance of the element
construction order in the discussion, and because not all constructors explicitly refer to the ordered sequence of numbers generated
by the variable <tt><i>i</i></tt> (The move constructor does it right, but most other don't do that). 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2529" href="#2529">2529.</a> Assigning to <tt>enable_shared_from_this::__weak_this</tt> twice</h3>
<p><b>Section:</b> 20.11.2.5 [util.smartptr.enab] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2015-08-26 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.enab">active issues</a> in [util.smartptr.enab].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.enab">issues</a> in [util.smartptr.enab].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It is unclear what should happen if a pointer to an object with an
<tt>enable_shared_from_this</tt> base is passed to two different <tt>shared_ptr</tt>
constructors.
</p>
<blockquote><pre>
#include &lt;memory&gt;

using namespace std;

int main()
{
  struct X : public enable_shared_from_this&lt;X&gt; { };
  auto xraw = new X;
  shared_ptr&lt;X&gt; xp1(xraw);  // #1
  {
    shared_ptr&lt;X&gt; xp2(xraw, [](void*) { });  // #2
  }
  xraw-&gt;shared_from_this();  // #3
}
</pre></blockquote>
<p>
This is similar to LWG <a href="lwg-active.html#2179">2179</a>, but involves no undefined behaviour due
to the no-op deleter, and the question is not whether the second
<tt>shared_ptr</tt> should share ownership with the first, but which <tt>shared_ptr</tt>
shares ownership with the <tt>enable_shared_from_this::__weak_this</tt> member.
<p/>
With all three of the major <tt>std::shared_ptr</tt> implementations the <tt>xp2</tt>
constructor modifies the <tt>__weak_this</tt> member so the last line of the
program throws <tt>bad_weak_ptr</tt>, even though all the requirements on the 
<tt>shared_from_this()</tt> function are met (20.11.2.5 [util.smartptr.enab])/7:
</p>
<blockquote><p>
<i>Requires</i>: <tt>enable_shared_from_this&lt;T&gt;</tt> shall be an accessible base class
of <tt>T</tt>. <tt>*this</tt> shall be a subobject of an object <tt>t</tt> of type <tt>T</tt>. There shall
be at least one <tt>shared_ptr</tt> instance <tt>p</tt> that owns <tt>&amp;t</tt>.
</p></blockquote>
<p>
Boost doesn't update <tt>__weak_this</tt>, leaving it sharing with <tt>xp1</tt>, so the
program doesn't throw. That change was made to <tt>boost::enable_shared_from_this</tt> because 
someone reported exactly this issue as a bug, see <a href="https://svn.boost.org/trac/boost/ticket/2584">Boost issue 2584</a>.
<p/>
On the reflector Peter Dimov explained that there are real-world use
cases that rely on the Boost behaviour, and none which rely on the
behaviour of the current <tt>std::shared_ptr</tt> implementations. We should
specify the behaviour of <tt>enable_shared_from_this</tt> more precisely, and
resolve this issue one way or another.
</p>

<p><i>[2016-03-16, Alisdair comments]</i></p>

<p>
This issues should be closed as <tt>Resolved</tt> by paper <a href="http://wg21.link/p0033r1">p0033r1</a> at Jacksonville.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2530" href="#2530">2530.</a> Clarify observable side effects of releasing a shared state</h3>
<p><b>Section:</b> 30.6.4 [futures.state] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When a shared-state is released, it may be necessary to execute user defined code for the destructor of a 
stored value or exception. It is unclear whether the execution of said destructor constitutes an observable side effect.
</p>
<p>
While discussing N4445 in Lenexa, Nat Goodspeed pointed out that 30.6.4 [futures.state]/5.1 does not explicitly 
mention the destruction of the result, so implementations should be allowed to release (or reuse) a shared state ahead 
of time under the "as-if" rule.
<p/>
The standard should clarify whether the execution of destructors is a visible side effect of releasing a shared state.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>This is related to <a href="lwg-active.html#2532">2532</a></p>
<p>Fri AM: Moved to Open</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2531" href="#2531">2531.</a> <tt>future::get</tt> should explicitly state that the shared state is released</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.unique_future">active issues</a> in [futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The standard is usually very explicit on when a shared state is released, except for <tt>future::get</tt> 
for which it only states <tt>valid() == false</tt> as a postcondition.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Modify 30.6.6 [futures.unique_future] as indicated:</p>
<blockquote><pre>
R future::get();
R&amp; future&lt;R&amp;&gt;::get();
void future&lt;void&gt;::get();
</pre>
<blockquote>
<p>
-14- <i>Note</i>: as described above, the template and its two required specializations differ only in the return
type and return value of the member function <tt>get</tt>.
<p/>
-15- <i>Effects</i>:
</p>
<ul>
<li><p><tt>wait()</tt>s until the shared state is ready, then retrieves the value stored in the shared state<del>.</del><ins>;</ins></p></li>
<li><p><ins>releases any shared state (30.6.4 [futures.state]).</ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2532" href="#2532">2532.</a> Satisfying a <tt>promise</tt> at thread exit</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>promise::set_value_at_thread_exit</tt> and <tt>promise::set_exception_at_thread_exit</tt> operate on a shared state 
at thread exit, without making the thread participate in the ownership of such shared state.
<p/>
Consider the following snippet:
</p>
<blockquote><pre>
std::promise&lt;int&gt;{}.set_value_at_thread_exit(42);
</pre></blockquote>
<p>
Arguably, since the <tt>promise</tt> abandons its shared state without actually making it ready, a <tt>broken_promise</tt> 
error condition should be stored in the shared state. Implementations diverge, they either crash at thread exit by 
dereferencing an invalid pointer, or keep the shared state around until thread exit.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>This is related to <a href="lwg-active.html#2530">2530</a></p>
<p><i>[2016-08-03, Billy O'Neal suggests concrete wording]</i></p>

<p>Fri AM: Moved to Open</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 30.6.4 [futures.state] p7 as indicated:</p>

<blockquote>
<p>
-7- When an asynchronous provider is said to abandon its shared state, it means:
</p>
<ol style="list-style-type: none">
<li><p>(7.1) &mdash; first, if that state is not ready <ins>or scheduled to be made ready at thread exit</ins>, the provider</p>
<ol style="list-style-type: none">
<li><p>(7.1.1) &mdash; stores an exception object of type <tt>future_error</tt> with an error condition of 
<tt>broken_promise</tt> within its shared state; and then</p></li>
<li><p>(7.1.2) &mdash; makes its shared state ready;</p></li>
</ol>
</li>
</ol>
</blockquote>
</li>

<li><p>Change 30.6.4 [futures.state] p10 as indicated:</p>

<blockquote>
<p>
-10- Some functions (e.g., <tt>promise::set_value_at_thread_exit</tt>) <del>delay making the shared state ready 
until</del><ins>schedule the shared state to be made ready when</ins> the
calling thread exits. <ins>This associates a reference to the shared state with the calling thread.</ins> The 
destruction of each of that thread's objects with thread storage duration 
(3.7.2 [basic.stc.thread]) is sequenced before making that shared state ready. <ins>When the calling 
thread makes the shared state ready, if the thread holds the last reference to the shared state, the shared state 
is destroyed. [<i>Note:</i> This means that the shared state may not become ready until after the <em>asynchronous 
provider</em> has been destroyed. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2533" href="#2533">2533.</a> [concurr.ts] Constrain threads where <tt>future::then</tt> can run a continuation</h3>
<p><b>Section:</b> 99 [concurr.ts::futures.unique_future] <b>Status:</b> <a href="lwg-active.html#SG1">SG1</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-09-03 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concurr.ts::futures.unique_future">active issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#concurr.ts::futures.unique_future">issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#SG1">SG1</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: concurr.ts</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4538.pdf">N4538</a>, the continuation given to 
<tt>future::then</tt> can be run "on an unspecified thread of execution". This is too broad, as it allows the 
continuation to be run on the main thread, a UI thread, or any other thread. In comparison, functions given to 
<tt>async</tt> run "as if in a new thread of execution", while the Parallelism TS gives less guarantees by running 
"in either the invoking thread or in a thread implicitly created by the library to support parallel algorithm execution". 
The threads on which the continuation given to <tt>future::then</tt> can run should be similarly constrained.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2534" href="#2534">2534.</a> Constrain rvalue stream operators</h3>
<p><b>Section:</b> 27.7.3.9 [ostream.rvalue], 27.7.2.6 [istream.rvalue] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2015-09-08 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#ostream.rvalue">active issues</a> in [ostream.rvalue].</p>
<p><b>View all other</b> <a href="lwg-index.html#ostream.rvalue">issues</a> in [ostream.rvalue].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The rvalue stream insertion and extraction operators should be constrained to not participate in overload 
resolution unless the expression they evaluate is well-formed. Programming code that tests the validity of 
stream insertions (or extractions) using SFINAE can result in false positives, as the present 
declarations accept virtually any right-hand side argument. Moreover, there is no need for pollution of 
the candidate set with ill-formed specializations.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Modify 27.7.3.9 [ostream.rvalue] as indicated:</p>
<blockquote>
<pre>
template &lt;class charT, class traits, class T&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
  operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp;&amp; os, const T&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <tt>os &lt;&lt; x</tt>
<p/>
-2- <i>Returns</i>: <tt>os</tt>
<p/>
<ins>-?- <i>Remarks</i>: This function shall not participate in overload resolution unless the expression 
<tt>os &lt;&lt; x</tt> is well-formed.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 27.7.2.6 [istream.rvalue] as indicated:</p>
<blockquote>
<pre>
template &lt;class charT, class traits, class T&gt;
  basic_istream&lt;charT, traits&gt;&amp;
  operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp;&amp; is, T&amp; x);
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <tt>is &gt;&gt; x</tt>
<p/>
-2- <i>Returns</i>: <tt>is</tt>
<p/>
<ins>-?- <i>Remarks</i>: This function shall not participate in overload resolution unless the expression 
<tt>is &gt;&gt; x</tt> is well-formed.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2536" href="#2536">2536.</a> What should <tt>&lt;complex.h&gt;</tt> do?</h3>
<p><b>Section:</b> D.4 [depr.c.headers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2015-09-10 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#depr.c.headers">issues</a> in [depr.c.headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG issue <a href="lwg-defects.html#1134">1134</a> removed the resolution of LWG <a href="lwg-defects.html#551">551</a>, leaving an incorrect specification for 
the behavior of <tt>&lt;complex.h&gt;</tt>. This header is currently required to make <tt>std::complex</tt> (and 
associated functions) visible in the global namespace, but should not be so required.
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4527.
</p>

<ol>
<li><p>Add a new paragraph <em>before</em> D.4 [depr.c.headers]/2:</p>
<blockquote><p>
<ins>-?- The header <tt>&lt;complex.h&gt;</tt> behaves as if it simply includes the header <tt>&lt;ccomplex&gt;</tt>.</ins>
</p></blockquote>
</li>

<li><p>Change in D.4 [depr.c.headers]/2:</p>
<blockquote><p>
-2- Every <ins>other</ins> C header, each of which has a name of the form <tt>name.h</tt>, behaves as if each name placed 
in the standard library namespace by the corresponding <tt>cname</tt> header is placed within the global namespace scope. 
It is unspecified whether these names are first declared or defined within namespace scope (3.3.6) of the namespace
<tt>std</tt> and are then injected into the global namespace scope by explicit <i>using-declarations</i> (7.3.3).
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2540" href="#2540">2540.</a> <tt>unordered_multimap::insert</tt> hint iterator</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Isaac Hier <b>Opened:</b> 2015-09-16 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have been wondering about the C++ standard requirements regarding the hint iterator for insertion into an 
<tt>unordered_multimap</tt> (and I imagine a similar question could be asked of <tt>unordered_map</tt>, but 
I have not researched that topic). As far as I can tell, it seems perfectly valid for an implementation to 
allow only valid dereferencable iterators to be used as the hint argument for this member function. If that 
is correct, it means that one could not expect the end iterator to be used as a valid hint nor could one use 
the begin iterator of an empty <tt>unordered_multimap</tt> as the hint. However, this essentially precludes 
all uses of inserter on an empty <tt>unordered_multimap</tt> seeing as the inserter functor requires that a 
hint iterator be passed to its constructor.
<p/>
Howard Hinnant:
</p>
<blockquote class="note">
<p>
The intent of the standard is that the iterator produced from container <tt>c</tt> by <tt>c.end()</tt> is a 
valid (but non-dereferenceable) iterator into container <tt>c</tt>. It is reachable by every other iterator 
into <tt>c</tt>.
<p/>
It appears to me that you and the Bloomberg implementation have fallen victim to a type-o in the Unordered 
associative container requirements, Table 102.  The row containing:
</p>
<blockquote><pre>
a.insert(q, t);
</pre></blockquote>
<p>
should read instead:
</p>
<blockquote><pre>
a.insert(p, t);
</pre></blockquote>
<p>
The distinction is that <tt>p</tt> is valid, and <tt>q</tt> is both valid and dereferenceable.
The correction of this type-o would make unordered container <tt>insert</tt> consistent with unordered <tt>emplace_hint</tt>, 
associative <tt>insert</tt>, and associative <tt>emplace_hint</tt>.
</p>
</blockquote>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the insert-with-hint row in Table 102
Unordered associative container requirements like so:
</p>
<blockquote>
<table border="1" cellpadding="4"><tr>
<td><tt>a.insert(<del>q</del><ins>p</ins>, t);</tt><br/></td>
<td><tt>iterator</tt><br/></td>
<td><i>Requires:</i> If <tt>t</tt> is a non-const<br/>...</td>
<td>Average Case<br/>...</td>
</tr></table>
</blockquote>





<hr>
<h3><a name="2541" href="#2541">2541.</a> [parallel.ts] Headers for <tt>ExecutionPolicy</tt> algorithm overloads</h3>
<p><b>Section:</b> 99 [parallel.ts::parallel.alg.overloads] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-09-26 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: parallel.ts</b></p>
<p>
99 [parallel.alg.overloads] provides parallel algorithm overloads for many algorithms in the standard library, 
but I can't find any normative wording specifying which headers these new overloads live in. Presumably, if the original 
algorithm is in <tt>&lt;meow&gt;</tt>, the new overloads should be in <tt>&lt;experimental/meow&gt;</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2543" href="#2543">2543.</a> LWG 2148 (hash support for enum types) seems under-specified</h3>
<p><b>Section:</b> 20.14.14 [unord.hash] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-09-27 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.hash">active issues</a> in [unord.hash].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.hash">issues</a> in [unord.hash].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The rationale in issue <a href="lwg-defects.html#2148">2148</a> says:
</p>
<blockquote class="note"><p>
This proposed resolution doesn't specify anything else about the
primary template, allowing implementations to do whatever they want
for non-enums: <tt>static_assert</tt> nicely, explode horribly at compiletime
or runtime, etc.
</p></blockquote>
<p>
libc++ seems to implement it by defining the primary template and
<tt>static_assert</tt>ing <tt>is_enum</tt> inside it. However, that brings forth
a problem; there are reasonable SFINAE uses broken by it:
</p>
<blockquote><pre>
#include &lt;type_traits&gt;
#include &lt;functional&gt;

class S{}; // No hash specialization

template&lt;class T&gt;
auto f(int) -&gt; decltype(std::hash&lt;T&gt;(), std::true_type());

template&lt;class T&gt;
auto f(...) -&gt; decltype(std::false_type());

static_assert(!decltype(f&lt;S&gt;(0))::value, "");
</pre></blockquote>
<p>
MSVC doesn't seem to accept that code either.
<p/>
There <em>is</em> a way to implement LWG <a href="lwg-defects.html#2148">2148</a> so that <tt>hash</tt> for enums is supported
without breaking that sort of SFINAE uses:
</p>
<ol>
<li><p>Derive the main <tt>hash</tt> template from a library-internal uglified-named
base template that takes a type and a <tt>bool</tt>, pass as argument for the base
the result of <tt>is_enum</tt>.</p></li>
<li><p>Partially specialize that base template so that the false-case has
a suitable set of private special member function declarations so that it's not
an aggregate nor usable in almost any expression.</p></li>
</ol>

<p><i>[2015-10, Kona Saturday afternoon]</i></p>

<p>EricWF to come back with wording; move to Open</p>

<p><i>[2016-05-08, Eric Fiselier &amp; Ville provide wording]</i></p>


<p><i>[2016-05-25, Tim Song comments]</i></p>

<p>
I see two issues with this P/R:
</p>
<ol>
<li><p>
"for which neither the library nor the user provides an explicit specialization" should probably be "for which neither 
the library nor the user provides an explicit or partial specialization".
</p></li>
<li><p>
Saying that the specialization "is not <tt>DefaultConstructible</tt> nor <tt>MoveAssignable</tt>" is not enough to 
guarantee that common SFINAE uses will work. Both of those requirements have several parts, and it's not too hard 
to fail only some of them. For instance, not meeting the assignment postcondition breaks <tt>MoveAssignable</tt>, 
but is usually not SFINAE-detectible. And for <tt>DefaultConstructible</tt>, it's easy to write something in a way 
that breaks <tt>T()</tt> but not <tt>T{}</tt> (due to aggregate initialization in the latter case).
</p></li>
</ol>

<p><i>[2016-06-14, Daniel comments]</i></p>

<p>
The problematic part of the P/R is that it describes constraints that would be suitable if they were constraints 
for user-code, but they are not suitable as requirements imposed on implementations to provide certain guarantees 
for clients of the Library. The guarantees should be written in terms of testable compile-time expressions, e.g. based on 
negative results of <tt>is_default_constructible&lt;hash&lt;X&gt;&gt;::value</tt>, 
<tt>std::is_copy_constructible&lt;hash&lt;X&gt;&gt;::value</tt>, and possibly also 
<tt>std::is_destructible&lt;hash&lt;X&gt;&gt;::value</tt>. <em>How</em> an implementation realizes these negative 
results shouldn't be specified, though, but the expressions need to be well-formed and well-defined.

<p><i>[2016-08-03, Ville provides revised wording as response to Daniel's previous comment]</i></p>

</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Insert a new paragraph after 20.14.14 [unord.hash]/2</p>

<blockquote>
<p>
-2- The template specializations shall meet the requirements of class template <tt>hash</tt> (20.12.14).
<p/>
<ins>-?- For any type that is not of integral or enumeration type, or for
which neither the library nor the user provides an explicit
specialization of the class template <tt>hash</tt>, the specialization of <tt>hash</tt> does not meet
any of the <tt>Hash</tt> requirements, and is not <tt>DefaultConstructible</tt> nor
<tt>MoveAssignable</tt>.
[<i>Note</i>: this means that the specialization of <tt>hash</tt> exists, but any
attempts to use it as a Hash will be ill-formed. &mdash; <i>end note</i>]
</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to Tentatively Ready</p>

<strong>Previous resolution [SUPERSEDED]:</strong>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Insert a new paragraph after 20.14.14 [unord.hash]/2</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> I see no reason to specify whether <tt>H&lt;T&gt;</tt> is
destructible. There's no practical use case for which that would need to be covered. 
libstdc++ makes it so that <tt>H&lt;T&gt;</tt> is destructible.]
</p>
</blockquote>

<blockquote>
<p>
-2- The template specializations shall meet the requirements of class template <tt>hash</tt> (20.12.14).
<p/>
<ins>-?- For any type <tt>T</tt> that is not of integral or enumeration type, or for
which neither the library nor the user provides an explicit or partial specialization of the class
template hash, the specialization of <tt>hash&lt;T&gt;</tt> has the following properties:
</ins>
</p>
<ul>
<li><ins><tt>is_default_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_copy_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_move_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_copy_assignable_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_move_assignable_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_callable_v&lt;hash&lt;T&gt;, T&amp;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_callable_v&lt;hash&lt;T&gt;, const T&amp;&gt;</tt> is <tt>false</tt></ins></li>
</ul>
<p>
<ins>[<i>Note:</i> this means that the specialization of <tt>hash</tt> exists, but any
attempts to use it as a <tt>Hash</tt> will be ill-formed. &mdash; end note]</ins>
</p>
</blockquote>
</li>
</ol></blockquote>

<p><i>[2016-08-09 Daniel reopens]</i></p>

<p>
As pointed out by Eric, the usage of <tt>is_callable</tt> is incorrect.
Eric provides new wording.
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Insert a new paragraph after 20.14.14 [unord.hash]/2</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> I see no reason to specify whether <tt>H&lt;T&gt;</tt> is
destructible. There's no practical use case for which that would need to be covered. 
libstdc++ makes it so that <tt>H&lt;T&gt;</tt> is destructible.]
</p>
</blockquote>

<blockquote>
<p>
-2- The template specializations shall meet the requirements of class template <tt>hash</tt> (20.12.14).
<p/>
<ins>-?- For any type <tt>T</tt> that is not of integral or enumeration type, or for
which neither the library nor the user provides an explicit or partial specialization of the class
template hash, the specialization of <tt>hash&lt;T&gt;</tt> has the following properties:
</ins>
</p>
<ul>
<li><ins><tt>is_default_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_copy_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_move_constructible_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_copy_assignable_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>is_move_assignable_v&lt;hash&lt;T&gt;&gt;</tt> is <tt>false</tt></ins></li>
<li><ins><tt>hash&lt;T&gt;</tt> is not a function object type (20.14 [function.objects])</ins></li>
</ul>
<p>
<ins>[<i>Note:</i> this means that the specialization of <tt>hash</tt> exists, but any
attempts to use it as a <tt>Hash</tt> will be ill-formed. &mdash; end note]</ins>
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2544" href="#2544">2544.</a> <tt>istreambuf_iterator(basic_streambuf&lt;charT, traits&gt;* s)</tt> effects unclear when <tt>s</tt> is <tt>0</tt></h3>
<p><b>Section:</b> 24.6.3.2 [istreambuf.iterator.cons] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2015-10-05 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4527 24.6.3.2 [istreambuf.iterator.cons] does not mention what the effect of calling 
<tt>istreambuf_iterator(basic_streambuf&lt;charT, traits&gt;* s)</tt> is when <tt>s</tt> is a null pointer. 
It should be made clear that this case is well-formed and the result is a end-of-stream iterator.
<p/>
Daniel:
<p/>
According to 24.6.3 [istreambuf.iterator] p1:
</p>
<blockquote><p>
[&hellip;] The default constructor <tt>istreambuf_iterator()</tt> and the constructor <tt>istreambuf_iterator(0)</tt> both 
construct an end-of-stream iterator object suitable for use as an end-of-range. [&hellip;]
</p></blockquote>
<p>
This indicates that the described constructor creates an end-of-stream iterator, but this wording is part of the introductory 
wording and I recommend to make 24.6.3.2 [istreambuf.iterator.cons] clearer, because the existing specification is already
flawed, e.g. it never specifies when and how the exposition-only-member <tt>sbuf_</tt> is initialized. The proposed wording 
below attempts to solve these problems as well.
</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>This wording is relative to N4527.</p>

<ol>
<li>
<p>Change 24.6.3.2 [istreambuf.iterator.cons] as indicated:
<p/>
[<i>Editorial note</i>: The proposed wording changes also performs some editorial clean-up of the existing mismatches
of the declarations in the class template synopsis and the individual member specifications. The below wording intentionally
does not say anything about the concrete value of <tt>sbuf_</tt> for end-of-stream iterator values, because that
was never specified before; in theory, this could be some magic non-null pointer that can be used in constant expressions. 
But the wording could be drastically simplified by requiring <tt>sbuf_</tt> to be a null pointer for an end-of-stream iterator value, 
since I have not yet seen any implementation where this requirement does not hold. &mdash; <i>end editorial note</i>]
</p>
<blockquote>
<pre>
constexpr istreambuf_iterator() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: Constructs the end-of-stream iterator.
</p>
</blockquote>
<pre>
istreambuf_iterator(<del>basic_istream&lt;charT,traits&gt;</del><ins>istream_type</ins>&amp; s) noexcept;
<del>istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s) noexcept;</del>
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: <ins>If <tt>s.rdbuf()</tt> is a null pointer, constructs an end-of-stream iterator; otherwise 
initializes  <tt>sbuf_</tt> with <tt>s.rdbuf()</tt> and constructs an <tt>istreambuf_iterator</tt> that uses the 
<tt>streambuf_type</tt> object <tt>*sbuf_</tt></ins><del>Constructs an <tt>istreambuf_iterator&lt;&gt;</tt> that 
uses the <tt>basic_streambuf&lt;&gt;</tt> object <tt>*(s.rdbuf())</tt>, or <tt>*s</tt>, respectively. Constructs 
an end-of-stream iterator if <tt>s.rdbuf()</tt> is null</del>.
</p>
</blockquote>
<pre>
<ins>istreambuf_iterator(streambuf_type* s) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: If <tt>s</tt> is a null pointer, constructs an end-of-stream iterator; otherwise initializes 
<tt>sbuf_</tt> with <tt>s</tt> and constructs an <tt>istreambuf_iterator</tt> that uses the <tt>streambuf_type</tt> 
object <tt>*sbuf_</tt>.</ins>
</p>
</blockquote>
<pre>
istreambuf_iterator(const proxy&amp; p) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>p.sbuf_</tt> and constructs an <tt>istreambuf_iterator</tt> 
that uses the <tt>streambuf_type</tt> object <tt>*sbuf_</tt></ins><del>Constructs a <tt>istreambuf_iterator&lt;&gt;</tt> 
that uses the <tt>basic_streambuf&lt;&gt;</tt> object pointed to by the <tt>proxy</tt> object's constructor argument 
<tt>p</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2015-10-20, Daniel provides alternative wording]</i></p>


<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li>
<p>Change 24.6.3.2 [istreambuf.iterator.cons] as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The proposed wording changes also performs some editorial clean-up of the existing mismatches
of the declarations in the class template synopsis and the individual member specifications. The below wording is 
simplified by requiring <tt>sbuf_</tt> to be a null pointer for an end-of-stream iterator value, 
since I have not yet seen any implementation where this requirement does not hold. Even if there <em>were</em> such an 
implementation, this would still be conforming, because concrete exposition-only member values are not part of public 
API. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
<blockquote>
<p>
<ins>For each <tt>istreambuf_iterator</tt> constructor in this section, an end-of-stream iterator is 
constructed if and only if the exposition-only member <tt>sbuf_</tt> is initialized with a null 
pointer value.</ins>
</p>
<pre>
constexpr istreambuf_iterator() noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>nullptr</tt></ins><del>Constructs the end-of-stream iterator</del>.
</p>
</blockquote>
<pre>
istreambuf_iterator(<del>basic_istream&lt;charT,traits&gt;</del><ins>istream_type</ins>&amp; s) noexcept;
<del>istreambuf_iterator(basic_streambuf&lt;charT,traits&gt;* s) noexcept;</del>
</pre>
<blockquote>
<p>
-2- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>s.rdbuf()</tt></ins><del>Constructs 
an <tt>istreambuf_iterator&lt;&gt;</tt> that uses the <tt>basic_streambuf&lt;&gt;</tt> object 
<tt>*(s.rdbuf())</tt>, or <tt>*s</tt>, respectively. Constructs 
an end-of-stream iterator if <tt>s.rdbuf()</tt> is null</del>.
</p>
</blockquote>
<pre>
<ins>istreambuf_iterator(streambuf_type* s) noexcept;</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes <tt>sbuf_</tt> with <tt>s</tt>.</ins>
</p>
</blockquote>
<pre>
istreambuf_iterator(const proxy&amp; p) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>Initializes <tt>sbuf_</tt> with <tt>p.sbuf_</tt></ins><del>Constructs a <tt>istreambuf_iterator&lt;&gt;</tt> 
that uses the <tt>basic_streambuf&lt;&gt;</tt> object pointed to by the <tt>proxy</tt> object's constructor argument 
<tt>p</tt></del>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2546" href="#2546">2546.</a> Implementability of locale-sensitive <em>UnicodeEscapeSequence</em> matching</h3>
<p><b>Section:</b> 28.13 [re.grammar] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-10-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.13 [re.grammar] paragraph 2:
</p>
<blockquote><p>
<tt>basic_regex</tt> member functions shall not call any locale dependent C or C++ API, including the formatted 
string input functions. Instead they shall call the appropriate traits member function to achieve the required effect.
</p></blockquote>
<p>
Yet, the required interface for a regular expression traits class (28.3 [re.req]) does not appear to have 
any reliable method for determining whether a character as encoded for the locale associated with the traits 
instance is the same as a character represented by a <em>UnicodeEscapeSequence</em>, e.g., assuming a sane 
<tt>ru_RU.koi8r</tt> locale:
</p>
<blockquote><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;regex&gt;

const char data[] = "\xB3";
const char matchCyrillicCaptialLetterYo[] = R"(\u0401)";

int main(void) 
{
  try {
    std::regex myRegex;
    myRegex.imbue(std::locale("ru_RU.koi8r"));

    myRegex.assign(matchCyrillicCaptialLetterYo, std::regex_constants::ECMAScript);
    printf("(%s)\n", std::regex_replace(std::string(data), myRegex, std::string("E")).c_str());

    myRegex.assign("[[:alpha:]]", std::regex_constants::ECMAScript);
    printf("(%s)\n", std::regex_replace(std::string(data), myRegex, std::string("E")).c_str());
  } catch (std::regex_error&amp; e) {
    abort();
  }
  return 0;
}
</pre></blockquote>
<p>
The implementation I tried prints:
</p>
<blockquote><pre>
(&#x401;)
(E)
</pre></blockquote>
<p>
Which means that the character class matching worked, but not the matching to the <em>UnicodeEscapeSequence</em>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2547" href="#2547">2547.</a> Container requirements (and other library text) should say "strict total order", not just "total order"</h3>
<p><b>Section:</b> 20.14.6 [comparisons], 23.2.1 [container.requirements.general], 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2015-10-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A number of places in the library, including 20.14.6 [comparisons]/14, the Optional container requirements in 
23.2.1 [container.requirements.general], and 30.3.1.1 [thread.thread.id]/8, use the phrase "total order". 
Unfortunately, that phrase is ambiguous. In mathematics, the most common definition is that a relation <tt>&le;</tt> is 
a total order if it's total, transitive, and antisymmetric in the sense that <tt>x&le;y &#x2227; y&le;x &rArr; x=y</tt>. 
What we really want is a strict total order: a relation <tt>&lt;</tt> is a strict total order if it's total, transitive, and 
antisymmetric in the sense that exactly one of <tt>x&lt;y</tt>, <tt>y&lt;x</tt>, and <tt>x=y</tt> holds.
</p>
<p>
The non-normative note in 25.5 [alg.sorting]/4 correctly uses the phrase "strict total ordering" rather than 
simply "total ordering".
</p>
<p>
We could address this issue by replacing "total order" with "strict total order" everywhere it appears, since I 
think there are no cases where we actually want a non-strict total order, or we could add something in Clause 17 saying 
that we always mean strict total order whenever we say total order.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2548" href="#2548">2548.</a> Missing <tt>vfscanf</tt> from <tt>&lt;cstdio&gt;</tt></h3>
<p><b>Section:</b> 27.11 [c.files] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Richard Smith  <b>Opened:</b> 2015-10-09 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#c.files">issues</a> in [c.files].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
C's <tt>vfscanf</tt> function is not present in C++'s <tt>&lt;cstdio&gt;</tt>, and presumably should be. 
It looks like this is the only missing member of C's <tt>[v]{f,s,sn}[w]{printf,scanf}</tt> family.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Resolved by P0175R1</p>
<p>Thurs AM: Moved to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4527.</p>

<p>Modify Table 133 as follows:</p>
<p>
<tt>ungetc</tt><br/>
<tt>vfprintf</tt><br/>
<ins><tt>vfscanf</tt></ins><br/>
<tt>vprintf</tt><br/>
<tt>vscanf</tt><br/>
</p>





<hr>
<h3><a name="2556" href="#2556">2556.</a> Wide contract for <tt>future::share()</tt></h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2015-11-05 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.unique_future">active issues</a> in [futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>future::share()</tt> is not <tt>noexcept</tt>, it has a narrow contact requiring <tt>valid()</tt> as per the blanket 
wording in 30.6.6 [futures.unique_future] p3. Its effects, however, are <tt>return shared_future&lt;R&gt;(std::move(*this))</tt>, 
which is <tt>noexcept</tt> as it has a wide contract. If the source <tt>future</tt> isn't valid then the target 
<tt>shared_future</tt> simply won't be valid either. There appears to be no technical reason preventing <tt>future::share()</tt> 
from having a wide contract, and thus being <tt>noexcept</tt>.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 30.6.6 [futures.unique_future] as indicated:</p>

<blockquote>
<p>
-3- The effect of calling any member function other than the destructor, the move-assignment operator, <ins><tt>share</tt>,</ins> 
or <tt>valid</tt> on a <tt>future</tt> object for which <tt>valid() == false</tt> is undefined. [<i>Note</i>: Implementations 
are encouraged to detect this case and throw an object of type <tt>future_error</tt> with an error condition of 
<tt>future_errc::no_state</tt>. &mdash; <i>end note</i>]
</p>
<blockquote><pre>
namespace std {
  template &lt;class R&gt;
  class future {
  public:
    [&hellip;]
    shared_future&lt;R&gt; share() <ins>noexcept</ins>;
    [&hellip;]
  };
}
</pre></blockquote>
<p>
[&hellip;]
</p>
<pre>
shared_future&lt;R&gt; share() <ins>noexcept</ins>;
</pre>
<blockquote>
<p>
-12- <i>Returns</i>: <tt>shared_future&lt;R&gt;(std::move(*this))</tt>.
<p/>
-13- <i>Postcondition</i>: <tt>valid() == false</tt>.
</p>
</blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2561" href="#2561">2561.</a> [fund.ts.v2] Incorrect exception specifications for 'swap' in C++ Extensions for Library Fundamentals</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object.swap], 99 [fund.ts.v2::propagate_const.modifiers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2015-11-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
As pointed out in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4511.html#Related_Issues">N4511</a>,
the Library fundamentals are affected by a similar problem as described in LWG <a href="lwg-defects.html#2456">2456</a>. First, it is caused
by <tt>optional</tt>'s member <tt>swap</tt> (99 [optional.object.swap]):
</p>
<blockquote><pre>
void swap(optional&lt;T&gt;&amp; rhs) noexcept(<i>see below</i>);
</pre></blockquote>
<p>
with 
</p>
<blockquote>
<p>
The expression inside <tt>noexcept</tt> is equivalent to: 
</p>
<blockquote><pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))
</pre></blockquote>
</blockquote>
<p>
Again, the unqualified lookup for <tt>swap</tt> finds the member <tt>swap</tt> instead of the result of a normal argument-depending 
lookup, making this ill-formed.
<p/>
A second example of such a problem recently entered the arena with the addition of the <tt>propagate_const</tt> template
with another member <tt>swap</tt> (99 [propagate_const.modifiers]):
</p>
<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- The constant-expression in the exception-specification is <tt>noexcept(swap(t_, pt.t_))</tt>.
</p>
</blockquote>
</blockquote>
<p>
A working approach is presented in 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4511.html#Proposed_resolution">N4511</a>. By adding a new
trait to the standard library and referencing this by the library fundamentals (A similar approach had been applied in the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3940.html#path-inserter-extractor">file system specification</a>
where the <tt>quoted</tt> manipulator from C++14 had been referred to, albeit the file system specification is generally based on the
C++11 standard), <tt>optional</tt>'s member <tt>swap</tt> exception specification could be rephrased as follows:
</p>
<blockquote>
<p>
The expression inside <tt>noexcept</tt> is equivalent to: 
</p>
<blockquote><pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; <ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</del>
</pre></blockquote>
</blockquote>
<p>
and <tt>propagate_const</tt>'s member <tt>swap</tt> exception specification could be rephrased as follows:
</p>
<blockquote>
<pre>
constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-2- The constant-expression in the exception-specification is <tt><ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(t_, pt.t_))</del></tt>.
</p>
</blockquote>
</blockquote>

<p><i>[2016-02-20, Ville comments]</i></p>

<p>
Feedback from an implementation:
<p/>
libstdc++ already applies the proposed resolution for <tt>propagate_const</tt>,
but not for <tt>optional</tt>.
</p>

<p><i>[2016-02-20, Daniel comments]</i></p>

<p>
A recent paper update has been provided: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0185r0.html#Proposed_resolution">P0185R0</a>.
</p>

<p><i>[2016-03, Jacksonville]</i></p>

Add a link to <a href="lwg-defects.html#2456">2456</a>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2562" href="#2562">2562.</a> Consistent total ordering of pointers by comparison functors</h3>
<p><b>Section:</b> 20.14.6 [comparisons] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2015-11-18 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#comparisons">active issues</a> in [comparisons].</p>
<p><b>View all other</b> <a href="lwg-index.html#comparisons">issues</a> in [comparisons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4567 20.14.6 [comparisons]/14 specifies that the comparison functors provide a total ordering for pointer types:
</p>
<blockquote><p>
For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the specializations for 
any pointer type yield a total order, even if the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, <tt>&gt;=</tt> 
do not.
</p></blockquote>
<p>
It notably does not specify:
</p>
<ul>
<li><p>whether the specializations of all of the named templates for a given pointer type yield the <em>same</em> total order</p></li>
<li><p>whether the total order imposed respects the partial order imposed by the built-in operators</p></li>
<li><p>whether the total order imposed is consistent with the partition induced by <tt>==</tt></p></li>
</ul>
<p>
All of which are important for sane semantics and provided by common implementations, since the built-in operators provide 
a total order and the comparison functors yield that same order.
<p/>
It would be extremely confusing &mdash; if not outright insane &mdash; for e.g.:
</p>
<ul>
<li><p><tt>less&lt;int*&gt;</tt> and <tt>greater&lt;int*&gt;</tt> to yield different orders</p></li>
<li><p><tt>less&lt;int*&gt;</tt> to disagree with <tt>&lt;</tt> on the relative order of two pointers for which <tt>&lt;</tt> 
is defined</p></li>
<li><p><tt>less&lt;int*&gt;</tt> to order <tt>a</tt> before <tt>b</tt> when <tt>a == b</tt>, i.e., not preserve equality.</p></li>
</ul>
<p>
Consistent semantics for the various comparison functors and the built-in operators is so intuitive as to be assumed by most programmers.
<p/>
Related issues: <a href="lwg-defects.html#2450">2450</a>, <a href="lwg-active.html#2547">2547</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Alter 20.14.6 [comparisons]/14 to read:</p>
<blockquote><p>
For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the specializations for any pointer type
yield <del>a</del><ins>the same</ins> total order, even if the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, 
<tt>&gt;=</tt> do not. <ins>The total order shall respect the partial order imposed by the built-in operators.</ins>
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-05-20, Casey Carter comments and suggests revised wording]</i></p>

<p>
The new proposed wording is attempting to address the issue raised in the 2016-02-04 telecon.
<p/>
The real issue I'm trying to address here is ensure that "weird" implementations provide the same kind of consistency 
for pointer orderings as "normal" implementations that use a flat address spaces and have totally ordered <tt>&lt;</tt>. 
If <tt>a &lt; b</tt> is true for <tt>int</tt> pointers <tt>a</tt> and <tt>b</tt>, then <tt>less&lt;int*&gt;(a, b)</tt>, 
<tt>less_equal&lt;int*&gt;(a, b)</tt>, <tt>less&lt;char*&gt;(a, b)</tt>, <tt>less&lt;void*&gt;(a, b)</tt>, and 
<tt>greater&lt;int*&gt;(b, a)</tt> should all hold. I <em>think</em> this wording is sufficient to provide that.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>

<ol>
<li><p>Alter 20.14.6 [comparisons] to read:</p>
<blockquote><p>
-14- For templates <tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and <tt>less_equal</tt>, the 
specializations for any pointer type yield <del>a</del><ins>the same</ins> total order<ins>. That total order is 
consistent with the partial order imposed by</ins><del>, even if</del> the built-in operators <tt>&lt;</tt>, <tt>&gt;</tt>, 
<tt>&le;</tt>, <ins>and</ins> <tt>&gt;</tt> <del>do not</del>. <ins>[<i>Note</i>: When <tt>a &lt; b</tt> is 
well-defined for pointers <tt>a</tt> and <tt>b</tt> of type <tt>P</tt>, this implies <tt>(a &lt; b) == 
less&lt;P&gt;(a, b)</tt>, <tt>(a &gt; b) == greater&lt;P&gt;(a, b)</tt>, and so forth. &mdash; <i>end note</i>]</ins> 
For template specializations <tt>greater&lt;void&gt;</tt>, <tt>less&lt;void&gt;</tt>, <tt>greater_equal&lt;void&gt;</tt>, 
and <tt>less_equal&lt;void&gt;</tt>, if the call operator calls a built-in operator comparing pointers, the 
call operator yields a total order.
</p></blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-04 Chicago LWG]</i></p>

<p>
LWG discusses and concludes that we are trying to accomplish the following:
</p>
<ol>
<li>
<blockquote><pre>
T* a = /* ... */;
T* b = /* ... */;
</pre></blockquote>
<p>
 if <tt>a &lt; b</tt> is valid, <tt>a &lt; b == less&lt;T*&gt;(a, b)</tt>, and analogously for <tt>&gt;</tt>, 
 <tt>&lt;=</tt>, <tt>&gt;=</tt>.
</p>
</li>
<li>
<blockquote><pre>
less&lt;void&gt;(a, b) == less&lt;T*&gt;(a, b);
less&lt;T*&gt;(a, b) == greater&lt;T*&gt;(b, a);
</pre></blockquote>
<p>
etc.
</p>
</li>
<li><p>
<tt>less&lt;T*&gt;</tt> produces a strict total ordering with which the other three
function objects are consistent
</p></li>
<li><p>
<tt>less&lt;void&gt;</tt> when applied to pointers produces a strict total ordering with
which the other three are consistent
</p></li>
<li><p>
<tt>less&lt;void&gt;</tt> when applied to pointers of the same type produces the same
strict total ordering as <tt>less&lt;T*&gt;</tt>, and analogously for the other three
</p></li>
<li><p>
we are not addressing <tt>less&lt;void&gt;</tt> (and the other three) when applied to
pointers of differing types
</p></li>
</ol>
<p>
Walter and Nevin revise Proposed Wording accordingly.
</p>
<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.14.6 [comparisons] p14 as indicated:</p>
<blockquote><p>
-14- For templates <del><tt>greater</tt>, <tt>less</tt>, <tt>greater_equal</tt>, and 
<tt>less_equal</tt></del><ins><ins><tt>less</tt>, <tt>greater</tt>, <tt>less_equal</tt>,
and <tt>greater_equal</tt></ins></ins>, 
the specializations for any pointer type yield a <ins>strict</ins> total order<ins>
that is consistent among those specializations and is also consistent with the partial order imposed by</ins>
<del>, even if</del> the built-in operators 
<tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, <tt>&gt;=</tt> <del>do not</del>. <ins>[<i>Note:</i>
When <tt>a &lt; b</tt> is well-defined for pointers <tt>a</tt> and <tt>b</tt> of type <tt>P</tt>,
this implies <tt>(a &lt; b) == less&lt;P&gt;(a, b)</tt>, <tt>(a &gt; b) == greater&lt;P&gt;(a, b)</tt>,
and so forth. &mdash; <i>end note</i>]</ins> For template specializations 
<del><tt>greater&lt;void&gt;</tt>, <tt>less&lt;void&gt;</tt>, <tt>greater_equal&lt;void&gt;</tt>, and 
<tt>less_equal&lt;void&gt;</tt></del><ins><tt>less&lt;void&gt;</tt>, <tt>greater&lt;void&gt;</tt>,
<tt>less_equal&lt;void&gt;</tt>, and <tt>greater_equal&lt;void&gt;</tt></ins>, if the call operator 
calls a built-in operator comparing pointers, the call operator yields a <ins>strict</ins> total 
order <ins>that is consistent among those specializations and is also consistent
with the partial order imposed by those built-in operators</ins>.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2563" href="#2563">2563.</a> LWG 2259 relaxes requirements, perhaps unintentionally</h3>
<p><b>Section:</b> 17.6.5.5 [member.functions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2015-11-29 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#member.functions">active issues</a> in [member.functions].</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in [member.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The combination of 17.6.5.5 [member.functions], paragraphs 2 and 3 that LWG 
<a href="lwg-defects.html#2259">2259</a> does seems to drop a requirement that any call behaves as if 
no overloads were added. Paragraph 3 used to say
"A call to a member function signature described in the C ++ standard
library behaves as if the implementation
declares no additional member function signatures."
whereas the new wording says
"provided that any call to the member function that would select an
overload from the set of declarations described in this standard
behaves as if that overload were selected."
<p/>
This can be read as meaning that if there's no default constructor
specified, like for instance for <tt>std::ostream</tt>, an implementation is free to
add it. It can also be read as meaning that an implementation is free to
add any overloads that wouldn't change the overload resolution result
of any call expression that would select a specified overload. That's
vastly different from allowing extensions that add new functions rather
than new overloads.
<p/>
Was this relaxation intentional?
</p>
<p><i>[2016-04, Issues Telecon]</i></p>

<p>
Ville provides a motivating example.
</p>

<p>
<blockquote>
<pre>
#include &lt;iostream&gt;

class my_stream : std::ostream
{
};

int main()
{
    my_stream ms;
}
</pre>
</blockquote>
</p>

<p>This example is accepted by libstdc++, msvc rejects it, and clang+libc++
segfault on melpon.org/wandbox o_O. An earlier clang+libc++ just accepts
it. I don't think the implementation divergence is caused by the acceptance
of the referred-to <a href="lwg-defects.html#2259">2259</a>, but it certainly seems to increasingly bless
the implementation divergence.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This is related to issue <a href="lwg-active.html#2695">2695</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2564" href="#2564">2564.</a> [fund.ts.v2] <tt>std::experimental::function</tt> constructors taking allocator arguments may throw exceptions</h3>
<p><b>Section:</b> 99 [fund.ts.v2::func.wrap.func] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song  <b>Opened:</b> 2015-12-05 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::func.wrap.func">active issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::func.wrap.func">issues</a> in [fund.ts.v2::func.wrap.func].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
[This is essentially LWG <a href="lwg-active.html#2370">2370</a>, but deals with the fundamentals TS version rather than the one in the standard]
<p/>
In 99 [func.wrap.func] of library fundamentals TS, the constructors
</p>
<blockquote><pre>
template&lt;class A&gt; function(allocator_arg_t, const A&amp;) noexcept;
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, nullptr_t) noexcept;
</pre></blockquote>
<p>
must type-erase and store the provided allocator, since the <tt>operator=</tt> specification requires using the "allocator 
specified in the construction of" the <tt>std::experimental::function</tt> object. This may require a dynamic allocation 
and so cannot be noexcept. Similarly, the following constructors
</p>
<blockquote><pre>
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, const function&amp;); 
template&lt;class A&gt; function(allocator_arg_t, const A&amp;, function&amp;&amp;);
template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp;, F);
</pre></blockquote>
<p>
cannot satisfy the C++14 requirement that they "shall not throw exceptions if [the <tt>function</tt> object to be stored] 
is a callable object passed via <tt>reference_wrapper</tt> or a function pointer" if they need to type-erase and store the 
allocator.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>.
</p>

<ol>
<li><p> Edit 99 [func.wrap.func], class template <tt>function</tt> synopsis, as follows:</p>

<blockquote>
<pre>
namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    [&hellip;]

    template&lt;class R, class... ArgTypes&gt;
    class function&lt;R(ArgTypes...)> {
    public:    
      [&hellip;]
      template&lt;class A> function(allocator_arg_t, const A&amp;) <del>noexcept</del>;
      template&lt;class A> function(allocator_arg_t, const A&amp;,
        nullptr_t) <del>noexcept</del>;
      [&hellip;]
    };

    [&hellip;]

  } // namespace fundamentals_v2
  } // namespace experimental

  [&hellip;]

} // namespace std
</pre>
</blockquote>
</li>

<li><p>Insert the following paragraphs after 99 [func.wrap.func.con]/1:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: This just reproduces the wording from C++14 with the "shall not throw exceptions for 
<tt>reference_wrapper</tt>/function pointer" provision deleted. &mdash; <i>end drafting note</i>]
</p>
</blockquote>

<blockquote>
<p>
-1- When a <tt>function</tt> constructor that takes a first argument of type <tt>allocator_arg_t</tt> is invoked, 
the second argument is treated as a <em>type-erased allocator</em> (8.3). If the constructor moves or makes a copy 
of a function object (C++14 &sect;20.9), including an instance of the <tt>experimental::function</tt> class template, 
then that move or copy is performed by <em>using-allocator construction</em> with allocator <tt>get_memory_resource()</tt>. 
</p>
<blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a);
template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, nullptr_t);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Postconditions</i>: <tt>!*this</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, const function&amp; f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Postconditions</i>: <tt>!*this if !f</tt>; otherwise, <tt>*this</tt> targets a copy of <tt>f.target()</tt>.</ins>
<p/>
<ins>-?- <i>Throws</i>: May throw <tt>bad_alloc</tt> or any exception thrown by the copy constructor of the stored callable object. 
[<i>Note</i>: Implementations are encouraged to avoid the use of dynamically allocated memory for small callable objects, 
for example, where <tt>f</tt>'s target is an object holding only a pointer or reference to an object and a member function pointer. 
&mdash; <i>end note</i>]</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class A&gt; function(allocator_arg_t, const A&amp; a, function&amp;&amp; f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- Effects: If <tt>!f</tt>, <tt>*this</tt> has no target; otherwise, move-constructs the target of <tt>f</tt> into the 
target of <tt>*this</tt>, leaving <tt>f</tt> in a valid state with an unspecified value.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>F</tt> shall be <tt>CopyConstructible</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution unless <tt>f</tt> is Callable 
(C++14 &sect;20.9.11.2) for argument types <tt>ArgTypes...</tt> and return type <tt>R</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>!*this</tt> if any of the following hold:</ins>
<ul>
<li><p><ins><tt>f</tt> is a null function pointer value.</ins></p></li>
<li><p><ins><tt>f</tt> is a null member pointer value.</ins></p></li>
<li><p><ins><tt>F</tt> is an instance of the <tt>function</tt> class template, and <tt>!f</tt>.</ins></p></li>
</ul>
<p/>
<ins>-?- Otherwise, <tt>*this</tt> targets a copy of <tt>f</tt> initialized with <tt>std::move(f)</tt>. [<i>Note</i>: 
Implementations are encouraged to avoid the use of dynamically allocated memory for small callable objects, for example, 
where <tt>f</tt>'s target is an object holding only a pointer or reference to an object and a member function pointer. &mdash; 
<i>end note</i>]</ins>
<p/>
<ins>-?- <i>Throws</i>: May throw <tt>bad_alloc</tt> or any exception thrown by <tt>F</tt>'s copy or move constructor.</ins>
</p>
</blockquote>
</blockquote>
<p>
-2- In the following descriptions, let <tt><i>ALLOCATOR_OF</i>(f)</tt> be the allocator specified in the construction 
of <tt>function f</tt>, or <tt>allocator&lt;char&gt;()</tt> if no allocator was specified.
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2567" href="#2567">2567.</a> Specification of logical operator traits uses <tt>BaseCharacteristic</tt>, which is defined only for <tt>UnaryTypeTraits</tt> 
and <tt>BinaryTypeTraits</tt></h3>
<p><b>Section:</b> 20.15.8 [meta.logical] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-10 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.logical">active issues</a> in [meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.logical">issues</a> in [meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> uses the term <tt>BaseCharacteristic</tt>, which 
is problematic in several ways:
</p>
<ul>
<li><p>That term is defined in 20.15.1 [meta.rqmts], but only for <tt>UnaryTypeTraits</tt> and <tt>BinaryTypeTraits</tt>. 
<tt>conjunction</tt> and <tt>disjunction</tt> seem to be neither.</p></li>
<li><p>20.15.1 [meta.rqmts] also requires the <tt>BaseCharacteristic</tt> for both <tt>UnaryTypeTraits</tt> and 
<tt>BinaryTypeTraits</tt> to be a specialization of <tt>integral_constant</tt>, which is inconsistent with the current design of 
<tt>conjunction</tt> and <tt>disjunction</tt>.</p></li>
<li><p>The requirement in 20.15.1 [meta.rqmts] that "member names of the <tt>BaseCharacteristic</tt> shall not be hidden 
and shall be unambiguously available" seems impossible to meet in every case, since the arbitrary base class from which a 
specialization of <tt>conjunction</tt> or <tt>disjunction</tt> derives may contain members called <tt>conjunction</tt> or 
<tt>disjunction</tt> that will necessarily be hidden.</p></li>
</ul>
<p><i>[2016-08 Chicago]</i></p>

<p>Ville provided wording for both <a href="lwg-active.html#2567">2567</a> and <a href="lwg-active.html#2568">2568</a></p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>In [meta.logical]/3, edit as follows:</p>

<p>The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that</ins>
is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or if every <tt>Bi::value != false</tt>, the
<ins>aforementioned base</ins><del>BaseCharacteristic</del> is
the last type in the list.
[ Note: This means a specialization of conjunction does
not necessarily <del>have a BaseCharacteristic
of</del> <ins>derive from</ins> either true_type or
false_type.  end note ]</p>

<p>In [meta.logical]/6, edit as follows:</p>

<p>The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that</ins>
is the first type <tt>Bi</tt> in the list <tt>false_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or if every <tt>Bi::value == false</tt>, the
<ins>aforementioned base</ins><del>BaseCharacteristic</del> is
the last type in the list.
[ Note: This means a specialization of disjunction does
not necessarily <del>have a BaseCharacteristic
of</del> <ins>derive from</ins> either true_type or
false_type.  end note ]</p>
</blockquote>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>In [meta.logical]/3, edit as follows:</p>

<p>The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either<br/>
* the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or<br/>
* if there is no such <tt>Bi</tt>, the last type in the list.</ins><br/>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or if every <tt>Bi::value != false</tt>, the
BaseCharacteristic is the last type in the list.</del><br/>
[ Note: This means a specialization of <tt>conjunction</tt> does
not necessarily <del>have a BaseCharacteristic
of</del> <ins>derive from</ins> either true_type or
false_type.  end note ]</p>

<p>In [meta.logical]/6, edit as follows:</p>
<p>The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either<br/>
* the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or<br/>
* if there is no such <tt>Bi</tt>, the last type in the list.</ins><br/>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or if every <tt>Bi::value == false</tt>, the
BaseCharacteristic is the last type in the list.</del><br/>
[ Note: This means a specialization of <tt>disjunction</tt> does
not necessarily <del>have a BaseCharacteristic
of</del> <ins>derive from</ins> either true_type or
false_type.  end note ]</p></blockquote>

Merged the resolution of <a href="lwg-active.html#2587">2587</a> with this issue. This proposed resolution
resolves both, and includes fixes from Daniel for negation.

Last review of this with LWG turned up a true_type typo in the definition of disjunction, and some editorial changes.
<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>
<ol>
<li>
<p>In 20.15.8 [meta.logical] p3, edit as follows:</p>
<pre>
template&lt;class... B&gt; struct conjunction : <em>see below</em> { };
</pre>
<blockquote>
<p>-3- The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins>
<ul>
<li><ins>the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>bool(Bi::value)</tt> is <tt>false</tt>, or</ins></li>
<li><ins>if there is no such <tt>Bi</tt>, the last type in the list.</ins></li>
</ul>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or if every <tt>Bi::value != false</tt>, the
BaseCharacteristic is the last type in the list.</del></p>
<p><ins>-?- The member names of the base class, other than <tt>conjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>conjunction</tt>. [<em>Note: </em>
This means a specialization of <tt>conjunction</tt> does not necessarily <del>have a BaseCharacteristic
of</del> <ins>inherit from</ins> either <tt>true_type</tt> or <tt>false_type</tt>.
&mdash;<em>end note</em>]</ins></p>
</blockquote>
</li>

<li>
<p>In 20.15.8 [meta.logical] p6, edit as follows:</p>
<pre>
template&lt;class... B&gt; struct disjunction : <em>see below</em> { };
</pre>
<blockquote>
<p>-6- The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins>
<ul>
<li><ins>the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>bool(Bi::value)</tt> is <tt>true</tt>, or,</ins></li>
<li><ins>if there is no such <tt>Bi</tt>, the last type in the list.</ins></li>
</ul>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or if every <tt>Bi::value == false</tt>, the
BaseCharacteristic is the last type in the list.</del></p>
<p><ins>-?- The member names of the base class, other than <tt>disjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>disjunction</tt>. [<em>Note: </em>This
means a specialization of <tt>disjunction</tt> does not necessarily <del>have a BaseCharacteristic
of</del> <ins>inherit from</ins> either <tt>true_type</tt> or <tt>false_type</tt>.
&mdash;<em>end note</em>]</ins></p>
</blockquote>
</li>

<li>
<p>In 20.15.8 [meta.logical] p8, edit as follows</p>
<pre>
template&lt;class B&gt; struct negation : bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt; { };
</pre>
<blockquote>
<p>
-8- The class template negation forms the logical negation of its template type argument. The type
<tt>negation&lt;B&gt;</tt> is a UnaryTypeTrait with a BaseCharacteristic of
<tt>bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt;</tt>.
</p>
</blockquote>
</li>
</ol>
</blockquote>
<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li>
<p>In 20.15.8 [meta.logical] p3, edit as follows:</p>
<pre>
template&lt;class... B&gt; struct conjunction : <em>see below</em> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>-3- The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins>
<ol style="list-style-type:none">
<li>&mdash; <ins>the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>bool(Bi::value)</tt> is <tt>false</tt>, or</ins></li>
<li>&mdash; <ins>if there is no such <tt>Bi</tt>, the last type in the list.</ins></li>
</ol>
<del>is the first type <tt>Bi</tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>Bi::value == false</tt>, or if every <tt>Bi::value != false</tt>, the
BaseCharacteristic is the last type in the list.</del>[<em>Note: </em>
This means a specialization of <tt>conjunction</tt> does not necessarily <del>have a BaseCharacteristic
of</del> <ins>inherit from</ins> either <tt>true_type</tt> or <tt>false_type</tt>.
&mdash;<em>end note</em>]</p>
<p><ins>-?- The member names of the base class, other than <tt>conjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>conjunction</tt>.</ins></p>
</blockquote>
</li>

<li>
<p>In 20.15.8 [meta.logical] p6, edit as follows:</p>
<pre>
template&lt;class... B&gt; struct disjunction : <em>see below</em> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>-6- The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins>
<ol style="list-style-type:none">
<li>&mdash; <ins>the first type <tt>Bi</tt> in the list <tt>false_type, B1, ..., BN</tt> for
which <tt>bool(Bi::value)</tt> is <tt>true</tt>, or,</ins></li>
<li>&mdash; <ins>if there is no such <tt>Bi</tt>, the last type in the list.</ins></li>
</ol>
<del>is the first type <tt>Bi</tt> in the list <tt>false_type, B1, ..., BN</tt> for
which <tt>Bi::value != false</tt>, or if every <tt>Bi::value == false</tt>, the
BaseCharacteristic is the last type in the list.</del>[<em>Note: </em>This
means a specialization of <tt>disjunction</tt> does not necessarily <del>have a BaseCharacteristic
of</del> <ins>inherit from</ins> either <tt>true_type</tt> or <tt>false_type</tt>.
&mdash;<em>end note</em>]</p>
<p><ins>-?- The member names of the base class, other than <tt>disjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>disjunction</tt>.</ins></p>
</blockquote>
</li>

<li>
<p>In 20.15.8 [meta.logical] p8, edit as follows</p>
<pre>
template&lt;class B&gt; struct negation : <ins><em>see below</em></ins><del><tt>bool_constant&lt;!B::value&gt;</tt></del> { };
</pre>
<blockquote>
<p>
-8- The class template negation forms the logical negation of its template type argument. The type
<tt>negation&lt;B&gt;</tt> is a UnaryTypeTrait with a BaseCharacteristic of
<tt>bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt;</tt>.
</p>
</blockquote>
</li>
</ol>




<hr>
<h3><a name="2568" href="#2568">2568.</a> [fund.ts.v2] Specification of logical operator traits uses <tt>BaseCharacteristic</tt>, which is defined only for 
<tt>UnaryTypeTraits</tt> and <tt>BinaryTypeTraits</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::meta.logical] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-10 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::meta.logical">active issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::meta.logical">issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> uses the term <tt>BaseCharacteristic</tt>, which 
is problematic in several ways:
</p>
<ul>
<li><p>That term is defined in 20.15.1 [meta.rqmts], but only for <tt>UnaryTypeTraits</tt> and <tt>BinaryTypeTraits</tt>. 
<tt>conjunction</tt> and <tt>disjunction</tt> seem to be neither.</p></li>
<li><p>20.15.1 [meta.rqmts] also requires the <tt>BaseCharacteristic</tt> for both <tt>UnaryTypeTraits</tt> and 
<tt>BinaryTypeTraits</tt> to be a specialization of <tt>integral_constant</tt>, which is inconsistent with the current design of 
<tt>conjunction</tt> and <tt>disjunction</tt>.</p></li>
<li><p>The requirement in 20.15.1 [meta.rqmts] that "member names of the <tt>BaseCharacteristic</tt> shall not be hidden 
and shall be unambiguously available" seems impossible to meet in every case, since the arbitrary base class from which a 
specialization of <tt>conjunction</tt> or <tt>disjunction</tt> derives may contain members called <tt>conjunction</tt> or 
<tt>disjunction</tt> that will necessarily be hidden.</p></li>
</ul>

<p><i>[2016-08 Chicago]</i></p>

<p>
Ville provided wording for both <a href="lwg-active.html#2567">2567</a> and <a href="lwg-active.html#2568">2568</a>.
</p>

<p><i>[2016-08-07 Daniel provides wording borrowed from <a href="lwg-active.html#2567">2567</a>]</i></p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://wg21.link/n4600">N4600</a>.</p>

<ol>
<li><p>In 99 [meta.logical] p3, edit as follows:</p>

<blockquote>
<pre>
template&lt;class... B&gt; struct conjunction : <i>see below</i> { };
</pre>
<blockquote>
<p>
-2- The class template <code>conjunction</code> forms the logical conjunction of its template type arguments. 
Every template type argument shall be usable as a base class and shall have a static data member <code>value</code> 
which is convertible to <code>bool</code>, is not hidden, and is unambiguously available in the type.
<p/>
-3- The <del>BaseCharacteristic of a</del> specialization <tt>conjunction&lt;B1, &hellip;, BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins> 
</p>
<ol style="list-style-type:none">
<li>&mdash; <ins>the first type <tt>B<i>i</i></tt> in the list <tt>true_type, B1, ..., BN</tt> for
which <tt>bool(B<i>i</i>::value)</tt> is <tt>false</tt>, or</ins></li>
<li>&mdash; <ins>if there is no such <tt>B<i>i</i></tt>, the last type in the list.</ins></li>
</ol>
<p>
<del>is the first type <code>B</code> in the list <code>true_type, B1, &hellip;, BN</code> for which 
<code>B::value == false</code>, or if <code>every B::value != false</code> the BaseCharacteristic is the last type 
in the list.</del> [<i>Note:</i> This means a specialization of conjunction does not necessarily <del>have a 
BaseCharacteristic of</del><ins>inherit from</ins> either <code>true_type</code> or <code>false_type</code>. 
&mdash; <i>end note</i>]
<p/>
<ins>-?- The member names of the base class, other than <tt>conjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>conjunction</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 99 [meta.logical] p6, edit as follows:</p>

<blockquote>
<pre>
template&lt;class... B&gt; struct disjunction : <i>see below</i> { };
</pre>
<blockquote>
<p>
-5- The class template <code>disjunction</code> forms the logical disjunction of its template type arguments. 
Every template type argument shall be usable as a base class and shall have a static data member <code>value</code> 
which is convertible to <code>bool</code>, is not hidden, and is unambiguously available in the type.
<p/>
-6- The <del>BaseCharacteristic of a</del> specialization <tt>disjunction&lt;B1, &hellip;, BN&gt;</tt>
<ins>has a public and unambiguous base that is either</ins> 
</p>
<ol style="list-style-type:none">
<li>&mdash; <ins>the first type <tt>B<i>i</i></tt> in the list <tt>false_type, B1, ..., BN</tt> for
which <tt>bool(B<i>i</i>::value)</tt> is <tt>true</tt>, or,</ins></li>
<li>&mdash; <ins>if there is no such <tt>B<i>i</i></tt>, the last type in the list.</ins></li>
</ol>
<p>
<del>is the first type <code>B</code> in the list <code>false_type, B1, &hellip;, BN</code> for which 
<code>B::value != false</code>, or if <code>every B::value == false</code> the BaseCharacteristic is the last type 
in the list.</del> [<i>Note:</i> This means a specialization of disjunction does not necessarily <del>have a 
BaseCharacteristic of</del><ins>inherit from</ins> either <code>true_type</code> or <code>false_type</code>. 
&mdash; <i>end note</i>]
<p/>
<ins>-?- The member names of the base class, other than <tt>disjunction</tt> and <tt>operator=</tt>,
shall not be hidden and shall be unambiguously available in <tt>disjunction</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 99 [meta.logical] p8, edit as follows:</p>

<blockquote>
<pre>
template&lt;class B&gt; struct negation : <del>integral_constant&lt;bool, !B::value&gt;</del><ins><i>see below</i></ins> { };
</pre>
<blockquote>
<p>
-8- The class template <code>negation</code> forms the logical negation of its template type argument. The type 
<code>negation&lt;B&gt;</code> is a UnaryTypeTrait with a BaseCharacteristic of <code>integral_constant&lt;bool, 
!<ins>bool(</ins>B::value<ins>)</ins>&gt;</code>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2569" href="#2569">2569.</a> <tt>conjunction</tt> and <tt>disjunction</tt> requirements are too strict</h3>
<p><b>Section:</b> 20.15.8 [meta.logical] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-11 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.logical">active issues</a> in [meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.logical">issues</a> in [meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.15.8 [meta.logical]/2 and /5 impose the following requirement on the arguments of <tt>conjunction</tt> and <tt>disjunction</tt>:
</p>
<blockquote><p>
Every template type argument shall be usable as a base class and shall have a static data member value which is convertible to 
<tt>bool</tt>, is not hidden, and is unambiguously available in the type.
</p></blockquote>
<p>
Since the requirement is unconditional, it applies even to type arguments whose instantiation is not required due to short circuiting. 
This seems contrary to the design intent, expressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a>, 
that it is valid to write <tt>conjunction_v&lt;is_class&lt;T&gt;, is_foo&lt;T&gt;&gt;</tt> even if instantiating 
<tt>is_foo&lt;T&gt;::value</tt> is ill-formed for non-class types.
</p>
<p><i>[2016-08 Chicago]</i></p>

<p>Ville provided wording for both <a href="lwg-active.html#2569">2569</a> and <a href="lwg-active.html#2570">2570</a>.</p>
<p>Tuesday AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p><i>[We recommend applying the proposed resolution for LWG issues 2567 and 2568 before this
proposed resolution, lest the poor editor gets confused.]</i></p>


<p>In [meta.logical],</p>

<p>- insert a new paragraph before paragraph 2:</p>

<p><ins>The class template <tt>conjunction</tt> forms the logical conjunction of its
template type arguments.</ins></p>

<p>- move paragraph 4 before paragraph 2, and edit
paragraph 2 as follows:</p>

<p><del>The class template <tt>conjunction</tt> forms the logical conjunction of its
template type arguments.</del>
Every template type argument <ins>for which <tt>Bi::value</tt> is instantiated</ins>
shall be usable as a base class and shall have a member value which is
convertible to <tt>bool</tt>, is not hidden, and is unambiguously available in the type.</p>

<p>- insert a new paragraph before paragraph 5:</p>

<p><ins>The class template <tt>disjunction</tt> forms the logical disjunction
of its template type arguments.</ins></p>

<p>- move paragraph 7 before paragraph 5, and edit
paragraph 5 as follows:</p>

<p><del>The class template <tt>disjunction</tt> forms the logical disjunction
of its template type arguments.</del>
Every template type argument <ins>for which <tt>Bi::value</tt> is instantiated</ins>
shall be usable as a base class and shall have a member value which is
convertible to <tt>bool</tt>, is not hidden, and is unambiguously available in the type.</p>





<hr>
<h3><a name="2570" href="#2570">2570.</a> [fund.ts.v2] <tt>conjunction</tt> and <tt>disjunction</tt> requirements are too strict</h3>
<p><b>Section:</b> 99 [fund.ts.v2::meta.logical] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2015-12-11 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::meta.logical">active issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::meta.logical">issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
99 [meta.logical]/2 and /5 impose the following requirement on the arguments of <tt>conjunction</tt> and <tt>disjunction</tt>:
</p>
<blockquote><p>
Every template type argument shall be usable as a base class and shall have a static data member value which is convertible to 
<tt>bool</tt>, is not hidden, and is unambiguously available in the type.
</p></blockquote>
<p>
Since the requirement is unconditional, it applies even to type arguments whose instantiation is not required due to short circuiting. 
This seems contrary to the design intent, expressed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0013r1.html">P0013R1</a>, 
that it is valid to write <tt>conjunction_v&lt;is_class&lt;T&gt;, is_foo&lt;T&gt;&gt;</tt> even if instantiating 
<tt>is_foo&lt;T&gt;::value</tt> is ill-formed for non-class types.
</p>

<p><i>[2016-06 Oulu]</i></p>

<p>Alisdair has a paper in progress addressing this</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Ville provided wording for both <a href="lwg-active.html#2569">2569</a> and <a href="lwg-active.html#2570">2570</a>.</p>
<p>Tuesday AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2578" href="#2578">2578.</a> Iterator requirements should reference iterator traits</h3>
<p><b>Section:</b> 24.2 [iterator.requirements], 24.4.1 [iterator.traits] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-01-05 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#iterator.requirements">active issues</a> in [iterator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=38504">this reflector discussion</a>
for background.
<p/>
24.2 [iterator.requirements] attempts to establish requirements for iterators,
but 24.4.1 [iterator.traits]/1 establishes further requirements that must be met
in order to author a portable iterator that works with existing implementations.
Failing to meet the requirements of the latter will fail to work in practice.
The former requirements should reference the latter, normatively.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
After [iterator.requirements.general]/5, insert the following new paragraph:

<blockquote>
<p>
<ins>
-?- In addition to the requirements in this sub-clause, the nested <em>typedef-name</em>s specified
in ([iterator.traits]) shall be provided for the iterator type. [<i>Note:</i>
Either the iterator type must provide the <em>typedef-name</em>s directly (in which
case iterator_traits pick them up automatically), or an iterator_traits
specialization must provide them. <i>-end note</i>]
</ins>
</p>
</blockquote>





<hr>
<h3><a name="2584" href="#2584">2584.</a> <tt>&lt;regex&gt;</tt> ECMAScript <tt>IdentityEscape</tt> is ambiguous</h3>
<p><b>Section:</b> 28.13 [re.grammar] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy O'Neal III <b>Opened:</b> 2016-01-13 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.grammar">active issues</a> in [re.grammar].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.grammar">issues</a> in [re.grammar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Stephan and I are seeing differences in implementation for how non-special characters should be handled in the 
<tt>IdentityEscape</tt> part of the ECMAScript grammar. For example:
</p>
<blockquote><pre>
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#ifdef USE_BOOST
#include &lt;boost/regex.hpp&gt;
using namespace boost;
#else
#include &lt;regex&gt;
#endif
using namespace std;

int main() {
  try {
    const regex r("\\z");
    cout &lt;&lt; "Constructed \\z." &lt;&lt; endl;
    if (regex_match("z", r))
      cout &lt;&lt; "Matches z" &lt;&lt; endl;
  } catch (const regex_error&amp; e) {
      cout &lt;&lt; e.what() &lt;&lt; endl;
  }
}
</pre></blockquote>
<p>
libstdc++, boost, and browsers I tested with (Microsoft Edge, Google Chrome) all happily interpret <tt>\z</tt>, which 
otherwise has no meaning, as an identity character escape for the letter <tt>z</tt>.
libc++ and msvc++ say that this is invalid, and throw <tt>regex_error</tt> with <tt>error_escape</tt>.
<p/>
ECMAScript 3 (which is what C++ currently points to) seems to agree with libc++ and msvc++:
</p>
<blockquote>
<pre>
IdentityEscape ::
  SourceCharacter <b>but not</b> IdentifierPart

IdentifierPart ::
  IdentifierStart
  UnicodeCombiningMark
  UnicodeDigit
  UnicodeConnectorPunctuation
  \ UnicodeEscapeSequence

IdentifierStart ::
  UnicodeLetter
  $
  _
  \ UnicodeEscapeSequence
</pre>
</blockquote>
<p>
But this doesn't make any sense &mdash; it prohibits things like <tt>\$</tt> which users absolutely need to be able to escape. 
So let's look at ECMAScript 6. I believe this says much the same thing, but updates the spec to better handle Unicode by 
referencing what the Unicode standard says is an identifier character:
</p>
<blockquote>
<pre>
IdentityEscape ::
  SyntaxCharacter
  /
  SourceCharacter <b>but not</b> UnicodeIDContinue
  
UnicodeIDContinue ::
  any Unicode code point with the Unicode property "ID_Continue", "Other_ID_Continue", or "Other_ID_Start"
</pre>
</blockquote>
<p>
However, ECMAScript 6 has an appendix B defining "additional features for web browsers" which says:
</p>
<blockquote>
<pre>
IdentityEscape ::
  SourceCharacter <b>but not</b> c
</pre>
</blockquote>
<p>
which appears to agree with what libstdc++, boost, and browsers are doing.
<p/>
What should be the correct behavior here?
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Move to tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 28.13 [re.grammar]/3 as indicated:</p>

<blockquote>
<p>
-3- The following productions within the ECMAScript grammar are modified as follows:
</p>
<blockquote><pre>
ClassAtom ::
  -
  ClassAtomNoDash
  ClassAtomExClass
  ClassAtomCollatingElement
  ClassAtomEquivalence
  
<ins>IdentityEscape ::
  SourceCharacter <b>but not</b> c</ins>
</pre></blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2587" href="#2587">2587.</a> "Convertible to <tt>bool</tt>" requirement in <tt>conjunction</tt> and <tt>disjunction</tt></h3>
<p><b>Section:</b> 20.15.8 [meta.logical] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-01-18 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.logical">active issues</a> in [meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.logical">issues</a> in [meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> in 20.15.8 [meta.logical] p2 and p5 requires 
<tt>Bi::value</tt> to be convertible to <tt>bool</tt>, but nothing in the specification of the actual behavior of the 
templates, which instead uses the expressions <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt> instead, 
actually requires this conversion.
<p/>
If the intention of this requirement is to allow implementations to pass <tt>Bi::value</tt> directly to <tt>std::conditional</tt>, 
like the sample implementation in P0013R1:
</p>
<blockquote><pre>
template&lt;class B1, class B2&gt;
struct and_&lt;B1, B2&gt; : conditional_t&lt;B1::value, B2, B1&gt; { };
</pre></blockquote>
<p>
then it's insufficient in at least two ways:
</p>
<ol>
<li><p>Nothing in the specification requires the result of comparing <tt>Bi::value</tt> with <tt>false</tt> to be consistent 
with the result of the implicit conversion. This is similar to LWG <a href="lwg-active.html#2114">2114</a>, though I don't think the 
<tt>BooleanTestable</tt> requirements in that issue's P/R covers <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt>.</p></li>
<li><p>More importantly, the above implementation is ill-formed for, e.g., 
<tt>std::conjunction&lt;std::integral_constant&lt;int, 2&gt;, std::integral_constant&lt;int, 4&gt;&gt;</tt>, because converting 2 
to <tt>bool</tt> is a narrowing conversion that is not allowed for non-type template arguments (see 5.20 [expr.const]/4). 
(Note that GCC currently doesn't diagnose this error at all, and Clang doesn't diagnose it inside system headers.) It's not clear 
whether such constructs are intended to be supported, but if they are not, the current wording doesn't prohibit it.</p></li> 
</ol>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Walter, Nevin, and Jason provide initial Proposed Resolution.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>

<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.15.8 [meta.logical] as indicated:</p>

<blockquote>
<pre>
template&lt;class... B&gt; struct conjunction : <i>see below</i> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- The BaseCharacteristic of a specialization <tt>conjunction&lt;B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub>&gt;</tt>
is the first type <tt>B<sub><i>i</i></sub></tt> in the list <tt>true_type, B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub></tt>
for which <tt><del>B<sub><i>i</i></sub>::value == false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>,
or if every <tt><del>B<sub><i>i</i></sub>::value != false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, the
BaseCharacteristic is the last type in the list. [&hellip;]
<p/>
-4- For a specialization <tt>conjunction&lt;B<sub>1</sub>, ..., B<sub><i>N</i></sub>&gt;</tt>, if there is a template
type argument <tt>B<sub><i>i</i></sub></tt> with <tt><del>B<sub><i>i</i></sub>::value ==
false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>, then instantiating [&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... B&gt; struct disjunction : <i>see below</i> { };
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- The BaseCharacteristic of a specialization <tt>disjunction&lt;B<sub><i>1</i></sub>, ..., B<sub><i>N</i></sub>&gt;</tt>
is the first type <tt>B<sub><i>i</i></sub></tt> in the list <tt>false_type, B<sub><i>1</i></sub>, ...,
B<sub><i>N</i></sub></tt> for which <tt><del>B<sub><i>i</i></sub>::value !=
false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, or if every
<tt><del>B<sub><i>i</i></sub>::value == false</del><ins>! bool(B<sub><i>i</i></sub>::value)</ins></tt>, the
BaseCharacteristic is the last type in the list. [&hellip;]
<p/>
-7- For a specialization <tt>disjunction&lt;B1, ..., BN&gt;</tt>, if there is a template type argument <tt>Bi</tt> with
<tt><del>B<sub><i>i</i></sub>::value != false</del><ins>bool(B<sub><i>i</i></sub>::value)</ins></tt>, then instantiating
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class B&gt; struct negation : bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt; { };
</pre>
<blockquote>
<p>
-8- The class template negation forms the logical negation of its template type argument. The type
<tt>negation&lt;B&gt;</tt> is a UnaryTypeTrait with a BaseCharacteristic of
<tt>bool_constant&lt;!<ins>bool(</ins>B::value<ins>)</ins>&gt;</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
The resolution for this issue was combined with the resolution for LWG <a href="lwg-active.html#2567">2567</a>, so <a href="lwg-active.html#2567">2567</a> 
resolves this issue here as well.
</p>





<hr>
<h3><a name="2588" href="#2588">2588.</a> [fund.ts.v2] "Convertible to <tt>bool</tt>" requirement in <tt>conjunction</tt> and <tt>disjunction</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::meta.logical] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-01-18 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fund.ts.v2::meta.logical">active issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::meta.logical">issues</a> in [fund.ts.v2::meta.logical].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
The specification of <tt>conjunction</tt> and <tt>disjunction</tt> in 99 [meta.logical] p2 and p5 requires 
<tt>Bi::value</tt> to be convertible to <tt>bool</tt>, but nothing in the specification of the actual behavior of the 
templates, which instead uses the expressions <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt> instead, 
actually requires this conversion.
<p/>
If the intention of this requirement is to allow implementations to pass <tt>Bi::value</tt> directly to <tt>std::conditional</tt>, 
like the sample implementation in P0013R1:
</p>
<blockquote><pre>
template&lt;class B1, class B2&gt;
struct and_&lt;B1, B2&gt; : conditional_t&lt;B1::value, B2, B1&gt; { };
</pre></blockquote>
<p>
then it's insufficient in at least two ways:
</p>
<ol>
<li><p>Nothing in the specification requires the result of comparing <tt>Bi::value</tt> with <tt>false</tt> to be consistent 
with the result of the implicit conversion. This is similar to LWG <a href="lwg-active.html#2114">2114</a>, though I don't think the 
<tt>BooleanTestable</tt> requirements in that issue's P/R covers <tt>Bi::value == false</tt> and <tt>Bi::value != false</tt>.</p></li>
<li><p>More importantly, the above implementation is ill-formed for, e.g., 
<tt>std::conjunction&lt;std::integral_constant&lt;int, 2&gt;, std::integral_constant&lt;int, 4&gt;&gt;</tt>, because converting 2 
to <tt>bool</tt> is a narrowing conversion that is not allowed for non-type template arguments (see 5.20 [expr.const]/4). 
(Note that GCC currently doesn't diagnose this error at all, and Clang doesn't diagnose it inside system headers.) It's not clear 
whether such constructs are intended to be supported, but if they are not, the current wording doesn't prohibit it.</p></li> 
</ol>


<p><b>Proposed resolution:</b></p>
<p>
The resolution for this issue was combined with the resolution for LWG <a href="lwg-active.html#2568">2568</a>, so <a href="lwg-active.html#2568">2568</a> 
resolves this issue here as well.
</p>





<hr>
<h3><a name="2589" href="#2589">2589.</a> <tt>match_results</tt> can't satisfy the requirements of a container</h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2016-01-24 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results">active issues</a> in [re.results].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4567 28.10 [re.results] p2 mentions
</p>
<blockquote>
<p>
The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specifed in 23.2.3, except that only operations defined for const-qualified sequence
containers are supported.
</p>
</blockquote>
<p>
However, this is impossible because <tt>match_results</tt> has a <tt>operator==</tt> whose semantics differs from the one 
required in Table 95 &mdash; "Container requirements".
<p/>
Table 95 requires that <tt>a == b</tt> is an equivalence relation and means <tt>equal(a.begin(), a.end(), b.begin(), b.end())</tt>. 
But for <tt>match_results</tt>, <tt>a == b</tt> and <tt>equal(a.begin(), a.end(), b.begin(), b.end())</tt> can give different 
results. For example:
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

int main()
{
  std::regex re("a*");
  std::string target("baaab");
  std::smatch a;

  std::regex_search(target, a, re);

  std::string target2("raaau");
  std::smatch b;

  std::regex_search(target2, b, re);

  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; (a == b) &lt;&lt; '\n'; // false
  std::cout &lt;&lt; std::equal(a.begin(), a.end(), b.begin(), b.end()) &lt;&lt; '\n'; // true
}
</pre></blockquote>
<p><i>[2016-02, Issues Telecon]</i></p>

Marshall: The submitter is absolutely right, but the proposed resolution is insufficient. We should avoid "shall", for once.<br/>
Jonathan: This is NAD, because the container comparison functions say "unless otherwise stated", 23.3.1p14 and table 97.<br/>
Ville: wrong, table 95 is relevant for ==.<br/>
Jonathan: good point<br/>

<p>2016-05: Marshall cleans up the wording around the change</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 28.10 [re.results] p2 as indicated:</p>
<blockquote><p>
-2- The class template <tt>match_results</tt> shall satisfy the requirements of an allocator-aware container and of a
sequence container, as specified in 23.2.3, except that only operations defined for const-qualified sequence
containers are supported <ins>and that the semantics of comparison functions are different from those required for a 
container</ins>.
</p></blockquote>
</li>
</ol>
</blockquote>

<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 28.10 [re.results] p2 as indicated:</p>
<blockquote><p>
-2- The class template <tt>match_results</tt> <del>shall satisfy</del><ins>satisfies</ins> the requirements of an allocator-aware container and of a
sequence container, <del>as specified in </del><ins>(</ins>23.2.3<ins>)</ins>, except that only operations defined for const-qualified sequence
containers are supported <ins>and the semantics of comparison functions are different from those required for a 
container</ins>.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2591" href="#2591">2591.</a> <tt>std::function</tt>'s member template <tt>target()</tt> should not lead to undefined behaviour</h3>
<p><b>Section:</b> 20.14.12.2.5 [func.wrap.func.targ] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2016-01-31 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.targ">issues</a> in [func.wrap.func.targ].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This issue is a spin-off of LWG <a href="lwg-defects.html#2393">2393</a>, it solely focuses on the pre-condition of 20.14.12.2.5 [func.wrap.func.targ] p2:
</p>
<blockquote class="note"><p>
<i>Requires</i>: <tt>T</tt> shall be a type that is Callable (20.9.12.2) for parameter types <tt>ArgTypes</tt> and return type
<tt>R</tt>.
</p></blockquote>
<p>
Originally, the author of this issue here had assumed that simply removing the precondition as a side-step of fixing LWG
<a href="lwg-defects.html#2393">2393</a> would be uncontroversial. Discussions on the 
<a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=38356">library reflector</a> indicated that this is not the case, 
although it seemed that there was agreement on removing the undefined behaviour edge-case.
<p/>
There exist basically the following positions:
</p>
<ol>
<li><p>The constraint should be removed completely, the function is considered as having a 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf">wide contract</a>.</p>
</li>
<li><p>The pre-condition should be replaced by a <i>Remarks</i> element, that has the effect of making the code ill-formed,
if <tt>T</tt> is a type that is not Lvalue-Callable (20.9.11.2) for parameter types <tt>ArgTypes</tt> and return type <tt>R</tt>.
Technically this approach is still conforming with a wide contract function, because the definition of this contract form
depends on runtime constraints.</p></li>
</ol>
<p>
Not yet explicitly discussed, but a possible variant of bullet (2) could be:
</p>
<ol start="3">
<li><p>The pre-condition should be replaced by a <i>Remarks</i> element, that has the effect of SFINAE-constraining
this member: "This function shall not participate in overload resolution unless  <tt>T</tt> is a type that is 
Lvalue-Callable (20.9.11.2) for parameter types <tt>ArgTypes</tt> and return type <tt>R</tt>".
</p></li>
</ol>
<p>
The following describes a list of some selected arguments that have been provided for one or the other position
using corresponding list items. Unless explicitly denoted, no difference has been accounted for option (3) over 
option (2).
</p>
<ol>
<li>
<ol style="list-style-type:lower-alpha">
<li>
<p>It reflects existing implementation practice, Visual Studio 2015 SR1, gcc 6 libstdc++, and clang 3.8.0 libc++ do accept 
the following code:</p>
<blockquote><pre>
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
#include "boost/function.hpp"

void foo(int) {}

int main() {
  std::function&lt;void(int)&gt; f(foo);
  std::cout &lt;&lt; f.target&lt;void(*)()&gt;() &lt;&lt; std::endl;
  boost::function&lt;void(int)&gt; f2(foo);
  std::cout &lt;&lt; f2.target&lt;void(*)()&gt;() &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
and consistently output the implementation-specific result for <b>two null pointer</b> values.
</p>
</li>
<li>
<p>
The current
<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/boost/function_base.html">Boost documentation</a>
does not indicate <em>any</em> precondition for calling the <tt>target</tt> function, so it is natural
that programmers would expect similar specification and behaviour for the corresponding standard component.
</p>
</li>
<li>
<p>
There is a consistency argument in regard to the free function template <tt>get_deleter</tt>
</p>
<blockquote><pre>
template&lt;class D, class T&gt; 
D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;
</pre></blockquote>
<p>
This function also does not impose any pre-conditions on its template argument <tt>D</tt>.
</p>
</li>
</ol>
</li>
<li>
<ol style="list-style-type:lower-alpha">
<li>
<p>
Programmers have control over the type they're passing to <tt>target&lt;T&gt;()</tt>. Passing a non-callable type 
can't possibly retrieve a non-null target, so it seems highly likely to be programmer error. Diagnosing that at 
compile time seems highly preferable to allowing this to return null, always, at runtime.
</p>
</li>
<li>
<p>
If <tt>T</tt> is a reference type then the return type <tt>T*</tt> is ill-formed anyway. This implies that one can't 
blindly call <tt>target&lt;T&gt;</tt> without knowing what <tt>T</tt> is.
</p>
</li>
<li>
<p>
It has been pointed out that some real world code, boiling down to
</p>
<blockquote><pre>
void foo() {}

int main() {
  std::function&lt;void()&gt; f = foo;
  if (f.target&lt;decltype(foo)&gt;()) {
    <i>// fast path</i>
  } else {
    <i>// slow path</i>
  }
}
</pre></blockquote>
<p>
had manifested as a performance issue and preparing a patch that made the library <tt>static_assert</tt> in that
case solved this problem (Note that <tt>decltype(foo)</tt> evaluates to <tt>void()</tt>, but a proper argument of
<tt>target()</tt> would have been the function <em>pointer</em> type <tt>void(*)()</tt>, because a function type 
<tt>void()</tt> is not any <i>Callable</i> type).
</p>
</li>
</ol>
</li>
</ol>
<p>
It might be worth adding that if use case (2 c) is indeed an often occurring idiom, it would make sense to consider
to provide an explicit conversion to a function pointer (w/o template parameters that could be provided incorrectly), 
if the <tt>std::function</tt> object at runtime conditions contains a pointer to a real function, e.g.
</p>
<blockquote><pre>
R(*)(ArgTypes...) target_func_ptr() const noexcept;
</pre></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 20.14.12.2.5 [func.wrap.func.targ] p2 as indicated:</p>

<blockquote><pre>
template&lt;class T&gt; T* target() noexcept;
template&lt;class T&gt; const T* target() const noexcept;
</pre>
<blockquote>
<p>
<del>-2- <i>Requires</i>: <tt>T</tt> shall be a type that is <tt>Callable</tt> (20.14.12.2 [func.wrap.func]) for parameter types 
<tt>ArgTypes</tt> and return type <tt>R</tt>.</del>
<p/>
-3- <i>Returns</i>: If <tt>target_type() == typeid(T)</tt> a pointer to the stored function target; otherwise a null
pointer.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2592" href="#2592">2592.</a> Require that <tt>chrono::duration_cast</tt>s from smaller durations to larger durations do not overflow</h3>
<p><b>Section:</b> 20.17.2 [time.syn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Andy Giese <b>Opened:</b> 2016-02-05 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.syn">issues</a> in [time.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently 20.17.2 [time.syn] states
</p>
<blockquote><pre>
<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least 45 bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least 35 bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least 29 bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least 23 bits</i>, ratio&lt;3600&gt;&gt; hours;
</pre></blockquote>
<p>
However, a <tt>duration_cast&lt;minutes&gt;(seconds::max())</tt> would cause overflow if the underlying signed integers 
only met the minimums specified.
<p/>
The standard should specify that implementations guarantee that a <tt>duration_cast</tt> from any smaller duration in 
these "convenience typedefs" will not overflow any larger duration. That is, <tt>hours</tt> should be able to hold 
the maximum of <tt>minutes</tt>, which should be able to hold the maximum of <tt>seconds</tt> and so on.
<p/>
More formally, if the ratio <tt>typedef A</tt> and <tt>typedef B</tt> is <tt>1:Y</tt> where <tt>Y &gt; 1</tt> (e.g., 
1 : 60 in case of <tt>minutes</tt> : <tt>seconds</tt>), then <tt>#bits<sub>A</sub>-1</tt> must be at least 
<tt>ceil(log<sub>2</sub>(2<sup>#bits<sub>B</sub>-1)/Y)</sup>)</tt>.
<p/>
In the case of <tt>minutes</tt> : <tt>seconds</tt>, <tt>X = 1</tt>, <tt>Y = 60</tt>. Let 
<tt>#bits<sub>seconds</sub> = 32</tt>. Therefore:
</p>
<ul>
<li><p><tt>2<sup>(#bits<sub>seconds</sub> - 1)</sup> = 2<sup>31</sup> = 2147483648</tt></p></li>
<li><p><tt>ceil(log<sub>2</sub>(2<sup>31</sup> / 60) = 26</tt></p></li>
<li><p><tt>#bits<sub>minutes</sub> - 1 = 26</tt></p></li>
<li><p><tt>#bits<sub>minutes</sub> = 27</tt></p></li>
</ul>
<p>
Therefore, a minimum of 27 bits would be needed to store <tt>minutes</tt> if 32 were used to store <tt>seconds</tt>.
<p/>
I propose to change the definitions of the convenience typedefs as follows:
</p>
<blockquote><pre>
<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least 46 bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least 37 bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least 32 bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least 27 bits</i>, ratio&lt;3600&gt;&gt; hours;
</pre></blockquote>
<p>
These bits were chosen to satisfy the above formula. Note that
minimums only increased, so larger ranges could be held. A nice
outcome of this choice is that <tt>minutes</tt> does not go above 32 bits.
</p>

<p><i>[2016-04-23, Tim Song comments]</i></p>

<p>
The P/R of LWG 2592 doesn't fix the issue it wants to solve, because the actual underlying type will likely 
have more bits than the specified minimum.
<p/>
Consider <tt>seconds</tt>, which the P/R requires to have at least 37 bits. On a typical system this implies 
using a 64-bit integer. To ensure that casting from <tt>seconds::max()</tt> to <tt>minutes</tt> doesn't overflow 
in such a system, it is necessary for the latter to have at least 59 bits (which means, in practice, 64 bits too), 
not just 32 bits. Thus, just changing the minimum number of bits will not be able to provide the desired guarantee 
that casting from a smaller unit to a larger one never overflow.
<p/>
If such a guarantee is to be provided, it needs to be spelled out directly. Note that the difference here is 9 bits 
(for the 1000-fold case) and 5 bits (for the 60-fold case), which is less than the size difference between integer 
types on common systems, so such a requirement would effectively require those convenience typedefs to use the 
same underlying integer type.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4567.</p>

<ol>
<li><p>Change 20.17.2 [time.syn], header <tt>&lt;chrono&gt;</tt> synopsis, as indicated</p>

<blockquote><pre>
[&hellip;]

<i>// convenience typedefs</i>
typedef duration&lt;<i>signed integer type of at least 64 bits</i>,        nano&gt; nanoseconds;
typedef duration&lt;<i>signed integer type of at least 55 bits</i>,       micro&gt; microseconds;
typedef duration&lt;<i>signed integer type of at least <ins>46</ins><del>45</del> bits</i>,       milli&gt; milliseconds;
typedef duration&lt;<i>signed integer type of at least <ins>37</ins><del>35</del> bits</i>             &gt; seconds;
typedef duration&lt;<i>signed integer type of at least <ins>32</ins><del>29</del> bits</i>, ratio&lt;  60&gt;&gt; minutes;
typedef duration&lt;<i>signed integer type of at least <ins>27</ins><del>23</del> bits</i>, ratio&lt;3600&gt;&gt; hours;

[&hellip;]
</pre></blockquote>

</li>
</ol>





<hr>
<h3><a name="2593" href="#2593">2593.</a> Moved-from state of Allocators</h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-02-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.requirements">active issues</a> in [allocator.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
17.6.3.5 [allocator.requirements] suggests that the moved-from state of an allocator may be unequal to its 
previous state. Such a move constructor would break most container implementations, which move-construct the 
embedded allocator along with a compressed pair. Even if a moved-from container is empty, it should still 
subsequently allocate from the same resource pool as it did before.
</p>
<blockquote><pre>
std::vector&lt;int, pool&gt; a(500, my_pool);
auto b = std::move(a); // b uses my_pool too.
a.resize(500); // should still use my_pool.
</pre></blockquote>

<p><i>[2016-02, Jacksonville]</i></p>

<p>Marshall will see if this can be resolved editorially.</p>

<p>
After discussion, the editors and I decided that this could not be handled editorially. 
The bit about a moved-from state of an allocator being the same as the original state is a
normative change. I submitted a <a href="https://github.com/cplusplus/draft/pull/727">pull request</a>
to handle the mismatched variables in the table.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4567.
</p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements], Table 28 &mdash; "Allocator requirements" as indicated:
<blockquote class="note">
<p>
Note there's an editorial error in Table 28 in that line and the surrounding ones. The left column was apparently 
updated to use <tt>u</tt> and the right column is still using <tt>a</tt>/<tt>a1</tt>/<tt>b</tt>.
</p>
</blockquote>
</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X u(move(a));<br/>
X u = move(a);</tt>
</td>
<td></td>
<td>
Shall not exit via an exception.
post: <ins><tt>u</tt> is equal to <tt>a</tt> and equal to the prior value of <tt>a</tt></ins><del><tt>a1</tt> 
equals the prior value of <tt>a</tt></del>.
</td>
<td>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>

</blockquote>

<p><i>[2016-06-20, Oulu, Daniel comments]</i></p>

<p>
According to the current working draft, the situation has changed due to changes performed by the project editor, the revised 
resolution has been adjusted to N4594.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to LEWG, as this decision (should allocators only be copyable, not movable) is design.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4594.
</p>

<ol>
<li><p>Change 17.6.3.5 [allocator.requirements], Table 28 &mdash; "Allocator requirements" as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 28 &mdash; Allocator requirements</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
<th>Default</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X u(std::move(a));<br/>
X u = std::move(a);</tt>
</td>
<td></td>
<td>
Shall not exit via an exception.
post: <ins><tt>u</tt> is equal to <tt>a</tt> and equal to the prior value of <tt>a</tt></ins><del><tt>u</tt> is equal to the prior
value of <tt>a</tt>.</del>.
</td>
<td>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2594" href="#2594">2594.</a> Contradicting definition of empty <tt>shared_ptr</tt> on <tt>shared_ptr(nullptr, d)</tt></h3>
<p><b>Section:</b> 20.11.2.2 [util.smartptr.shared] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-02-20 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared">active issues</a> in [util.smartptr.shared].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared">issues</a> in [util.smartptr.shared].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Latest draft (N4567) 20.11.2.2 [util.smartptr.shared] p1 says:
</p>
<blockquote>
<p>
A <tt>shared_ptr</tt> object is <em>empty</em> if it does not own a pointer.
</p>
</blockquote>
<p>
Please note that it says "own a pointer". This definition was added as
the resolution for LWG defect <a href="lwg-defects.html#813">813</a>.
<p/>
20.11.2.2.1 [util.smartptr.shared.const] p8 says about the effect of
<tt>shared_ptr(nullptr_t p, D d)</tt>:
</p>
<blockquote>
<p>
<i>Effects</i>: Constructs a <tt>shared_ptr</tt> object that <em>owns</em> the object <tt>p</tt> and the deleter <tt>d</tt>.
</p>
</blockquote>
<p>
Please note that it says "<em>owns</em> the object". This was intentionally
changed from "the pointer" as a part of resolution for LWG defect <a href="lwg-defects.html#758">758</a>,
to cover <tt>nullptr_t</tt> case.
<p/>
Since <tt>shared_ptr(nullptr, d)</tt> owns an object of type <tt>nullptr_t</tt>, but does
not own a pointer, it is said as "empty" by a strict reading of the
above mentioned definition in 20.11.2.2 [util.smartptr.shared] p1.
<p/>
These cause a contradiction:
<p/>
20.11.2.2.1 [util.smartptr.shared.const] p9 sets a postcondition
<tt>use_count() == 1</tt> on <tt>shared_ptr(nullptr, d)</tt>. But 
20.11.2.2.5 [util.smartptr.shared.obs] p7 says that the return value of <tt>use_count()</tt>
is "<tt>0</tt> when <tt>*this</tt> is <em>empty</em>".
</p>
<p>
Proposed wording changes:
<p/>
Replace the last 2 words in 20.11.2.2 [util.smartptr.shared] p1 from
</p>
<blockquote><p>
[&hellip;] <em>empty</em> if it does not own a pointer.
</p></blockquote>
<p>
to
</p>
<blockquote><p>
[&hellip;] <em>empty</em> if it does not own an object.
</p></blockquote>
<p>
Note that <tt>shared_ptr(nullptr_t)</tt> is defined to be empty in synopsis in
20.11.2.2 [util.smartptr.shared].
</p>
<blockquote><pre>
constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }
</pre></blockquote>
<p>
It could be less confusing if <tt>shared_ptr(nullptr, d)</tt> could be defined to
be empty. But it seems too late to change that (which means changing
whether the deleter is called or not, see 
<a href="https://stackoverflow.com/questions/11164354/">this Stackoverflow article</a>). 
Then I'm proposing just fix the contradiction.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4594.
</p>

<ol>
<li><p>Change 20.11.2.2 [util.smartptr.shared] p1 as indicated:</p>

<blockquote>
<p>-1- The <tt>shared_ptr</tt> class template stores a pointer, usually obtained via <tt>new</tt>. <tt>shared_ptr</tt> 
implements semantics of shared ownership; the last remaining owner of the pointer is responsible for destroying the 
object, or otherwise releasing the resources associated with the stored pointer. A <tt>shared_ptr</tt> object is 
<em>empty</em> if it does not own <ins>an object</ins><del>a pointer</del>.
</p>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2595" href="#2595">2595.</a> <tt>reverse_iterator::operator[]</tt>'s return type revisited</h3>
<p><b>Section:</b> 24.5.1.1 [reverse.iterator], 24.5.1.3.12 [reverse.iter.opindex] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2016-02-28 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#reverse.iterator">issues</a> in [reverse.iterator].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="lwg-defects.html#386">386</a> changed the return type of <tt>reverse_iterator::operator[]</tt> to unspecified. However, 
as of N3066, the return type of a random access iterator's <tt>operator[]</tt> shall be convertible to <tt>reference</tt>; 
thus the return type of <tt>reverse_iterator::operator[]</tt> should be <tt>reference</tt> (and it is in all common
implementations).
<p/>
Suggested resolution: Adjust 24.5.1.1 [reverse.iterator]'s synopsis and 24.5.1.3.12 [reverse.iter.opindex] to 
use <tt>reference</tt> instead of <tt><i>unspecified</i></tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Edit 24.5.1.1 [reverse.iterator], class template <tt></tt> synopsis, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class Iterator&gt;
  class reverse_iterator {
  public:
    [&hellip;]
    typedef typename iterator_traits&lt;Iterator&gt;::reference reference;
    [&hellip;]
    constexpr <ins>reference</ins><del><i>unspecified</i></del> operator[](difference_type n) const;
    [&hellip;]
  };
}
</pre></blockquote>

</li>

<li><p>Change 24.5.1.3.12 [reverse.iter.opindex] before p1 as indicated:</p>

<blockquote>
<pre>
constexpr <ins>reference</ins><del><i>unspecified</i></del> operator[](
  typename reverse_iterator&lt;Iterator&gt;::difference_type n) const;
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2597" href="#2597">2597.</a> <tt>std::log</tt> misspecified for complex numbers</h3>
<p><b>Section:</b> 26.5.8 [complex.transcendentals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-03-01 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.transcendentals">issues</a> in [complex.transcendentals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <tt>std::log</tt> is inconsistent for complex numbers, specifically, the Returns clause 
(26.5.8 [complex.transcendentals]). On the one hand, it states that the imaginary part of the return value lies 
in the <em>closed</em> interval <tt>[-<i>i</i> &pi;, +<i>i</i> &pi;]</tt>. On the other hand, it says that "the branch 
cuts are along the negative real axis" and "the imaginary part of <tt>log(x)</tt> is <tt>+&pi;</tt> when <tt>x</tt> 
is a negative real number".
</p>
<p>
The inconsistency lies in the difference between the mathematical concept of a branch cut and the nature of floating 
point numbers in C++. The corresponding specification in the C standard makes it clearer that if <tt>x</tt> is a real 
number, then <tt>log(x + 0<i>i</i>) = +&pi;</tt>, but <tt>log(x - 0<i>i</i>) = -&pi;</tt>, i.e. they consider positive 
and negative zero to represent the two different limits of approaching the branch cut from opposite directions. In 
other words, the term "negative real number" is misleading, and in fact there are <em>two distinct</em> real numbers, 
<tt>x + 0<i>i</i></tt> and <tt>x - 0<i>i</i></tt>, that compare equal but whose logarithms differ by <tt>2 &pi; <i>i</i></tt>.
</p>
<p>
The resolution should consist of two parts:
</p>
<ol>
<li><p>Double-check that our usage and definition of "branch cut" is sufficiently unambiguous. The C standard contains 
a lot more wording around this that we don't have in C++.</p></li>
<li><p>Change the Returns clause of <tt>log</tt> appropriately. For example: "When <tt>x</tt> is a negative real number, 
<tt>imag(log(x + 0<i>i</i>))</tt> is <tt>&pi;</tt>, and <tt>imag(log(x - 0<i>i</i>))</tt> is <tt>-&pi;</tt>."</p></li>
</ol>
<p>
Current implementations seem to behave as described in (2). 
(<a href="http://melpon.org/wandbox/permlink/pwBDeGiY3HDtFAh8">Try-it-at-home link</a>)
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2598" href="#2598">2598.</a> <tt>addressof</tt> works on temporaries</h3>
<p><b>Section:</b> 20.10.10.1 [specialized.addressof] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Brent Friedman <b>Opened:</b> 2016-03-06 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#specialized.addressof">issues</a> in [specialized.addressof].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG issue <a href="lwg-defects.html#970">970</a> removed the rvalue reference overload for <tt>addressof</tt>. This allows const prvalues to 
bind to a call to <tt>addressof</tt>, which is dissimilar from the behavior of <tt>operator&amp;</tt>.
</p>
<blockquote><pre>
const vector&lt;int&gt; a();

void b()
{
  auto x = addressof(a()); // "ok"
  auto y = addressof&lt;const int&gt;(0); // "ok"
  auto z = &amp;a(); //error: cannot take address of a temporary
}
</pre></blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Tues PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 20.10.2 [memory.syn], header <tt>&lt;memory&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
[&hellip;]
<i>// 20.9.12, specialized algorithms:</i>
template &lt;class T&gt; constexpr T* addressof(T&amp; r) noexcept;
<ins>template &lt;class T&gt; const T* addressof(const T&amp;&amp; elem) = delete;</ins>
[&hellip;]
</pre>
</blockquote>
</li>

<li><p>Change 20.10.10.1 [specialized.addressof] p1 as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; constexpr T* addressof(T&amp; r) noexcept;
<ins>template &lt;class T&gt; const T* addressof(const T&amp;&amp; elem) = delete;</ins>
</pre>
<blockquote>
<p>
-1- <i>Returns</i>: The actual address of the object or function referenced by <tt>r</tt>, even in the presence of an
overloaded <tt>operator&amp;</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2599" href="#2599">2599.</a> Library incomplete type permission phrase is unclear</h3>
<p><b>Section:</b> 20.2.6 [declval], 20.11.1 [unique.ptr], 20.11.1.1.1 [unique.ptr.dltr.general], 20.11.2.2 [util.smartptr.shared], 20.11.2.3 [util.smartptr.weak], 20.11.2.5 [util.smartptr.enab] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2016-03-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently the phrase to grant this permission is:
</p>
<blockquote><p>
The template parameter <tt>T</tt> of <tt><i>LibraryTemplate</i></tt> may be an incomplete type.
</p></blockquote>
<p>
Two problems:
</p>
<ol>
<li><p>The timing is unclear.  We always allow specializations like <tt><i>LibraryTemplate</i>&lt;Incomp&gt;* p;</tt></p></li>
<li><p>To the users of a template, the correct terminology should be "argument" rather than "parameter".</p></li>
</ol>
<p>
Suggested resolution:
</p>
<blockquote><p>
In an instantiation of <tt><i>LibraryTemplate</i></tt>, an incomplete type
may be used as the template argument for the template parameter <tt>T</tt>.
</p></blockquote>
<p>
as shown <a href="https://github.com/cplusplus/draft/pull/304/files">here</a>.
<p/>
Or, to copy <a href=" http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4510.html">N4510's wording</a>:
</p>
<blockquote><p>
An incomplete type <tt>T</tt> may be used when instantiating <tt><i>LibraryTemplate</i></tt>.
</p></blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2600" href="#2600">2600.</a> <tt>ios_base</tt> must store inaccessible iostate flags</h3>
<p><b>Section:</b> 27.5.3.5 [ios.base.storage] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base.storage">issues</a> in [ios.base.storage].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
DR <a href="lwg-defects.html#41">41</a>, "Ios_base needs <tt>clear()</tt>, <tt>exceptions()</tt>" stopped short of providing the interface 
suggested in its title, but it did require the underlying state to be stored in <tt>ios_base</tt>. Because <tt>rdstate()</tt> 
is also missing, <tt>ios_base</tt> manipulators relying on <tt>iword</tt> and <tt>pword</tt> cannot detect failure. 
The only safe alternative is to manipulate a derived class, which must be a template.
<p/>
libc++ already provides the interface as a nonconforming extension. libstdc++ implements the internal state but leaves 
it frustratingly inaccessible, as specified. Any conforming implementation should be able to provide the interface 
without ABI problems.
</p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
This is really a request for an (feature) API. Passing to LEWG.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2663" href="#2663">2663.</a> Enable efficient retrieval of file size from <code>directory_entry</code></h3>
<p><b>Section:</b> 27.10.15.14 [fs.op.file_size] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Gor Nishanov <b>Opened:</b> 2014-05-22 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  On Windows, the <code><del>FindFileData</del> <ins>WIN32_FIND_DATA</ins></code> structure, which is the underlying data type for <code>directory_entry</code>, contains the file size as one of the fields.

  Thus efficient enumeration of files and getting their sizes is possible without doing a separate query for the file size.

</p>
  <p><i>[17 Jun 2014 Rapperswil LWG will investigate issue at a subsequent meeting.]</i></p>

  <p><i>[23 Nov 2015 Editorally correct name of data structure mentioned in discussion.]</i></p>


<p><i>[Mar 2016 Jacksonville Beman to provide paper about this]</i></p>


<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><strong>Previous resolution [SUPERSEDED]</strong></p>
<blockquote class="note">
  <p>
    <i>
      In 27.10.12 [class.directory_entry] Class <code>directory_entry</code> add the
      following observer declarations:
    </i>
  </p>
  <p></p>
  <blockquote>
    <pre>
      uintmax_t file_size();
      uintmax_t file_size(error_code&amp; ec) noexcept;
    </pre>
  </blockquote>
  <p>
    <i>
      In <code>directory_entry</code> observers 27.10.12.3 [directory_entry.obs]
      add the following:
    </i>
  </p>
  <p></p>
  <blockquote>
    <pre>
      uintmax_t file_size();
      uintmax_t file_size(error_code&amp; ec) noexcept;
    </pre>
    <p></p>
    <blockquote>
      <p>
        <i>Returns:</i> if <code>*this</code> contains a cached file size, return
        it.
        Otherwise return <code>file_size(path())</code> or <code>file_size(path(), ec)</code>
        respectively.
      </p>
      <p>
        <i>Throws:</i> As specified in Error reporting (7).
      </p>
    </blockquote>
  </blockquote>
</blockquote>

<p><i>[2016-08, Beman comments]</i></p>

<p>
This will be resolved by <a href="http://wg21.link/p0317r1">P0317R1</a>, Directory Entry Caching for Filesystem.
<p>Fri AM: Moved to Tentatively Resolved</p>
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2664" href="#2664">2664.</a> <code>operator/</code> (and other append) semantics not useful if argument has root</h3>
<p><b>Section:</b> 27.10.8.4.3 [path.append], 27.10.8.6 [path.non-member] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Peter Dimov <b>Opened:</b> 2014-05-30 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#path.append">active issues</a> in [path.append].</p>
<p><b>View all other</b> <a href="lwg-index.html#path.append">issues</a> in [path.append].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  In a recent discussion on the Boost developers mailing list, the semantics of <code>operator /</code>
  and other append operations were questioned:
<p/>
In brief, currently <code>p1 / p2</code> is required to concatenate the
  lexical representation of <code>p1</code> and <code>p2</code>, inserting a
  preferred separator as needed.
<p/>
This means that, for example, <code>&quot;c:\x&quot; / &quot;d:\y&quot;</code> gives <code>
    &quot;c:\x\d:\y&quot;</code>, and that <code>&quot;c:\x&quot; / &quot;\\server\share&quot;</code>
    gives <code>&quot;c:\x\\server\share&quot;</code>. This is rarely, if ever, useful.
<p/>
An alternative interpretation of <code>p1 / p2</code> could be that it yields a
  path that is the approximation of what <code>p2</code> would mean if interpreted
  in an environment in which <code>p1</code> is the starting directory. 
  Under this interpretation, <code>&quot;c:\x&quot; / &quot;d:\y&quot;</code> gives <code>&quot;d:\y&quot;</code>,
  which is more likely to match what was intended.
<p/>
I am not saying that this second interpretation is the right one, but I do say
  that we have reasons to suspect that the first one (lexical concatenation using
  a separator) may not be entirely correct.
  This leads me to think that the behavior of <code>p1 / p2</code>, when <code>p2</code>
  has a root, needs to be left implementation-defined, so that implementations are
  not required to do the wrong thing, as above.
<p/>
This change will not affect the ordinary use case in which <code>p2</code> is a
  relative, root-less, path.
</p>  
<p><i>[17 Jun 2014 Rapperswil LWG will investigate issue at a subsequent meeting.]</i></p>


<p><i>[2016-02, Jacksonville]</i></p>

<p>Beman to provide wording.</p>

<p><i>[2016-06-13, Beman provides wording and rationale]</i></p>

<p>
<b>Rationale:</b> The purpose of the append operations is to provide a simple concatenation facility for users 
wishing to extend a path by appending one or more additional elements, and to do so without worrying about the 
details of when a separator is needed. In that context it makes no sense to provide an argument that has a 
<i>root-name</i>. The simplest solution is simply to require <code>!p.has_root_name()</code>.
The other suggested solutions IMO twist the functions into something harder to reason about
yet any advantages for users are purely speculative. The concatenation functions can
be used instead for corner cases.
</p>

<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><i>[2016-07-03, Daniel comments]</i></p>

<p>
The same wording area is touched by LWG <a href="lwg-active.html#2732">2732</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4594.</p>
<ol>
<li><p><i>Change 27.10.8.4.3 [path.append] path appends as indicated:</i></p>

<blockquote>
<code>path&amp; operator/=(const path&amp; p);</code>
<blockquote>
  <p><ins>-?- <i>Requires:</i> <code>!p.has_root_name()</code>.</ins></p>
  <p>-2- <i>Effects:</i> Appends <code>path::preferred_separator</code> to <tt>pathname</tt> unless:</p>
  <ul>
  <li><p>an added <i>directory-separator</i> would be redundant, or</p></li>
  <li><p>an added <i>directory-separator</i> would change a relative path to an absolute path 
  [<i>Note:</i> An empty path is relative. &mdash; <i>end note</i>], or</p></li>
  <li><p><code>p.empty()</code> is <tt>true</tt>, or</p></li>
  <li><p><code>*p.native().cbegin()</code> is a <i>directory-separator</i>.</p></li>
  </ul>
  <p>Then appends <code>p.native()</code> to <tt>pathname</tt>.</p>
  <p>-3- <i>Returns:</i> <code>*this</code>.</p>
</blockquote>
<code>template &lt;class Source&gt;<br/>
&nbsp; path&amp; operator/=(const Source&amp; source);<br/>
template &lt;class Source&gt;<br/>
&nbsp; path&amp; append(const Source&amp; source);<br/>
template &lt;class InputIterator&gt;<br/>
&nbsp; path&amp; append(InputIterator first, InputIterator last);</code>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> <code>!source.has_root_name()</code> or
<code>!*first.has_root_name()</code>, respectively.</ins>
<p/>
-4- <i>Effects:</i> Appends <code>path::preferred_separator</code> to <tt>pathname</tt>,
converting format and encoding if required (27.10.8.2 [path.cvt]), unless:
</p>
<ul>
  <li><p>an added <i>directory-separator</i> would be redundant, or</p></li>
  <li><p>an added <i>directory-separator</i> would change a relative path to an absolute path, or</p></li>
  <li><p><code>source.empty()</code> is <tt>true</tt>, or</p></li>
  <li><p><code>*source.native().cbegin()</code> is a <i>directory-separator</i>.</p></li>
</ul>
<p>
Then appends the effective range of <code>source</code> (27.10.8.3 [path.req]) or the range
<code>[first, last)</code> to <code>pathname</code>, converting format and encoding if required (27.10.8.2 [path.cvt]).
<p/>
-5- <i>Returns:</i> <code>*this</code>.
</p>
</blockquote>
</blockquote>
</li>

<li><p><i>Change 27.10.8.6 [path.non-member] path non-member functions as indicated:</i></p>

<blockquote>
<code>path operator/(const path&amp; lhs, const path&amp; rhs);</code>
  <blockquote>
  <p><ins>-?- <i>Requires:</i> <code>!rhs.has_root_name()</code>.</ins></p>
  <p>-13- <i>Returns:</i> <code>path(lhs) /= rhs</code>.</p>
  </blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-03 Chicago]</i></p>

<p>After discussion on <a href="lwg-active.html#2732">2732</a>, it was determined that the PR for that issue should be
applied to this issue before it is accepted. That PR changes all the path appends to go through
operator/=, so only one requires element remains necessary.</p>
<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606, and assumes that the PR for <a href="lwg-active.html#2732">2732</a> is applied.</p>
<ol>
<li>Change 27.10.8.4.3 [path.append] as indicated:
<pre>path&amp; operator/=(const path&amp; p);</pre>
<blockquote>
  <p><ins>-?- <i>Requires:</i> <code>!p.has_root_name()</code>.</ins></p>
  <p>-2- <i>Effects:</i> Appends <code>path::preferred_separator</code> to <tt>pathname</tt> unless:</p>
  <ul style="list-style-type: none">
  <li>&mdash; an added <i>directory-separator</i> would be redundant, or</li>
  <li>&mdash; an added <i>directory-separator</i> would change a relative path to an absolute path
  [<i>Note:</i> An empty path is relative. &mdash; <i>end note</i>], or</li>
  <li>&mdash; <code>p.empty()</code> is <tt>true</tt>, or</li>
  <li>&mdash; <code>*p.native().cbegin()</code> is a <i>directory-separator</i>.</li>
  </ul>
  <p>Then appends <code>p.native()</code> to <tt>pathname</tt>.</p>
  <p>-3- <i>Returns:</i> <code>*this</code>.</p>
</blockquote>
</li>
<li>Change 27.10.8.6 [path.non-member] p13 as indicated:
<pre>path operator/(const path&amp; lhs, const path&amp; rhs);</pre>
<blockquote>
<p>-13- <em><del>Returns</del><ins>Effects</ins>:</em> <ins>Equivalent to </ins><code>
<ins>return </ins>path(lhs) /= rhs;</code>.</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2665" href="#2665">2665.</a> <code>remove_filename()</code> post condition is incorrect</h3>
<p><b>Section:</b> 27.10.8.4.5 [path.modifiers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2014-06-07 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
  <code>remove_filename()</code> specifies <code>!has_filename()</code> as the post condition.
This post condition is not correct. For example the path <code>"/foo"</code>
has a filename of <code>"foo"</code>. If we remove the filename we get <code>"/"</code>,
and <code>"/"</code> has a filename of <code>"/"</code>.</p>

<p><i>[2014-06-08 Beman supplies an <i>Effects:</i> element.]</i></p>


<p><i>[2014-06-17 Rapperswil LWG will investigate issue at a subsequent meeting.]</i></p>


<p><i>[<b>2016-04  Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
There was concern that the effects wording is not right.  Jonathan provided updated wording.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
  <pre>
    path&amp; <a name="path-remove_filename">remove_filename</a>();
  </pre>
  <blockquote>
    <p>
      <del><i>Postcondition:</i> <code>!has_filename()</code>.</del>
    </p>
    <p>
    <ins>
      <i>Effects:</i> <code>*this = parent_path()</code>, except that if <code>parent_path() == root_path()</code>, <code>clear()</code>.
    </ins>
    </p>
    <p>
      <i>Returns: </i> <code>*this</code>.
    </p>
    <p>
      [<i>Example:</i>
    </p>
    <blockquote>
      <pre>
        <code>std::cout &lt;&lt; path(&quot;/foo&quot;).remove_filename();</code>  // outputs &quot;<code>/</code>&quot;
        std::cout &lt;&lt; path(&quot;/&quot;).<code>remove_</code>filename();     // outputs &quot;&quot;
      </pre>
    </blockquote>
    <p>
      <i>&mdash;end example</i>]
    </p>
  </blockquote>
</blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<pre>
  path&amp; <a name="path-remove_filename">remove_filename</a>();
</pre>
<blockquote>
  <p>
    <del>Postcondition: !has_filename().</del>
  </p>
  <p>
    <ins>Effects: If <code>*this == root_path()</code>, then <code>clear()</code>. Otherwise, <code>*this = parent_path()</code>.</ins>
  </p>
  <p>
    <i>Returns: </i> <code>*this</code>.
  </p>
  <p>
    [<i>Example:</i><br/>
  <blockquote>
    <pre>
      <code>std::cout &lt;&lt; path(&quot;/foo&quot;).remove_filename();</code>  // outputs &quot;<code>/</code>&quot;
      std::cout &lt;&lt; path(&quot;/&quot;).<code>remove_</code>filename();     // outputs &quot;&quot;
    </pre>
  </blockquote><br/>
    <i>&mdash;end example</i>]
  </p>
  </blockquote>






<hr>
<h3><a name="2668" href="#2668">2668.</a> <code>path::operator+=</code> is defined, but not <code>operator+</code></h3>
<p><b>Section:</b> 27.10.8 [class.path] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-07-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#class.path">issues</a> in [class.path].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>This doesn't seem to be in Boost.Filesystem, so maybe it isn't needed,
but since <code>path += path2</code> works then it seems reasonable to expect
<code>path1 + path2</code> to work as well.</p>

  <p><i>[04 Jul 2014 Beman Dawes comments:]</i></p>

  <blockquote>
    <p>The 12 overloads required by <code>basic_string operator+</code> scared me off,
    and I never came back to the issue.</p>  
  </blockquote>

  <p><i>[22 Nov 2015 Beman supplies proposed resolution wording.]</i></p>

 
<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 




<p><b>Proposed resolution:</b></p>
<p>NAD, Future.</p>
  <blockquote>
  <p>It is not necessary to provide every possible string operation for class
  <code>path</code> because it is always possible to convert to a string,
  perform the operation, and convert back to a path. The most commonly needed string
  operations are provided for class <code>path</code> as a convenience, but every added
  function comes at the cost of increased interface complexity. In this case, the cost
  is judged to outweigh the convenience.</p>
  
  <p>Future changes to the language, such as concepts, and changes to the library, such as
  <code>basic_string_view</code>, may allow reduction of the complexity of the class path
  interface. The LWG may wish to reconsider this issue at that time.</p>
  </blockquote>





<hr>
<h3><a name="2672" href="#2672">2672.</a> Should is_empty use error_code in its specification?</h3>
<p><b>Section:</b> 27.10.15.19 [fs.op.is_empty] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-08-01 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The descriptions of most functions are explicit about the use of the <code>ec</code> argument,
  either saying something like "<code>foo(p)</code> or <code>foo(p, ec)</code>, respectively" or using the
  <code>ec</code> argument like <code>foo(p[, ec])</code>, but <code>is_empty</code> does not.
</p>
<p>
27.10.15.19 [fs.op.is_empty]/2 refers to <code>ec</code> unconditionally, but more importantly
  27.10.15.19 [fs.op.is_empty]/3 doesn't pass <code>ec</code> to the <code>directory_iterator</code>
  constructor or the <code>file_size</code> function.
</p>

  <p><i>[
    9 Oct 2014 Beman supplies proposed wording.
  ]</i></p>


<p><i>[<b>Apr 2016 Issue updated to address the C++ Working Paper. Previously addressed File System TS</b>]</i></p>
 

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<ol>
<li>
  <blockquote>
  <pre>
    bool is_empty(const path&amp; p);
    bool is_empty(const path&amp; p, error_code&amp; ec) noexcept;
  </pre>
  <blockquote>
    <p>
      <i>Effects:</i>
    </p>
    <ul>
      <li>
        Determine <code>file_status s</code>, as if by
        <ins>
          <code>status(p)</code> or
        </ins> <code>status(p, ec)</code><ins>, respectively</ins>.
      </li>
      <li>
        <ins>
          For the signature with argument <code>ec</code>, return <code>false</code> if
          an error occurred.
        </ins>
      </li>
      <li>
        <ins>
          Otherwise, if <code>is_directory(s)</code>:
        </ins>
        <ul>
          <li>
            <ins>
              Create <code>directory_iterator itr</code>, as if by
              <code>directory_iterator(p)</code>
              or <code>directory_iterator(p, ec)</code>, respectively.
            </ins>
          </li>
          <li>
            <ins>
              For the signature with argument <code>ec</code>, return <code>false</code> if
              an error occurred.
            </ins>
          </li>
          <li>
            <ins>
              Otherwise, return <code>itr == directory_iterator()</code>.
            </ins>
          </li>
        </ul>
      </li>
      <li>
        <ins>Otherwise:</ins>
        <ul>
          <li>
            <ins>
              Determine <code>uintmax_t sz</code>, as if by <code>
                file_size(p)
              </code> or<code> file_size(p, ec)</code>, respectively
            </ins>.
          </li>
          <li>
            <ins>
              For the signature with argument <code>ec</code>, return <code>false</code> if
              an error occurred.
            </ins>
          </li>
          <li>
            <ins>
              Otherwise, return <code>sz == 0</code>.
            </ins>
          </li>
        </ul>
      </li>
    </ul>
    <p>
      <ins>
        <i>Remarks:</i> The temporary objects described in <i>Effects</i>
        are for exposition only. Implementations are not required to create them.
      </ins>
    </p>
    <p>
      <i>Returns:</i>
      <del>
        <code>
          is_directory(s) ? directory_iterator(p) == directory_iterator()
          : file_size(p) == 0;
        </code>
      </del>
      <ins>
        See <i>Effects</i>.
      </ins>
    </p>
    <blockquote>
      <p>
        <del>
          The signature with argument <code>ec</code> returns <code>false</code> if
          an error occurs.
        </del>
      </p>
    </blockquote>
    <p>
      <i>Throws:</i> As specified in Error reporting (7).
    </p>
  </blockquote>
  </blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
  <blockquote>
  <pre>
    bool is_empty(const path&amp; p);
    bool is_empty(const path&amp; p, error_code&amp; ec) noexcept;
  </pre>
  <blockquote>
    <p>
      <i>Effects:</i>
    </p>
    <ul>
      <li>
        Determine <code>file_status s</code>, as if by
        <ins>
          <code>status(p)</code> or
        </ins> <code>status(p, ec)</code><ins>, respectively</ins>.
      </li>
      <li>
        <ins>
          For the signature with argument <code>ec</code>, return <code>false</code> if
          an error occurred.
        </ins>
      </li>
      <li>
        <ins>
          Otherwise, if <code>is_directory(s)</code>:
        </ins>
        <ul>
          <li>
            <ins>
              Create <code>directory_iterator itr</code>, as if by
              <code>directory_iterator(p)</code>
              or <code>directory_iterator(p, ec)</code>, respectively.
            </ins>
          </li>
          <li>
            <ins>
              For the signature with argument <code>ec</code>, return <code>false</code> if
              an error occurred.
            </ins>
          </li>
          <li>
            <ins>
              Otherwise, return <code>itr == directory_iterator()</code>.
            </ins>
          </li>
        </ul>
      </li>
      <li>
        <ins>Otherwise:</ins>
        <ul>
          <li>
            <ins>
              Determine <code>uintmax_t sz</code>, as if by <code>
                file_size(p)
              </code> or<code> file_size(p, ec)</code>, respectively
            </ins>.
          </li>
          <li>
            <ins>
              For the signature with argument <code>ec</code>, return <code>false</code> if
              an error occurred.
            </ins>
          </li>
          <li>
            <ins>
              Otherwise, return <code>sz == 0</code>.
            </ins>
          </li>
        </ul>
      </li>
    </ul>
    <p>
      <del>
      <i>Returns:</i>
        <code>
          is_directory(s) ? directory_iterator(p) == directory_iterator()
          : file_size(p) == 0;
        </code>
      </del>
    </p>
    <blockquote>
      <p>
        <del>
          The signature with argument <code>ec</code> returns <code>false</code> if
          an error occurs.
        </del>
      </p>
    </blockquote>
    <p>
      <i>Throws:</i> As specified in Error reporting (7).
    </p>
  </blockquote>
  </blockquote>
</li>
</ol>





<hr>
<h3><a name="2675" href="#2675">2675.</a> <tt>register_callback</tt> can fail</h3>
<p><b>Section:</b> 27.5.3.6 [ios.base.callback] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> David Krauss <b>Opened:</b> 2016-03-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>register_callback</tt> allocates memory and so it can fail, but the case is unspecified. libc++ sets
<tt>badbit</tt>, which is consistent with <tt>iword</tt> and <tt>pword</tt>. libstdc++ throws <tt>std::bad_alloc</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2676" href="#2676">2676.</a> Provide <code>filesystem::path</code> overloads for <i>File-based streams</i></h3>
<p><b>Section:</b> 27.9 [file.streams] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2016-03-16 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#file.streams">issues</a> in [file.streams].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
  <p>
    The constructor and <code>open</code> functions for <i>File-based streams</i> in
    27.9 [file.streams] currently provide overloads for <code>const char*</code> and
    <code>const string&amp;</code> arguments that specify the path for the file to be opened.
    With the addition of the File System TS to the standard library, these
    constructors and <code>open</code> functions need to be overloaded for <code>
      const filesystem::path&amp;
    </code> so that file-based streams can take advantage of class <code>filesystem::path</code>
    features such as support for strings of character types <code>wchar_t</code>,
    <code>char16_t</code>, and <code>char32_t</code>.
  </p>
  <p>
    The <code>
      const filesystem::path&amp; p
    </code> overload for these functions is like the
    existing <code>const string&amp;</code> overload; it simply calls the overload of
    the same function that takes a C-style string.</p>
  <p> For operating systems like POSIX
    that traffic in <code>char</code> strings for filenames, nothing more is
    required. For operating systems like Windows that traffic in <code>wchar_t</code>
    strings for filenames, an additional C-style string overload is required.
    The overload's character type needs to be specified as
    <code>std::filesystem::path::value_type</code> to also support possible future
    operating systems that traffic in <code>char16_t</code> or <code>char32_t</code> characters.
  </p>
  
  <p><b>Not recommended:</b></p>
  <p>Given the proposed constructor and <code>open</code> signatures taking
  <code>const filesystem::path&amp;</code>, it would in theory be possible to remove 
  some of the other signatures. This is not proposed because it would break ABI's, break
  user code depending on user-defined automatic conversions to the existing argument types,
  and invalidate existing documentation, books, and tutorials.</p>
  
  <p><b>Implementation experience:</b></p>
  <p>
    The Boost Filesystem library has provided header <code>&lt;boost/filesystem/fstream.hpp&gt;</code>
    implementing the proposed resolution for over a decade.
  </p>
  <p>
    The Microsoft/Dinkumware
    implementation of standard library header <code>&lt;fstream&gt;</code> has provided
    the <code>const wchar_t*</code>
    overloads for many years.
  </p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri PM: Move to Review</p>


<p><b>Proposed resolution:</b></p>

<p><i><span style="background-color: #E1E9FD">At the end of 27.9.1 File streams 
[</span><span style="background-color: #E1E9FD">fstreams</span><span style="background-color: #E1E9FD">] 
add a paragraph:</span></i></p>

<p>In this subclause, member functions taking arguments of <code>
const std::filesystem::path::value_type*</code> shall only be provided on systems 
where <code>std::filesystem::path::value_type</code> ([class.path]) is not <code>
char</code>. [<i>Note:</i> These functions enable class <code>path</code> 
support for systems with a wide native path character type, such as <code>
wchar_t</code>. &mdash; <i>end note</i>]</p>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.1 Class template 
basic_filebuf [filebuf] as indicated:</span></i></p>

<pre>basic_filebuf&lt;charT,traits&gt;* open(const char* s,
    ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode);  // wide systems only; see [fstreams]</ins> 
basic_filebuf&lt;charT,traits&gt;* open(const string&amp; s,
   ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const filesystem::path&amp; p,</ins>
   <ins>ios_base::openmode mode);</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.4 Member functions [filebuf.members] 
as indicated:</span></i></p>

<pre>basic_filebuf&lt;charT,traits&gt;* open(const char* s,
   ios_base::openmode mode);
<ins>basic_filebuf&lt;charT,traits&gt;* open(const std::filesystem::path::value_type* s,</ins>
   <ins>ios_base::openmode mode);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.4 Member functions [filebuf.members] 
add:</span></i></p>

<pre><ins>basic_filebuf&lt;charT,traits&gt;* open(const filesystem::path&amp; p,</ins>
   <ins>ios_base::openmode mode);</ins></pre>
   
<blockquote>
  <p><i>Returns:</i> <code>open(p.c_str(), mode);</code></p>
</blockquote>

  <p><i><span style="background-color: #E1E9FD">Change 27.9.1.6 Class template 
basic_ifstream [ifstream] as indicated:</span></i></p>

<pre>explicit basic_ifstream(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins>
explicit basic_ifstream(const string&amp; s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.7 basic_ifstream 
constructors [ifstream.cons] as indicated:</span></i></p>

<pre>explicit basic_ifstream(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>explicit basic_ifstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.7 basic_ifstream 
constructors [ifstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_ifstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_ifstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.9 Member functions [ifstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::in);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.9 Member functions [ifstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.10 Class template 
basic_ofstream [ofstream] as indicated:</span></i></p>

<pre>explicit basic_ofstream(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins>
explicit basic_ofstream(const string&amp; s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.11 basic_ofstream 
constructors [ofstream.cons] as indicated:</span></i></p>

<pre>explicit basic_ofstream(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>explicit basic_ofstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.11 basic_ofstream 
constructors [ofstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_ofstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_ofstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.13 Member functions [ofstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::out);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.13 Member functions [ofstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.14 Class template 
basic_fstream [fstream] as indicated:</span></i></p>

<pre>explicit basic_fstream(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins>
explicit basic_fstream(const string&amp; s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins>
...
void open(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins>
void open(const string&amp; s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>

<p><i><span style="background-color: #E1E9FD">Change 27.9.1.15 basic_fstream 
constructors [fstream.cons] as indicated:</span></i></p>

<pre>explicit basic_fstream(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>explicit basic_fstream(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins></pre>

<p><i><span style="background-color: #E1E9FD">To 27.9.1.15 basic_fstream 
constructors [fstream.cons] 
add:</span></i></p>
<pre><ins>explicit basic_fstream(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects: </i>the same as <code>basic_fstream(p.c_str(), mode)</code>.</ins></p>
</blockquote>
   
<p><i><span style="background-color: #E1E9FD">Change 27.9.1.17 Member functions [fstream.members] 
as indicated:</span></i></p>
   
<pre>void open(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
<ins>void open(const std::filesystem::path::value_type* s,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);  // wide systems only; see [fstreams]</ins></pre>
   
<p><i><span style="background-color: #E1E9FD">To 27.9.1.17 Member functions [fstream.members] 
add:</span></i></p>
<pre><ins>void open(const filesystem::path&amp; p,</ins>
    <ins>ios_base::openmode mode = ios_base::in|ios_base::out);</ins></pre>
   <blockquote>
  <p><ins><i>Effects:</i> calls <code>open(p.c_str(), mode)</code>.</ins></p>
</blockquote>






<hr>
<h3><a name="2677" href="#2677">2677.</a> <code>directory_entry::status</code> is not allowed to be cached as a quality-of-implementation issue</h3>
<p><b>Section:</b> 27.10.12.3 [directory_entry.obs] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Billy O'Neal <b>Opened:</b> 2016-03-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#directory_entry.obs">active issues</a> in [directory_entry.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#directory_entry.obs">issues</a> in [directory_entry.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>To fix multi-threading problems in <code>directory_entry</code>, caching behavior
was removed from the type. This is bad for performance reasons,
because the values can no longer be cached from the result of <code>readdir</code>
on POSIX platforms, or from <code>FindFirstFile/FindNextFile</code> on Windows.</p>

<p>It appears that the intent was to allow implementers to fill in the
values for <code>directory_entry::status</code> inside <code>directory_iterator</code>, but as
currently specified:</p>

    <blockquote><i>Returns:</i> <code>status(path()[, ec])</code>.</blockquote>

<p>This is not allowed to be cached, because the target of the path can
change. For example, consider the following program:</p>

<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;

using namespace std;
namespace fs = ::std::filesystem;

void verify(const bool b, const char * const msg) {
    if (!b) {
        printf("fail: %s\n", msg);
        exit(1);
    }
}

void touch_file(const char * const filename) {
    ofstream f(filename);
    f &lt;&lt; '\n' &lt;&lt; endl;
    verify(f.good(), "File write failed");
}

int main() {
    fs::remove_all("subDir");
    fs::create_directory("subDir");
    fs::create_directory("subDir/child");
    touch_file("subDir/child/child");
    fs::current_path("./subDir");
    fs::directory_iterator dir(".");
    ++dir;
    fs::directory_entry entry = *dir;

    verify(entry == "./child",
      "unexpected subdirectory"); //enumerating "subDir" returned the directory "child"

    fs::file_status status = entry.status();
    verify(status.type() == fs::file_type::directory,
        "subDir/child was not a directory");
    fs::current_path("./child");
    status = entry.status(); // REQUIRED to re-stat() on POSIX,
                             // GetFileAttributes() on Windows
    verify(status.type() == fs::file_type::regular,
        "subDir/child/child was not a regular file");
    return 0;
}</pre>

  <p>
    <code>directory_entry</code> should be re-specified to allow implementers to cache
    the value of <code>status(path)</code> at the time <code>irectory_iterator</code> was
    incremented to avoid repeated <code>stat()</code> / <code>GetFileAttributes</code> calls. (This
    may mean additional constructors are necessary for <code>directory_entry</code> as well)
  </p>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
Beman is working on a paper to address this.
</p>

<p><i>[2016-08, Beman comments]</i></p>

<p>This will be resolved by <a href="http://wg21.link/p0317r1">P0317R1</a>, Directory Entry Caching for Filesystem.</p>
<p>Fri AM: Moved to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2678" href="#2678">2678.</a> <tt>std::filesystem</tt> enum classes overspecified</h3>
<p><b>Section:</b> 27.10.10.1 [enum.file_type], 27.10.10.2 [enum.copy_options], 27.10.10.4 [enum.directory_options] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-03-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The enum class <tt>std::filesystem::file_type</tt> specifies a collection of enumerators for describing the type of 
a file, but also specifies (1) the numeric values of the enumerators, and (2) that an implementation cannot extend the 
list with additional types known to it (and by extension, the standard cannot extend the list in future versions without 
breakage).
</p>
<p>
These both seem like mistakes in the design. I would suggest we remove the 
specification of numerical values, and maybe also
</p>
<ul>
  <li><p>we allow implementations to add new implementation-defined value</p></li>
  <li><p>we replace <tt>std::filesystem::file_type::unknown</tt> with a value that <em>only</em> 
  means &quot;exists but type could not be determined&quot; and use 
  implementation-specific values for other possibilities.</p></li>
</ul>
 <p>
 Similar overspecification exists for <tt>std::filesystem::copy_options</tt> and 
 <tt>std::filesystem::directory_options</tt>, where again precise numerical values are specified.
 </p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Strike the "Value" column from:
</p>
<ul>
  <li><p>27.10.10.1 [enum.file_type], Table 145 Enum class <code>file_type</code> </p></li>
  <li><p>27.10.10.2 [enum.copy_options], Table 146 Enum class <code>copy_options</code> </p></li>
  <li><p>27.10.10.4 [enum.directory_options], Table 148 Enum class <code>enum.directory_options</code>.</p></li>
</ul>
</li>

<li><p>Change 27.10.10.1 [enum.file_type] Table 145 Enum class <code>file_type</code> as indicated:</p>

<blockquote>
 <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse">
    <tr>
      <td><b>Constant</b></td>
      <td><b>Meaning</b></td>
    </tr>
    <tr>
      <td><code>none</code></td>
      <td>The type of the file has not been determined or an error occurred 
      while trying to determine the type.</td>
    </tr>
    <tr>
      <td><code>not_found</code></td>
      <td>Pseudo-type indicating the file was not found. [ <i>Note:</i>
      The file not being
      found is not considered an error while determining the type of a file. 
      <i>end note</i> ]</td>
    </tr>
    <tr>
      <td><code>regular</code></td>
      <td>Regular file</td>
    </tr>
    <tr>
      <td><code>directory</code></td>
      <td>Directory file</td>
    </tr>
    <tr>
      <td><code>symlink</code></td>
      <td>Symbolic link file</td>
    </tr>
    <tr>
      <td><code>block</code></td>
      <td>Block special file</td>
    </tr>
    <tr>
      <td><code>character</code></td>
      <td>Character special file</td>
    </tr>
    <tr>
      <td><code>fifo</code></td>
      <td>FIFO or pipe file</td>
    </tr>
    <tr>
      <td><code>socket</code></td>
      <td>Socket file</td>
    </tr>
    <tr>
      <td><ins>implementation-<br/>defined</ins></td>
      <td><ins>Implementations that support file systems having file types
      in addition to the above file_type types shall supply
      implementation-defined <code>file_type</code> 
      constants to separately identify each of those additional
      file types</ins></td>
    </tr>
    <tr>
      <td><code>unknown</code></td>
      <td><del>The file does exist, but is of an operating system dependent type not 
      covered by any of the other cases or the process does not have permission to query
      the file type</del> <ins>The file exists but the type could not be determined</ins></td>
    </tr>
  </table>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2679" href="#2679">2679.</a> Inconsistent Use of Effects and Equivalent To</h3>
<p><b>Section:</b> 17.5.1.4 [structure.specifications] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Dawn Perchik <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#structure.specifications">active issues</a> in [structure.specifications].</p>
<p><b>View all other</b> <a href="lwg-index.html#structure.specifications">issues</a> in [structure.specifications].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<ul>
<li><p>
Some <i>Effects</i>: were intended to include the "Equivalent to" phrasing where no or different words were used.  
See examples in <tt>std::filesystem</tt> and throughout the library.
</p></li>
<li><p>
The wording in [structure.specifications]/4 is incorrect and <i>Effects</i>: throughout the library which use 
(or were intended to use) the "Equivalent to" phrasing need to be checked to make sure they fit the intended wording.
</p></li>
</ul>

<p><i>[2016-04, Issues Telecon]</i></p>

<p>
The PR is fine; but bullet #1 in the report really should have a list of places to change.
<p/>
Jonathan checked throughout the library for bullet #2 and found two problems in [string.access], 
which have been added to the PR.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>Change [structure.specifications]/4 as indicated:</p>

<blockquote>
<p>
"[&hellip;] if <tt>F</tt> has no <i>Returns</i>: element, a non-<tt>void</tt> return from <tt>F</tt> is specified by the 
<del>Returns: elements</del><ins>return statements</ins> in the code sequence."
</p>
</blockquote>
</li>

<li><p>Add two <tt>return</tt> keywords to [string.access]:</p>

<blockquote>
<pre>
const charT&amp; front() const;
charT&amp; front();
</pre>
<blockquote>
<p>-7- <i>Requires:</i> <code>!empty()</code>.</p>
<p>-8- <i>Effects:</i> Equivalent to <code><ins>return </ins>operator[](0)</code>.</p>
</blockquote>

<pre>
const charT&amp; back() const;
charT&amp; back();
</pre>
<blockquote>
<p>-9- <i>Requires:</i> <code>!empty()</code>.</p>
<p>-10- <i>Effects:</i> Equivalent to <code><ins>return </ins>operator[](size() - 1)</code>.</p>
</blockquote>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="2680" href="#2680">2680.</a> Add "Equivalent to" to filesystem</h3>
<p><b>Section:</b> 27.10 [filesystems] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Beman Dawes <b>Opened:</b> 2016-04-15 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>The IS project editors have requested that filesystem <i>Effects</i> elements specified purely as C++ code 
include the phrase "Equivalent to" if this is the intent. They do not consider this change to be editorial.</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>

<p><i><section>27.10.8.4.5 [path.modifiers]</section></i></p>
<blockquote>
<pre>path&amp; replace_filename(const path&amp; replacement);</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins></p>
<pre>remove_filename();
operator/=(replacement);</pre>
</blockquote>
</blockquote>

<p><i><section>27.10.8.6 [path.non-member]</section></i></p>
<blockquote>
<pre>void swap(path&amp; lhs, path&amp; rhs) noexcept;</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins> <code>lhs.swap(rhs)</code></p>
</blockquote>
</blockquote>

<p><i><section>27.10.8.6.1 [path.io]</section></i></p>
<blockquote>
<pre>template &lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins> <code>os &lt;&lt; quoted(p.string&lt;charT, traits&gt;())</code>.</p>
<pre></pre>
</blockquote>
</blockquote>

<p><i><section>27.10.8.6.1 [path.io]</section></i></p>
<blockquote>
<pre>template &lt;class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins></p>
<pre>basic_string&lt;charT, traits&gt; tmp;
is &gt;&gt; quoted(tmp);
p = tmp;</pre>
</blockquote>
</blockquote>

<p><i><section>27.10.15.3 [fs.op.copy]</section></i></p>
<blockquote>
<pre>void copy(const path&amp; from, const path&amp; to);
void copy(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins> <code>copy(from, to, copy_options::none)</code> or <code>copy(from, to, 
copy_options::none, ec)</code>, respectively.</p>
</blockquote>
</blockquote>

<p><i><section>27.10.15.5 [fs.op.copy_symlink]</section></i></p>
<blockquote>
<pre>void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink);
void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink,
  error_code&amp; ec) noexcept;</pre>
<blockquote>
<p><i>Effects:</i> <ins>Equivalent to:</ins> <code><i>function</i>(read_symlink(existing_symlink), new_symlink)</code> or
<code><i>function</i>(read_symlink(existing_symlink, ec), new_symlink, ec)</code>, respectively, 
where <code><i>function</i></code>
is <code>create_symlink</code> or <code>create_directory_symlink</code>, as appropriate.</p>
</blockquote>
</blockquote>







<hr>
<h3><a name="2681" href="#2681">2681.</a> <code>filesystem::copy()</code> cannot copy symlinks</h3>
<p><b>Section:</b> 27.10.15.3 [fs.op.copy] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-04-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fs.op.copy">active issues</a> in [fs.op.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.copy">issues</a> in [fs.op.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>27.10.15.3 [fs.op.copy] paragraph 3 bullet (3.4) says that if <code>is_symlink(f)</code> and
<code>copy_options</code> is set in options then it should copy a symlink, but that
case cannot be reached.</p>

<p><code>is_symlink(f)</code> can only be true if f was set using
<code>symlink_status(from)</code>, but that doesn't happen unless one of
<code>create_symlinks</code> or <code>skip_symlinks</code> is set in options. It should depend
on <code>copy_symlinks</code> too.</p>

<p>I'm not sure what the correct behaviour is, but I don't think we
want to simply add a check for <code>copy_symlinks</code> in bullet (3.1) because
that would mean that <code>t = symlink_status(to)</code>, and I don't think we want
that. Consider <code>'touch file; mkdir dir; ln -s dir link;'</code> and then
<code>filesystem::copy("file", "link",
filesystem::copy_options::copy_symlinks)</code>. If <code>t = symlink_status(to)</code>
then <code>is_directory(t) == false</code>, and we don't use bullet (3.5.4) but go
to (3.5.5) instead and fail. So when <code>copy_symlinks</code> is set we still
need to use <code>t = status(to)</code> as specified today.</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This is related to <a href="lwg-active.html#2682">2682</a>; and should be considered together.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>Modify paragraph 3 of 27.10.15.3 [fs.op.copy] as shown:</p>

<blockquote>
<p><i>Effects:</i> Before the first use of <code>f</code> and <code>t</code>:<br/><br/>
  If <code>(options &amp; copy_options::create_symlinks) != copy_options::none ||
(options &amp; copy_options::skip_symlinks) != copy_options::none</code>
then <code>auto f = symlink_status(from)</code> and if needed <code>auto t = symlink_status(to)</code>.<br/><br/>
<ins>
  Otherwise, if <code>(options &amp; copy_options::copy_symlinks) != copy_options::none</code>
then <code>auto f = symlink_status(from)</code> and if needed <code>auto t = status(to)</code>.
</ins><br/>
  Otherwise, <code>auto f = status(from)</code> and if needed <code>auto t = status(to)</code>.
</p>
</blockquote>





<hr>
<h3><a name="2682" href="#2682">2682.</a> <code>filesystem::copy()</code> won't create a symlink to a directory</h3>
<p><b>Section:</b> 27.10.15.3 [fs.op.copy] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-04-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#fs.op.copy">active issues</a> in [fs.op.copy].</p>
<p><b>View all other</b> <a href="lwg-index.html#fs.op.copy">issues</a> in [fs.op.copy].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>(First raised in c++std-lib-38544)</p>

<p><code>filesystem::copy</code> doesn't create a symlink to a directory in this case:</p>

<blockquote>
<code>copy("/", "root", copy_options::create_symlinks);</code>
</blockquote>

<p>If the first path is a file then a symlink is created, but I think my
implementation is correct to do nothing for a directory. We get to
bullet 27.10.15.3 [fs.op.copy] (3.6) where <code>is_directory(f)</code> is true, but <code>options
== create_symlinks</code>, so we go to the next bullet (3.7) which says
"Otherwise, no effects."</p>

<p>I think the case above should either create a symlink, or should
report an error. GNU cp -s gives an error in this case, printing
"omitting directory '/'". An error seems reasonable, you can use
<code>create_symlink</code> to create a symlink to a directory.
</p>

<p><i>[2016-05 Issues Telecon]</i></p>

<p>
This is related to <a href="lwg-active.html#2681">2681</a>; and should be considered together.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>Add a new bullet following (3.6) in 27.10.15.3 [fs.op.copy] as shown:</p>

<blockquote>
<ul>
<li><p>If <code>!exists(t)</code>, then <code>create_directory(to, from)</code>.</p></li>
<li><p>Then, iterate over the files in <code>from</code>, as if by <code>for (directory_entry&amp; x :
 directory_iterator(from))</code>, and for each iteration
  <code>copy(x.path(), to/x.path().filename(), options | copy_options::unspecified )</code></p></li>
<li><p><ins>Otherwise, if <code>is_directory(f) &amp;&amp; (options &amp;
copy_options::create_symlinks) != copy_options::none</code>, then report an
error with an <code>error_code</code> argument equal to
<code>make_error_code(errc::is_a_directory)</code>.</ins></p></li>
<li><p>Otherwise, no effects.</p></li>
</ul>
</blockquote>





<hr>
<h3><a name="2686" href="#2686">2686.</a> Why is <tt>std::hash</tt> specialized for <tt>error_code</tt>, but not <tt>error_condition</tt>?</h3>
<p><b>Section:</b> 19.5.1 [system_error.syn] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-05-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Both <tt>error_code</tt> and <tt>error_condition</tt> have an <tt>operator&lt;</tt> overload, 
enabling their use in associative containers without having to write a custom comparator. 
</p>
<p>
However, only <tt>error_code</tt> has a <tt>std::hash</tt>
specialization. So it's possible to have a
<tt>set&lt;error_code&gt;</tt>, a <tt>set&lt;error_condition&gt;</tt>,
an <tt>unordered_set&lt;error_code&gt;</tt>, but not an
<tt>unordered_set&lt;error_condition&gt;</tt>. This seems...odd.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Edit 19.5.1 [system_error.syn], header <tt>&lt;system_error&gt;</tt> synopsis, as indicated: </p>

<blockquote><pre>
namespace std {
    // ...

    // 19.5.6 Hash support
    template&lt;class T&gt; struct hash;
    template&lt;&gt; struct hash&lt;error_code&gt;;
    <ins>template&lt;&gt; struct hash&lt;error_condition&gt;;</ins>

   // ...
}
</pre></blockquote>
</li>
<li> <p> Edit 19.5.6 [syserr.hash] as indicated: </p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;error_code&gt;;
<ins>template &lt;&gt; struct hash&lt;error_condition&gt;;</ins>
</pre>

<blockquote>
<p>-1- The template specialization<ins>s</ins> shall meet the requirements of class template <tt>hash</tt> (20.12.14).</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2690" href="#2690">2690.</a> <tt>invoke&lt;R&gt;</tt></h3>
<p><b>Section:</b> 20.14.3 [func.invoke] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Zhihao Yuan <b>Opened:</b> 2016-03-25 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4169.html">N4169</a>
the author dropped the <tt>invoke&lt;R&gt;</tt> support by claiming
that it's an unnecessary cruft in TR1, obsoleted by C++11
type inference.  But now we have some new business went
to *<tt><i>INVOKE</i></tt>*<tt>(f, t1, t2, ..., tN, R)</tt>, that is to discard the
return type when <tt>R</tt> is <tt>void</tt>. This form is very useful, or
possible even more useful than the basic form when
implementing a call wrapper. Also note that the optional
<tt>R</tt> support is already in <tt>std::is_callable</tt> and
<tt>std::is_nothrow_callable</tt>.
</p>

<p><i>[2016-07-31, Tomasz Kami&nacute;ski comments]</i></p>

<p>
The lack of <tt>invoke&lt;R&gt;</tt> was basically a result of the concurrent publication of the never revision 
of the paper and additional special semantics of <tt><i>INVOKE</i>(f, args..., void)</tt>.
<p/>
In contrast to existing <tt>std::invoke</tt> function, the proposed <tt>invoke&lt;R&gt;</tt> version is not 
SFINAE friendly, as elimination of the standard version of invoke is guaranteed by <tt>std::result_of_t</tt> 
in the result type that is missing for proposed <tt>invoke&lt;R&gt;</tt> version. To provide this guarantee, 
following remarks shall be added to the specification:
</p>
<blockquote>
<p>
<i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_callable_v&lt;F(Args...), R&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>

<p><i>[2016-08-01, Tomasz Kami&nacute;ski and Zhihao Yuan update the proposed wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 20.14 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  <i>// 20.12.3, invoke:</i>
  template &lt;class F, class... Args&gt; result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);
  <ins>template &lt;class R, class F, class... Args&gt; R invoke(F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
</blockquote>
</li>

<li><p>Add the following sequence of paragraphs after 20.14.3 [func.invoke]/1 as indicated:</p>

<blockquote>
<pre>
<ins>template &lt;class R, class F, class... Args&gt; R invoke(F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt><i>INVOKE</i>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)..., R)</tt> 
(20.14.2 [func.require]).</ins>
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_callable_v&lt;F(Args...), R&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-09-04, Tomasz Kami&nacute;ski comments and improves wording]</i></p>

<p>
The usage of <tt>is_callable_v&lt;F(Args...), R&gt;</tt> causes problem in situation when either <tt>F</tt> or <tt>Args</tt> 
is an abstract type and the function type <tt>F(Args...)</tt> cannot be formed or when one of the args is <i>cv</i>-qualified, 
as top-level <i>cv</i>-qualification for function parameters is dropped by language rules. It should use 
<tt>is_callable_v&lt;F&amp;&amp;(Args&amp;&amp;...), R&gt;</tt> instead.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>
<ol>
<li><p>Modify 20.14 [function.objects]/2, header <tt>&lt;functional&gt;</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
namespace std {
  <i>// 20.12.3, invoke:</i>
  template &lt;class F, class... Args&gt; result_of_t&lt;F&amp;&amp;(Args&amp;&amp;...)&gt; invoke(F&amp;&amp; f, Args&amp;&amp;... args);
  <ins>template &lt;class R, class F, class... Args&gt; R invoke(F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
</blockquote>
</li>

<li><p>Add the following sequence of paragraphs after 20.14.3 [func.invoke]/1 as indicated:</p>

<blockquote>
<pre>
<ins>template &lt;class R, class F, class... Args&gt; R invoke(F&amp;&amp; f, Args&amp;&amp;... args);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Returns</i>: <tt><i>INVOKE</i>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)..., R)</tt> 
(20.14.2 [func.require]).</ins>
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_callable_v&lt;F&amp;&amp;(Args&amp;&amp;...), R&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2691" href="#2691">2691.</a> <tt>money_base::space</tt> and <tt>do_put</tt>: U+0020 versus <tt>fill</tt></h3>
<p><b>Section:</b> 22.4.6.3 [locale.moneypunct] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-12 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.moneypunct">issues</a> in [locale.moneypunct].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The description of <tt>money_base::space</tt> is that "at least one space is required at that position." 
(N4582 subclause 22.4.6.3 [locale.moneypunct] paragraph 2)
<p/>
When formatting for output (22.4.6.2.2 [locale.money.put.virtuals]), it is not clear that
</p>
<ol style="list-style-type:lower-alpha">
<li><p>
"the number of characters generated for the specified format" (excluding fill padding) includes exactly 
one character for <tt>money_base::space</tt> (if present), and
</p></li>
<li><p>
all characters corresponding to <tt>money_base::space</tt> (excluding fill padding) are copies of <tt>fill</tt>.
</p></li>
</ol>
<p>
In particular, there is implementation divergence over point (b) as to whether U+0020 or <tt>fill</tt> should be used.
Further, should a character other than <tt>fill</tt> be used, it is unclear when "the fill characters are 
placed where <tt>none</tt> or <tt>space</tt> appears in the formatting pattern", whether the fill characters are placed 
at the beginning or the end of the "space field".
<p/>
I believe that a strict interpretation of the current wording supports U+0020; however, <tt>fill</tt> is more likely 
to be the pragmatic choice.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Change 22.4.6.3 [locale.moneypunct] paragraph 2 as indicated:</p>

<blockquote>
<p>
-2- Where <tt>none</tt> or <tt>space</tt> appears, white space is permitted in the format, except where <tt>none</tt> 
appears at the end, in which case no white space is permitted. <ins>For input, the value <tt>space</tt> indicates that 
at least one space is required at that position. For output, the value <tt>space</tt> indicates one instance of the 
fill character (22.4.6.2.2 [locale.money.put.virtuals]).</ins><del>The value <tt>space</tt> indicates that at least one 
space is required at that position</del>. Where <tt>symbol</tt> appears, the sequence of characters returned by 
<tt>curr_symbol()</tt> is permitted, and can be required. Where <tt>sign</tt> appears, the first (if any) of the 
sequence of characters returned by <tt>positive_sign()</tt> or <tt>negative_sign()</tt> (respectively as the monetary 
value is non-negative or negative) is required. Any remaining characters of the sign sequence are required after all 
other format components. Where <tt>value</tt> appears, the absolute numeric monetary value is required.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2692" href="#2692">2692.</a> Overspecification of lvalueness of bitmask elements</h3>
<p><b>Section:</b> 17.5.2.1.3 [bitmask.types] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#bitmask.types">issues</a> in [bitmask.types].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The usual pattern now used for identifying where bitmask elements are declared, namely, as variables, preclude 
declaring them as enumerators.
<p/>
Compare: <tt>ctype_base::space</tt> in C++03 subclause 22.2.1 [lib.category.ctype] versus the same in N4582 
subclause 22.4.1 [category.ctype].
<p/>
It is unclear whether this is intentional. Further it is unclear if odr-use of bitmask elements is intended to be allowed.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Jonathan believes that this was intentional, and was done by N3110. 
Jonathan will provide more precise references.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2693" href="#2693">2693.</a> <tt>constexpr</tt> for various <tt>std::complex</tt> arithmetic and value operators</h3>
<p><b>Section:</b> 26.5 [complex.numbers] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Oliver Rosten <b>Opened:</b> 2016-04-14 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#complex.numbers">active issues</a> in [complex.numbers].</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.numbers">issues</a> in [complex.numbers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This modification will allow complex-number arithmetic to be performed at compile time. From a mathematical 
standpoint, it is natural (and desirable) to treat complex numbers on the same footing as the reals. 
From a programming perspective, this change will broaden the scope in which <tt>std::complex</tt> can be used, 
allowing it to be smoothly incorporated into classes exploiting <tt>constexpr</tt>.
<p/>
Suggested resolution:
<p/>
The following functions in the <tt>std::complex</tt> namespace should be made <tt>constexpr</tt>:
</p>
<ol>
<li><p>
Section 26.5.5 [complex.member.ops]: The member (arithmetic) operators 
{<tt>+=</tt>, <tt>-=</tt>, <tt>/=</tt>, <tt>*=</tt>}
</p></li>
<li><p>
Section 26.5.6 [complex.ops]: The arithmetic operators unary operators {<tt>+</tt>, <tt>-</tt>} 
and binary operators {<tt>+</tt>, <tt>-</tt>, <tt>/</tt>, <tt>*</tt>};
</p></li>
<li><p>
Section 26.5.7 [complex.value.ops]: The 'value' operators <tt>abs</tt>, <tt>norm</tt>, and <tt>conj</tt>.
</p></li>
</ol>
<p>
In terms of modification of the standard, all that is required is the insertion of the <tt>constexpr</tt> specifier 
in the relevant parts of:
</p>
<ol>
<li><p>
Section 26.5.1 [complex.syn] (the Header synopsis), together with the corresponding entries in sections 
26.5.6 [complex.ops] and 26.5.7 [complex.value.ops].
</p></li>
<li><p>
Sections 26.5.2 [complex], 26.5.3 [complex.special] (class template and specializations), together 
with the corresponding entries in section 26.5.5 [complex.member.ops].
</p></li>
</ol>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This kind of work (new feature) has been being done via papers rather than via the issues list.
</p>
<p>
Walter believes that he knows someone who would be willing to write such a paper.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2694" href="#2694">2694.</a> Application of LWG 436 accidentally deleted definition of "facet"</h3>
<p><b>Section:</b> 22.3.1.1.2 [locale.facet] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-04-15 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#locale.facet">issues</a> in [locale.facet].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[locale.facet]/1 (then-called [lib.locale.facet]) read in C++03:
</p>
<blockquote>
<p>
Class <tt>facet</tt> is the base class for locale feature sets. A class is a <i>facet</i> if it is publicly derived 
from another facet, or if it is a class derived from <tt>locale::facet</tt> and containing a publicly-accessible 
declaration as follows: [<i>Footnote</i>: This is a complete list of requirements; there are no other requirements. 
Thus, a facet class need not have a public copy constructor, assignment, default constructor, destructor, etc.]
</p>
<blockquote><pre>
static ::std::locale::id id;
</pre></blockquote>
<p>
Template parameters in this clause which are required to be facets are those named <tt>Facet</tt> in declarations. 
A program that passes a type that is <em>not</em> a facet, as an (explicit or deduced) template parameter to a locale 
function expecting a facet, is ill-formed.
</p>
</blockquote>
<p>
LWG <a href="lwg-defects.html#436">436</a>'s intent appears to be to ban <tt>volatile</tt>-qualified facets and permitting 
<tt>const</tt>-qualified ones. The PR was somewhat poorly worded, however, and the editor in applying 
it deleted the whole first half of the paragraph, including the definition of <i>facet</i> and the requirement 
for a static data member named <tt>id</tt>.
<p/>
As a result, we have things like 22.3.1.1.3 [locale.id]/2 and 22.3.2 [locale.global.templates]/1 referring 
to the <tt>id</tt> member that's not defined anywhere in the working draft.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Insert the following paragraph before 22.3.1.1.2 [locale.facet]/1:</p>

<blockquote>
<p>
<ins>-?- Class <tt>facet</tt> is the base class for locale feature sets. A class is a <i>facet</i> if it is publicly 
derived from another facet, or if it is a class derived from <tt>locale::facet</tt> and containing a publicly accessible 
declaration as follows: [<i>Footnote</i>: This is a complete list of requirements; there are no other requirements. Thus, a 
facet class need not have a public copy constructor, assignment, default constructor, destructor, etc.]</ins>
</p>
<blockquote><pre>
<ins>static ::std::locale::id id;</ins>
</pre></blockquote>
<p>
-1- Template parameters in this Clause which are required to be facets are those named <tt>Facet</tt> in declarations. A
program that passes a type that is <i>not</i> a facet, or a type that refers to a volatile-qualified facet, as an (explicit
or deduced) template parameter to a locale function expecting a facet, is ill-formed. A const-qualified facet is
a valid template argument to any locale function that expects a Facet template parameter.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2695" href="#2695">2695.</a> "As if" unclear in [member.functions]</h3>
<p><b>Section:</b> 17.6.5.5 [member.functions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-04-15 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#member.functions">active issues</a> in [member.functions].</p>
<p><b>View all other</b> <a href="lwg-index.html#member.functions">issues</a> in [member.functions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4582 subclause 17.6.5.5 [member.functions], the requirement that:
</p>
<blockquote><p>
any call to the member function that would select an overload from the set of declarations described in this 
standard behaves as if that overload were selected
</p></blockquote>
<p>
is unclear in the extent of the "as if". For example, in providing:
</p>
<blockquote><pre>
basic_string(const charT* s);
</pre></blockquote>
<p>
for a one-argument call to:
</p>
<blockquote><pre>
basic_string(const charT* s, const Allocator&amp; a = Allocator());
</pre></blockquote>
<p>
it can be read that an implementation may be required to call the copy constructor for the allocator since 
the core language rules for copy elision would not allow the "a" argument to be constructed directly into 
the member used to store the allocator.
<p/>
Clarification (even if just a note) would be appreciated.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
This is related to issue <a href="lwg-active.html#2563">2563</a>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2696" href="#2696">2696.</a> Interaction between <tt>make_shared</tt> and <tt>enable_shared_from_this</tt> is underspecified</h3>
<p><b>Section:</b> 20.11.2.2.6 [util.smartptr.shared.create] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Joe Gottman <b>Opened:</b> 2016-04-02 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.create">active issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.create">issues</a> in [util.smartptr.shared.create].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
For each public constructor of <tt>std::shared_ptr</tt>, the standard says that constructor <i>enables 
<tt>shared_from_this</tt></i> if that constructor is expected to initialize the internal <tt>weak_ptr</tt> 
of a contained <tt>enable_shared_from_this&lt;X&gt;</tt> object. But there are other ways to construct 
a <tt>shared_ptr</tt> than by using a public constructor. The template functions <tt>make_shared</tt> 
and <tt>allocate_shared</tt> both require calling a private constructor, since no public constructor 
can fulfill the requirement that at most one allocation is made. The standard does not specify that 
that private constructor enables <tt>shared_from_this</tt>; therefore in the following code:
</p>
<blockquote><pre>
struct Foo : public std::enable_shared_from_this&lt;Foo&gt; {};

int main() {
  auto p = std::make_shared&lt;Foo&gt;();
  assert(p == p-&gt;shared_from_this());
  return 0;
}
</pre></blockquote>
<p>
it is unspecified whether the assertion will fail.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Jonathan Wakely to provide updated wording.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Monday PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Change 20.11.2.2.6 [util.smartptr.shared.create] indicated:</p>

<blockquote><pre>
template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);
template&lt;class T, class A, class... Args&gt;
  shared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-6- <i>Remarks</i>: <ins>The <tt>shared_ptr</tt> constructor called by this function enables <tt>shared_from_this</tt> 
with the address of the newly constructed object of type <tt>T</tt>.</ins> Implementations should perform no more than 
one memory allocation. [<i>Note</i>: This provides efficiency equivalent to an intrusive smart 
pointer. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2697" href="#2697">2697.</a> [concurr.ts] Behavior of <tt>future/shared_future</tt> unwrapping constructor when given an invalid <tt>future</tt></h3>
<p><b>Section:</b> 99 [concurr.ts::futures.unique_future], 99 [concurr.ts::futures.shared_future] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-04-22 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#concurr.ts::futures.unique_future">active issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all other</b> <a href="lwg-index.html#concurr.ts::futures.unique_future">issues</a> in [concurr.ts::futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: concurr.ts</b></p>

<p>
In the concurrency TS, the future/shared_future unwrapping constructors
</p>
<blockquote><pre>
future(future&lt;future&lt;R&gt;&gt;&amp;&amp;) noexcept;
shared_future(future&lt;shared_future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre></blockquote>
<p>
appear to implicitly require <tt>rhs</tt> be valid (e.g., by referring to its shared state, and by requiring a 
<tt>valid() == true</tt> postcondition). However, they are also marked <tt>noexcept</tt>, suggesting that they 
are wide-contract, and also makes the usual suggested handling for invalid futures, throwing a 
<tt>future_error</tt>, impossible.
<p/>
Either the <tt>noexcept</tt> should be removed, or the behavior with an invalid future should be specified.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n4577.pdf">N4577</a>.
</p>
<ol style="list-style-type:upper-alpha">
<li><p><b>Alternative 1:</b></p>
<p>Strike the <tt>noexcept</tt> on these constructors in 99 [futures.unique_future]/1-2 and 
99 [futures.shared_future]/1-2, and optionally add a <i>Requires</i>: <tt>rhs.valid() == true</tt> 
paragraph.</p>
</li>

<li><p><b>Alternative 2:</b></p>
<p>
Specify that an empty (<tt>shared_</tt>)<tt>future</tt> object is constructed if <tt>rhs</tt> is invalid, and adjust 
the postcondition accordingly.
</p>
<ol>
<li><p>Edit 99 [futures.unique_future] as indicated:</p>

<blockquote><pre>
future(future&lt;future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>If <tt>rhs.valid() == false</tt>, constructs an empty <tt>future</tt> object that does not 
refer to a shared state. Otherwise, c</ins><del>C</del>onstructs a <tt>future</tt> object from the shared state 
referred to by <tt>rhs</tt>. The <tt>future</tt> becomes ready when one of the following occurs:
</p>
<ul>
<li><p>Both the <tt>rhs</tt> and <tt>rhs.get()</tt> are ready. The value or the exception from
<tt>rhs.get()</tt> is stored in the <tt>future</tt>'s shared state.</p></li>
<li><p><tt>rhs</tt> is ready but <tt>rhs.get()</tt> is invalid. An exception of type
<tt>std::future_error</tt>, with an error condition of <tt>std::future_errc::broken_promise</tt>
is stored in the <tt>future</tt>'s shared state.</p></li>
</ul>
<p>
-4- <i>Postconditions</i>:
</p>
<ul>
<li><p><del><tt>valid() == true</tt></del><ins><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> prior to 
the constructor invocation.</ins>.</p></li>
<li><p><tt>rhs.valid() == false</tt>.</p></li>
</ul>
</blockquote>
</blockquote>
</li>

<li><p>Edit 99 [futures.shared_future] as indicated:</p>

<blockquote><pre>
shared_future(future&lt;shared_future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Effects</i>: <ins>If <tt>rhs.valid() == false</tt>, constructs an empty <tt>shared_future</tt> object that does not 
refer to a shared state. Otherwise, c</ins><del>C</del>onstructs a <tt>shared_future</tt> object from the shared state 
referred to by <tt>rhs</tt>. The <tt>shared_future</tt> becomes ready when one of the following occurs:
</p>
<ul>
<li><p>Both the <tt>rhs</tt> and <tt>rhs.get()</tt> are ready. The value or the exception from
<tt>rhs.get()</tt> is stored in the <tt>shared_future</tt>'s shared state.</p></li>
<li><p><tt>rhs</tt> is ready but <tt>rhs.get()</tt> is invalid. The <tt>shared_future</tt>
stores an exception of type <tt>std::future_error</tt>, with an error condition of
<tt>std::future_errc::broken_promise</tt>.</p></li>
</ul>
<p>
-4- <i>Postconditions</i>:
</p>
<ul>
<li><p><del><tt>valid() == true</tt></del><ins><tt>valid()</tt> returns the same value as <tt>rhs.valid()</tt> prior to 
the constructor invocation.</ins>.</p></li>
<li><p><tt>rhs.valid() == false</tt>.</p></li>
</ul>
</blockquote>
</blockquote>
</li>
</ol>

</li>
</ol>





<hr>
<h3><a name="2699" href="#2699">2699.</a> Missing restriction in [numeric.requirements]</h3>
<p><b>Section:</b> 26.3 [numeric.requirements] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4582 subclause 26.3 [numeric.requirements], the "considerable flexibility in how arrays are initialized" 
do not appear to allow for replacement of calls to the default constructor with calls to the copy constructor with 
an appropriate source value.
</p>

<p><i>[2016-08-03 Chicago]</i></p>

<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>
<ol>
<li><p>Adjust 26.3 [numeric.requirements]/1 as indicated:</p>

<blockquote>
<p>
-1- The <tt>complex</tt> and <tt>valarray</tt> components are parameterized by the type of information they contain and
manipulate. [&hellip;]
</p>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; <tt>T</tt> is not an abstract class (it has no pure virtual member functions);</p></li>
<li><p>[&hellip;]</p></li>
<li><p>(1.8) &mdash; If <tt>T</tt> is a class, its assignment operator, copy and default constructors, and 
destructor shall correspond to each other in the following sense: <ins>Initialization of raw storage using 
the copy constructor on the value of <tt>T()</tt>, however obtained, is semantically equivalent to value 
initialization of the same raw storage.</ins> Initialization of raw storage using the 
default constructor, followed by assignment, is semantically equivalent to initialization of raw storage 
using the copy constructor. Destruction of an object, followed by initialization of its raw storage using 
the copy constructor, is semantically equivalent to assignment to the original object.
[<i>Note</i>: This rule states<ins>, in part,</ins> that there shall not be any subtle differences in the 
semantics of initialization versus assignment. This gives an implementation considerable flexibility in how 
arrays are initialized.
[<i>Example</i>: An implementation is allowed to initialize a <tt>valarray</tt> by allocating storage using the 
<tt>new</tt> operator (which implies a call to the default constructor for each element) and then assigning each
element its value. Or the implementation can allocate raw storage and use the copy constructor to
initialize each element. &mdash; <i>end example</i>]
If the distinction between initialization and assignment is important for a class, or if it fails to satisfy any
of the other conditions listed above, the programmer should use <tt>vector</tt> (23.3.11) instead of <tt>valarray</tt>
for that class; &mdash; <i>end note</i>]</p></li>
</ol>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2702" href="#2702">2702.</a> <tt>num_put::do_put(..., bool)</tt> performs ill-formed <tt>do_put</tt> call</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-07 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The call to <tt>do_put(out, str, fill, (int)val)</tt> in N4582 subclause 22.4.2.2.2 [facet.num.put.virtuals] 
paragraph 6 cannot select a best viable function in overload resolution given the overloads listed for 
<tt>do_put</tt> in 22.4.2.2 [locale.nm.put].
<p/>
There is implementation divergence:
</p>
<ul>
<li><p>Some implementations call the <tt>long</tt> overload (as overriden);</p></li>
<li><p>some implementations call the <tt>unsigned long</tt> overload (as overriden);</p></li>
<li><p>some implementations call something else.</p></li>
</ul>
<p>
It appears that the resolution to DR <a href="lwg-defects.html#359">359</a> attempted a fix; however, the relevant portion of the 
change was not applied to the WP.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2703" href="#2703">2703.</a> No provision for fill-padding when <tt>boolalpha</tt> is set</h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-07 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
N4582 subclause 22.4.2.2.2 [facet.num.put.virtuals] paragraph 6 makes no provision for fill-padding in its 
specification of the behaviour when <tt>(str.flags() &amp; ios_base::boolalpha) != 0</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2705" href="#2705">2705.</a> Questionable precondition on Sequence containers <tt>a.assign(n, t)</tt></h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Kazutoshi Satoda <b>Opened:</b> 2016-05-08 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Please look through the following modifications on a value <tt>v</tt> of type <tt>vector&lt;T&gt;</tt>:
</p>
<blockquote><pre>
assert(v.size() &gt; 0);
v.push_back(v[0]);
v.insert(v.begin(), v[0]);
v.resize(v.size() * 2, v[0]);
v.assign(v.size() * 2, v[0]);
</pre></blockquote>
<p>
All of these use an element of itself which may be moved or destroyed by
the modification.
<p/>
From what I see so far, the first three are required to work. Please
see library issue <a href="lwg-closed.html#526">526</a> for validity of them.
<p/>
But only the last one is undefined because it violates a precondition of
a sequence container operation. I think this is too subtle.
<p/>
Should it be like that, really?
<p/>
The precondition is in Table 107 "Sequence container requirements" at the next 
of 23.2.3 [sequence.reqmts] p3.
</p>
<blockquote>
<p>
In Tables 107 and 108, <tt>X</tt> denotes a sequence container class,
<tt>a</tt> denotes a value of <tt>X</tt> containing elements of type <tt>T</tt>,
[&hellip;] <tt>n</tt> denotes a value of <tt>X::size_type</tt>,
[&hellip;] <tt>t</tt> denotes an lvalue or a <tt>const</tt> rvalue of <tt>X::value_type</tt>,
[&hellip;]
</p>
<p>[&hellip;]</p>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>a.assign(n, t)</tt>
</td>
<td><tt>void</tt></td>
<td>
<i>Requires</i>: <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>X</tt> and <tt>CopyAssignable</tt>.<br/>
pre: <tt>t</tt> is not a reference into <tt>a</tt>.<br/>
Replaces elements in <tt>a</tt> with <tt>n</tt> copies of <tt>t</tt>.
</td>
</tr>
</table>
</blockquote>
<p>
I looked into the following implementations:
</p>
<ul>
<li><p>
libc++ relies on the precondition.
<p/>
It deallocates first on <tt>n &gt; capacity()</tt> case,
see <a href="https://github.com/llvm-mirror/libcxx/blob/release_38/include/vector#L1415">here</a>.
</p></li>
<li><p>
libstdc++ doesn't rely on the precondition.
<p/>
It creates temporary <tt>vector(n, t)</tt> and <tt>swap()</tt>
on <tt>n &gt; capacity()</tt> case, see
<a href="https://github.com/gcc-mirror/gcc/blob/gcc_5_3_0_release/libstdc%2B%2B-v3/include/bits/vector.tcc#L223">here</a>.
</p></li>
<li><p>
MSVC relies on the precondition.
<p/>
It unconditionally does <tt>clear()</tt> and then <tt>insert(begin(), n, t)</tt>.
I looked into my local "%PROGRAMFILES(X86)%/Microsoft Visual Studio 14.0/VC/include/vector".
</p></li>
</ul>
<p>
One drawback of libstdc++ implementation, I could find so far, is
possibly increased peek memory usage (both old and new buffer exist at
the same time). But, because the same can happen on the most other
modifications, it seems a reasonable trade-off to remove the
precondition to fill the subtle gap. Users who really needs less memory
usage can do <tt>clear()</tt> and <tt>insert()</tt> by themselves.
<p/>
I also found that <tt>basic_string::assign(n, c)</tt> is safe on this point.
At 21.3.1.6.3 [string::assign] p17:
</p>
<blockquote>
<pre>
basic_string&amp; assign(size_type n, charT c);
</pre>
<blockquote>
<p>
<i>Effects</i>: Equivalent to <tt>assign(basic_string(n, c))</tt>.
<p/>
<i>Returns</i>: <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
<p>
This can be seen as another gap.
<p/>
Looking back on the history, I found that the definition of <tt>assign(n, t)</tt>
was changed at C++14 for library issue <a href="lwg-defects.html#2209">2209</a>. There were more restricting 
definitions like this:
</p>
<blockquote>
<pre>
void assign(size_type n, const T&amp; t);
</pre>
<blockquote>
<p>
<i>Effects</i>:
</p>
<blockquote><pre>
erase(begin(), end());
insert(begin(), n, t);
</pre></blockquote>
</blockquote>
</blockquote>
<p>
I think the precondition was probably set to accept this old definition
and is not required inherently. And if the less memory usage was really
intended, the standard is now underspecifying about that.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Howard believes this should be NAD, but we tabled the discussion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>In 23.2.3 [sequence.reqmts], edit Table 107 (Sequence container requirements) as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Sequence container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br/>pre-&#47;post-condition</th>
</tr>
<tr>
<td colspan="3" align="center">
<tt>[&hellip;]</tt>
</td>
</tr>
<tr>
<td>
<tt>a.assign(n, t)</tt>
</td>
<td><tt>void</tt></td>
<td>
<i>Requires</i>: <tt>T</tt> shall be <tt>CopyInsertable</tt> into <tt>X</tt> and <tt>CopyAssignable</tt>.<br/>
<del>pre: <tt>t</tt> is not a reference into <tt>a</tt>.</del><br/> 
Replaces elements in <tt>a</tt> with <tt>n</tt> copies of <tt>t</tt>.
</td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2708" href="#2708">2708.</a> <tt>recursive_directory_iterator::recursion_pending()</tt> is incorrectly specified</h3>
<p><b>Section:</b> 27.10.14.1 [rec.dir.itr.members] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-05-09 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all other</b> <a href="lwg-index.html#rec.dir.itr.members">issues</a> in [rec.dir.itr.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <tt>recursion_pending()</tt> says (27.10.14.1 [rec.dir.itr.members]/24):
</p>
<blockquote><p>
<i>Returns</i>: <tt>true</tt> if <tt>disable_recursion_pending()</tt> has not been called subsequent to the prior construction 
or increment operation, otherwise <tt>false</tt>.
</p></blockquote>
<p>
This language does not take into account cases where the prior construction was a copy construction from a iterator, 
<tt>it</tt>, where <tt>it.recursion_pending() == false</tt>. 
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Open</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4582.
</p>

<ol>
<li><p>Change 27.10.14.1 [rec.dir.itr.members] as indicated:</p>

<blockquote>
<pre>
explicit recursive_directory_iterator(const path&amp; p);
recursive_directory_iterator(const path&amp; p, directory_options options);
recursive_directory_iterator(const path&amp; p, directory_options options, error_code&amp; ec) noexcept;
recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Postcondition</i>: <del><tt>options() == options</tt> for the signatures with a <tt>directory_options</tt> argument, 
otherwise <tt>options() == directory_options::none</tt>.</del>
</p>
<ul>
<li><p><ins><tt>options() == options</tt> for the signatures with a <tt>directory_options</tt> argument, otherwise 
<tt>options() == directory_options::none</tt>.</ins></p></li>
<li><p><ins><tt>recursion_pending() == true</tt>.</ins></p></li>
</ul>
<p>
[&hellip;]
</p>
</blockquote>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The following changes the specification of <tt>recursion_pending()</tt> seemingly recursive. 
Perhaps it would be easier to specify <tt>recursion_pending()</tt> in terms of a exposition only member in 
<tt>recursive_directory_iterator</tt>.]
</p>
</blockquote>
<pre>
bool recursion_pending() const;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-24- <i>Returns</i>: <del><tt>true</tt> if <tt>disable_recursion_pending()</tt> has not been called subsequent to the 
prior construction or increment operation, otherwise <tt>false</tt></del><ins><tt>false</tt> if 
<tt>disable_recursion_pending()</tt> has been called subsequent to the prior construction or increment operation, 
otherwise the value of <tt>recursion_pending()</tt> set by that operation</ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
recursive_directory_iterator&amp; operator++();
recursive_directory_iterator&amp; increment(error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-27- <i>Effects</i>: As specified by Input iterators (24.2.3), except that: [&hellip;]
<p/>
<ins>-?- <i>Postcondition</i>: <tt>recursion_pending() == true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2712" href="#2712">2712.</a> <tt>copy_file(from, to, ...)</tt> has a number of unspecified error conditions</h3>
<p><b>Section:</b> 27.10.15.4 [fs.op.copy_file] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-05-10 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are a number of error cases that <tt>copy_file(from, to, ...)</tt> does not take into account.
Specifically the cases where:
</p>
<ol style="list-style-type:upper-alpha">
<li><tt>from</tt> does not exist</li>
<li><tt>from</tt> is not a regular file</li>
<li><tt>to</tt> exists and is not a regular file</li>
</ol>
<p>
These error cases should be specified as such.
</p>

<p><i>[2016-05 Issues Telecom]</i></p>

<p>
Eric to provide wording.
</p>

<p><i>[2016-05-28, Eric Fiselier provides wording]</i></p>


<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Modify 27.10.15.4 [fs.op.copy_file] as indicated:</p>

<blockquote>
<pre>
bool copy_file(const path&amp; from, const path&amp; to, copy_options options);
bool copy_file(const path&amp; from, const path&amp; to, copy_options options,
               error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-3- <i>Requires:</i> At most one constant from each <tt>copy_options</tt> option group (27.10.10.2) is present in
<tt>options</tt>.
<p/>
-4- <i>Effects:</i> Report a file already exists error as specified in Error reporting (27.5.6.5) if:
</p>
<ul>
<li><ins><tt>!is_regular_file(from)</tt>, or</ins></li>
<li><ins><tt>exists(to)</tt> and <tt>!is_regular_file(to)</tt>, or</ins></li>
<li><tt>exists(to)</tt> and <tt>equivalent(from, to)</tt>, or</li>
<li><tt>exists(to)</tt> and <tt>(options &amp; (copy_options::skip_existing | copy_options::overwrite_existing | 
copy_options::update_existing)) == copy_options::none</tt>.</li>
</ul>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2713" href="#2713">2713.</a> More missing allocator-extended constructors for unordered containers</h3>
<p><b>Section:</b> 23.5 [unord] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-20 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#unord">issues</a> in [unord].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The resolution of LWG <a href="lwg-defects.html#2210">2210</a> missed constructors accepting a range or initializer list and allocator.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Add to the synopsis in 23.5.4.1 [unord.map.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_map(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_map(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.5.1 [unord.multimap.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_multimap(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_multimap(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.6.1 [unord.set.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_set(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_set(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Add to the synopsis in 23.5.7.1 [unord.multiset.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
      : unordered_multiset(f, l, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
      : unordered_multiset(il, <em>see below</em>, hasher(), key_equal(), a) { }</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>
</ol>

</blockquote>

<p><i>[2016-06, Oulu &mdash; Daniel comments and provides new wording]</i></p>

<p>
During the LWG discussion of this issue it has been observed, that the interpretation of the embedded <i>see below</i>
is not really clear and that we should split declaration and definition of the new overloads, so that we have a place
that allows us to specify what "<i>see below</i>" stands for. In addition, the new wording wraps the "<i>see below</i>"
as "<tt>size_type(<i>see below</i>)</tt>" to clarify the provided expression type, similar as we did for the default
constructor of <tt>unordered_map</tt>.
</p>

<p><i>[Oulu, 2016-06]</i></p>

<p>Alisdair to review wording.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Add to the synopsis in 23.5.4.1 [unord.map.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_map {
  public:
    [&hellip;]
    unordered_map(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_map(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_map(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_map(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.4.2 [unord.map.cnstr] p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_map(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_map(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_map(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_map(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.5.1 [unord.multimap.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key, class T,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; {
  class unordered_multimap {
  public:
    [&hellip;]
    unordered_multimap(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multimap(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.5.2 [unord.multimap.cnstr] p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multimap(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multimap(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multimap(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multimap(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.6.1 [unord.set.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_set {
  public:
    [&hellip;]
    unordered_set(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_set(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_set(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.6.2 [unord.set.cnstr] p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_set(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_set(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_set(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_set(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Add to the synopsis in 23.5.7.1 [unord.multiset.overview] p3:</p>

<blockquote>
<pre>
namespace std {
  template &lt;class Key,
    class Hash = hash&lt;Key&gt;,
    class Pred = std::equal_to&lt;Key&gt;,
    class Allocator = std::allocator&lt;Key&gt; &gt; {
  class unordered_multiset {
  public:
    [&hellip;]
    unordered_multiset(size_type n, const hasher&amp; hf, const allocator_type&amp; a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    <ins>template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a);</ins>
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template &lt;class InputIterator&gt;
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
            const allocator_type&amp; a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    <ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);</ins>
    unordered_multiset(initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>Insert the following new prototype specification just after 23.5.7.2 [unord.multiset.cnstr] p2</p>

<blockquote>
<pre>
<ins>template &lt;class InputIterator&gt;
  unordered_multiset(InputIterator f, InputIterator l, const allocator_type&amp; a)
    : unordered_multiset(f, l, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>

<ins>unordered_multiset(initializer_list&lt;value_type&gt; il, const allocator_type&amp; a)
  : unordered_multiset(il, size_type(<em>see below</em>), hasher(), key_equal(), a) { }</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Remarks:</i> The number of buckets is implementation-defined.</ins>
</p>
</blockquote>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="2714" href="#2714">2714.</a> <tt>complex</tt> stream extraction underspecified</h3>
<p><b>Section:</b> 26.5.6 [complex.ops] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-05-23 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#complex.ops">issues</a> in [complex.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The specification of <tt>operator&gt;&gt;(istream&amp;, complex&lt;T&gt;&amp;)</tt> is extremely short on details. 
It currently reads, in its entirety (26.5.6 [complex.ops]/12-15):
</p>
<blockquote class="note">
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp; operator>>(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
<i>Effects:</i> Extracts a complex number <tt>x</tt> of the form: <tt>u</tt>, <tt>(u)</tt>, or <tt>(u,v)</tt>, 
where <tt>u</tt> is the real part and <tt>v</tt> is the imaginary part (27.7.2.2 [istream.formatted]).
<p/>
<i>Requires:</i> The input values shall be convertible to <tt>T</tt>.
<p/>
If bad input is encountered, calls <tt>is.setstate(ios_base::failbit)</tt> (which may throw <tt>ios::failure</tt> 
(27.5.5.4 [iostate.flags])).
<p/>
<i>Returns:</i> <tt>is</tt>.
<p/>
<i>Remarks:</i> This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace 
is specified to be the same for each of the simpler extractions.
</p>
</blockquote>
</blockquote>
<p>
It is completely unclear:
</p>
<ul>
<li>which "simpler extractions" are performed,</li>
<li>how the extracted characters are matched to the special characters <tt>'('</tt>, <tt>')'</tt> and <tt>','</tt> 
(by <tt>==</tt>, or by <tt>traits::eq</tt>),</li>
<li>what is left in the stream on failure. (For example, with <tt>"(0, 0]"</tt>, libstdc++ extracts the <tt>]</tt> 
while libc++ leaves it in the stream.)</li>
</ul>


<p><b>Proposed resolution:</b></p>
<blockquote class="note">
<i>Drafting note:</i> the following wording is based on:
<ul>
<li> Characters are extracted using <tt>operator&gt;&gt;</tt> and compared using <tt>traits::eq</tt>.</li>
<li> Mismatched characters are returned to the stream. </li>
</ul>
</blockquote>
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Replace 26.5.6 [complex.ops]/12-15 with the following paragraphs:</p>

<blockquote>
<pre>
template&lt;class T, class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator>>(basic_istream&lt;charT, traits&gt;&amp; is, complex&lt;T&gt;&amp; x);
</pre>
<blockquote>
<p>
-?- <i>Effects:</i> First, extracts a character from <tt>is</tt>.
<ul>
<li>If the character extracted is equal to <tt>is.widen('(')</tt>, extracts an object <tt>u</tt> of type <tt>T</tt> from <tt>is</tt>, then extracts a character from <tt>is</tt>.
<ul>
    <li>
    If this character is equal to <tt>is.widen(')')</tt>, then assigns <tt>complex&lt;T&gt;(u)</tt> to <tt>x</tt>.
    </li>
    <li>
      Otherwise, if this character is equal to <tt>is.widen(',')</tt>, extracts an object <tt>v</tt> of type <tt>T</tt> from <tt>is</tt>,
      then extracts a character from <tt>is</tt>.
      If this character is equal to <tt>is.widen(')')</tt>, then assigns <tt>complex&lt;T&gt;(u, v)</tt> to <tt>x</tt>;
      otherwise returns the character to <tt>is</tt> and the extraction fails.
    </li>
    <li>
      Otherwise, returns the character to <tt>is</tt> and the extraction fails.
    </li>
  </ul>
</li>
<li> Otherwise, returns the character to <tt>is</tt>, extracts an object <tt>u</tt> of type <tt>T</tt> from <tt>is</tt>, and assigns <tt>complex&lt;T&gt;(u)</tt> to <tt>x</tt>.
</li>
</ul>
In the description above, characters are extracted from <tt>is</tt> as if by <tt>operator&gt;&gt;</tt> (27.7.2.2.3 [istream::extractors]), and returned
to the stream as if by <tt>basic_istream::putback</tt> (27.7.2.3 [istream.unformatted]). Character equality is determined using <tt>traits::eq</tt>.
An object <tt>t</tt> of type <tt>T</tt> is extracted from <tt>is</tt> as if by <tt> is &gt;&gt; t</tt>.
<p/>
If any extraction operation fails, no further operation is performed and the whole extraction fails.
<p/>
On failure, calls <tt>is.setstate(ios_base::failbit)</tt> (which may throw <tt>ios::failure</tt>
(27.5.5.4 [iostate.flags])).
<p/>
-?- <i>Returns:</i> <tt>is</tt>.
<p/>
-?- [<i>Note</i>: This extraction is performed as a series of simpler extractions. Therefore, the skipping of whitespace
is specified to be the same for each of the simpler extractions. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2715" href="#2715">2715.</a> What is 'aggregate initialization syntax'?</h3>
<p><b>Section:</b> 29.5 [atomics.types.generic] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.generic">active issues</a> in [atomics.types.generic].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
29.5 [atomics.types.generic] mentions 'aggregate initialization syntax'. It's unclear what it stands for, 
especially since atomic types are actually not aggregate types (they have user-provided constructors).
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2717" href="#2717">2717.</a> <tt>scoped_allocator_adaptor</tt> uses <tt>forward</tt> to do <tt>move</tt>'s job</h3>
<p><b>Section:</b> 20.13.4 [allocator.adaptor.members] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-05-24 <b>Last modified:</b> 2016-08-01</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#allocator.adaptor.members">active issues</a> in [allocator.adaptor.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.adaptor.members">issues</a> in [allocator.adaptor.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>scoped_allocator_adaptor</tt> is specified to use <tt>forward</tt> when
what it is really doing is moving elements. It should use <tt>move</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Edit 20.13.4 [allocator.adaptor.members] p15 as indicated:</p>

<blockquote><pre>
template &lt;class T1, class T2, class U, class V&gt;
  void construct(pair&lt;T1, T2&gt;* p, pair&lt;U, V&gt;&amp;&amp; x);
</pre>
<blockquote>
<p>
<em>Effects:</em> Equivalent to <tt>this-&gt;construct(p, piecewise_construct, 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;U&gt;(x.first)), 
forward_as_tuple(std::<del>forward</del><ins>move</ins>&lt;V&gt;(x.second)))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Withdrawn by the submitter, since the prerequisites were incorrect.
</p>





<hr>
<h3><a name="2722" href="#2722">2722.</a> <tt>equivalent</tt> incorrectly specifies throws clause</h3>
<p><b>Section:</b> 27.10.15.13 [fs.op.equivalent] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-05-28 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The spec for <tt>equivalent</tt> has a throws clause which reads: [fs.op.equivalent]/5
</p>
<blockquote>
<p>
<i>Throws:</i> <tt>filesystem_error</tt> if <tt>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) 
&amp;&amp; is_other(s2))</tt>, otherwise as specified in Error reporting (27.10.7).
</p>
</blockquote>
<p>
This explicit requirement to throw is incorrect for the <tt>equivalent</tt> overload which takes an <tt>error_code</tt>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4582.</p>
<ol>
<li><p>Modify 27.10.15.13 [fs.op.equivalent] as follows:</p>

<blockquote>
<pre>
bool equivalent(const path&amp; p1, const path&amp; p2);
bool equivalent(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Determines <tt>file_status s1</tt> and <tt>s2</tt>, as if by <tt>status(p1)</tt> and 
<tt>status(p2)</tt>, respectively.
<p/>
-2- <i>Returns:</i> <ins>If <tt>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; is_other(s2))</tt> 
an error is reported (27.10.7 [fs.err.report]). Otherwise</ins> <tt>true</tt>, if <tt>s1 == s2</tt> and 
<tt>p1</tt> and <tt>p2</tt> resolve to the same file system entity, else <tt>false</tt>. The signature with argument 
<tt>ec</tt> returns <tt>false</tt> if an error occurs.
<p/>
-3- Two paths are considered to resolve to the same file system entity if two candidate entities reside on the
same device at the same location. This is determined as if by the values of the POSIX <tt>stat</tt> structure,
obtained as if by <tt>stat()</tt> for the two paths, having equal <tt>st_dev</tt> values and equal <tt>st_ino</tt> values.
<p/>
-4- <i>Throws:</i> <del><tt>filesystem_error</tt> if <tt>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; 
is_other(s2))</tt>, otherwise a</del><ins>A</ins>s specified in <del>E</del><ins>e</ins>rror reporting 
(27.10.7 [fs.err.report]).
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-06 Oulu &mdash; Daniel provides wording improvements]</i></p>

<p>
mc: do we have an error reporting clause?<br/>
jw: there is no such clause<br/>
gr: it should go into the effects clause<br/>
dk: we have the same issue for <tt>file_size</tt><br/>
dk: the right place is the effects clause
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Modify 27.10.15.13 [fs.op.equivalent] as follows:</p>

<blockquote>
<pre>
bool equivalent(const path&amp; p1, const path&amp; p2);
bool equivalent(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;
</pre>
<blockquote>
<p>
-1- Let <tt>s1</tt> and <tt>s2</tt> be <tt>file_status</tt>s, determined as if by <tt>status(p1)</tt> and <tt>status(p2)</tt>, respectively.
<p/>
-2- <i>Effects:</i> Determines <tt>s1</tt> and <tt>s2</tt>. <ins>If <tt>(!exists(s1) &amp;&amp; !exists(s2)) || 
(is_other(s1) &amp;&amp; is_other(s2))</tt> an error is reported (27.10.7 [fs.err.report]).</ins>
<p/>
-3- <i>Returns:</i> <tt>true</tt>, if <tt>s1 == s2</tt> and 
<tt>p1</tt> and <tt>p2</tt> resolve to the same file system entity, else <tt>false</tt>. The signature with argument 
<tt>ec</tt> returns <tt>false</tt> if an error occurs.
<p/>
-4- Two paths are considered to resolve to the same file system entity if two candidate entities reside on the
same device at the same location. This is determined as if by the values of the POSIX <tt>stat</tt> structure,
obtained as if by <tt>stat()</tt> for the two paths, having equal <tt>st_dev</tt> values and equal <tt>st_ino</tt> values.
<p/>
-5- <i>Throws:</i> <del><tt>filesystem_error</tt> if <tt>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; 
is_other(s2))</tt>, otherwise a</del><ins>A</ins>s specified in <del>E</del><ins>e</ins>rror reporting 
(27.10.7 [fs.err.report]).
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2729" href="#2729">2729.</a> Missing SFINAE on <tt>std::pair::operator=</tt></h3>
<p><b>Section:</b> 20.4.2 [pairs.pair], 20.5.2.2 [tuple.assign] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-06-07 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#pairs.pair">active issues</a> in [pairs.pair].</p>
<p><b>View all other</b> <a href="lwg-index.html#pairs.pair">issues</a> in [pairs.pair].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::is_copy_assignable&lt;std::pair&lt;int, std::unique_ptr&lt;int&gt;&gt;&gt;::value</tt> is <tt>true</tt>, and 
should be <tt>false</tt>. We're missing a "shall not participate in overload resolution unless" for <tt>pair</tt>'s 
<tt>operator=</tt>, and likewise for <tt>tuple</tt>.
</p>

<p><i>[2016-08-03 Chicago LWG]</i></p>

<p>
Inspired by Eric Fiselier and Ville, Walter and Nevin provide initial Proposed Resolution.
</p>

<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs PM: Moved to Tentatively Ready</p>
<p>Lots of discussion, but no one had a better idea.</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 20.4.2 [pairs.pair] as indicated:</p>

<blockquote>
<pre>
pair&amp; operator=(const pair&amp; p);
</pre>
<blockquote>
<p>
-15- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_copy_assignable_v&lt;first_type&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;second_type&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class V&gt; pair&amp; operator=(const pair&lt;U, V&gt;&amp; p);
</pre>
<blockquote>
<p>
-18- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;first_type&amp;, const U&amp;&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;second_type&amp;, const V&amp;&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
pair&amp; operator=(pair&amp;&amp; p) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-21- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T1&gt; &amp;&amp; is_nothrow_move_assignable_v&lt;T2&gt;
</pre></blockquote>
<p>
-22- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_move_assignable_v&lt;first_type&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;second_type&gt;</tt> is <tt>true</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class U, class V&gt; pair&amp; operator=(pair&lt;U, V&gt;&amp;&amp; p);
</pre>
<blockquote>
<p>
-25- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;first_type&amp;, U&amp;&amp;&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;second_type&amp;, V&amp;&amp;&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.5.2.2 [tuple.assign] as indicated:</p>

<blockquote>
<pre>
tuple&amp; operator=(const tuple&amp; u);
</pre>
<blockquote>
<p>
-2- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins> 
<tt>is_copy_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
tuple&amp; operator=(tuple&amp;&amp; u) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-5- <i>Remark:</i> The expression inside <tt>noexcept</tt> is equivalent to the logical AND of the following expressions:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T<sub><i>i</i></sub>&gt;
</pre></blockquote>
<p>
where <tt>T<sub><i>i</i></sub></tt> is the <tt><i>i<sup>th</sup></i></tt> type in <tt>Types</tt>.
<p/>
-6- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall be defined as deleted unless</ins>
<tt>is_move_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class... UTypes&gt;
  tuple&amp; operator=(const tuple&lt;UTypes...&gt;&amp; u);
</pre>
<blockquote>
<p>
-9- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == sizeof...(UTypes)</tt> and 
<tt>is_assignable_v&lt;T<sub><i>i</i></sub>&amp;, const U<sub><i>i</i></sub>&amp;&gt;</tt> is <tt>true</tt> 
for all <tt><i>i</i></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class... UTypes&gt;
  tuple&amp; operator=(tuple&lt;UTypes...&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-12- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>is_assignable_v&lt;T<sub><i>i</i></sub>&amp;, U<sub><i>i</i></sub>&amp;&amp;&gt; == true</tt> 
for all <tt><i>i</i></tt><del>.</del> <ins>and</ins> <tt>sizeof...(Types) == sizeof...(UTypes)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U1, class U2&gt; tuple&amp; operator=(const pair&lt;U1, U2&gt;&amp; u);
</pre>
<blockquote>
<p>
-15- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == 2</tt><del>.</del> <ins>and</ins> <tt>is_assignable_v&lt;T<sub><i>0</i></sub>&amp;, 
const U<sub><i>1</i></sub>&amp;&gt;</tt> is <tt>true</tt> for the first type <tt>T<sub><i>0</i></sub></tt> in 
<tt>Types</tt> and <tt>is_assignable_v&lt;T<sub><i>1</i></sub>&amp;, const U<sub><i>2</i></sub>&amp;&gt;</tt> 
is <tt>true</tt> for the second type <tt>T<sub><i>1</i></sub></tt> in <tt>Types</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U1, class U2&gt; tuple&amp; operator=(pair&lt;U1, U2&gt;&amp;&amp; u);
</pre>
<blockquote>
<p>
-18- <i><del>Requires</del><ins>Remarks</ins>:</i> <ins>This operator shall not participate in overload resolution 
unless</ins> <tt>sizeof...(Types) == 2</tt><del>.</del> <ins>and</ins> <tt>is_assignable_v&lt;T<sub><i>0</i></sub>&amp;, 
U<sub><i>1</i></sub>&amp;&amp;&gt;</tt> is <tt>true</tt> for the first type <tt>T<sub><i>0</i></sub></tt> in 
<tt>Types</tt> and <tt>is_assignable_v&lt;T<sub><i>1</i></sub>&amp;, U<sub><i>2</i></sub>&amp;&amp;&gt;</tt> 
is <tt>true</tt> for the second type <tt>T<sub><i>1</i></sub></tt> in <tt>Types</tt>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2730" href="#2730">2730.</a> <tt>numeric_limits</tt> primary template definition</h3>
<p><b>Section:</b> 18.3.2.1 [limits.numeric] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-06-09 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I've received this report at the <a href="mailto:cxxeditor@gmail.com">project editor mail alias</a>, and it seems like it may be worthy of a LWG issue:
</p>
<blockquote class="note">
<p>
I recently had this problem: 
</p>
<ul>
<li>I was storing data in a vector of <tt>__uint128_t</tt>s</li>
<li>I used a sorting library which used <tt>numeric_limits&lt;T&gt;::max()</tt> as a sentinel value</li>
<li>GCC's libstdc++ provides a <tt>numeric_limits</tt> specialisation for that type, but</li>
<li>Clang's libc++ does not.</li>
</ul>
<p>
This broke the sorting for me on different platforms, and it was quite difficult to determine why. If the default 
<tt>numeric_limits</tt> didn't default to <tt>0</tt>s and <tt>false</tt> values (18.3.2.4 of N4582), and instead 
<tt>static_assert</tt>ed, causing my code to not compile, I would have found the solution immediately.
<p/>
I know that <tt>__uint128_t</tt> is non-standard, so neither GCC nor Clang is doing the wrong thing nor the right thing 
here. I could just submit a patch to libc++ providing the specialisations, but it doesn't fix the problem at its core.
<p/>
I am wondering, what is the rationale behind the defaults being <tt>0</tt> and <tt>false</tt>? It seems like it is 
inviting a problem for any future numeric types, whether part of a library, compiler extension, and possibly even 
future updates to C++'s numeric types. I think it would be much better to prevent code that tries to use 
unspecified <tt>numeric_limits</tt> from compiling.
</p>
</blockquote>
<p>
An alternative to this suggestion would be to still define the primary template, but not provide any of the members 
except <tt>is_specialized</tt>. Either way, this would make <tt>numeric_limits</tt> members SFINAEable.
<p/>
Along the same lines, one might wonder why the members that only make sense for floating-point types are required to 
be defined to nonsense values for integer types.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2731" href="#2731">2731.</a> Existence of <tt>lock_guard&lt;MutexTypes...&gt;::mutex_type</tt> typedef unclear</h3>
<p><b>Section:</b> 30.4.2.1 [thread.lock.guard] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Eric Fiselier <b>Opened:</b> 2016-06-13 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.lock.guard">issues</a> in [thread.lock.guard].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the synopsis of 30.4.2.1 [thread.lock.guard] the <tt>mutex_type</tt> typedef is specified as follows:
</p>
<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class lock_guard {
public:
  typedef Mutex mutex_type; <i>// If</i> MutexTypes... <i>consists of the single type</i> Mutex
  [&hellip;]
};
</pre>
</blockquote>
<p>
The comment seems ambiguous as it could mean either:
</p>
<ol>
<li><tt>sizeof...(MutexTypes) == 1</tt>.</li>
<li><tt>sizeof...(MutexTypes) &gt;= 1</tt> and every type in <tt>MutexTypes...</tt> is the same type.</li>
</ol>
<p>
I originally took the language to mean (2), but upon further review it seems that (1) is the intended interpretation, 
as suggested in the LEWG discussion in <a href="http://wiki.edg.com/bin/view/Wg21lenexa/N4470">Lenexa</a>.
<p/>
I think the language should be clarified to prevent implementation divergence.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Edit 30.4.2.1 [thread.lock.guard]/1, class template <tt>lock_guard</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
template &lt;class... MutexTypes&gt;
class lock_guard {
public:
  typedef Mutex mutex_type; <i>// <ins>Only i</ins><del>I</del>f</i> MutexTypes... <i><del>consists of the</del><ins>expands to a</ins> single type</i> <tt>Mutex</tt>
  [&hellip;]
};
</pre>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2732" href="#2732">2732.</a> Questionable specification of <tt>path::operator/=</tt> and <tt>path::append</tt></h3>
<p><b>Section:</b> 27.10.8.4.3 [path.append] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-06-14 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#path.append">active issues</a> in [path.append].</p>
<p><b>View all other</b> <a href="lwg-index.html#path.append">issues</a> in [path.append].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current specification of <tt>operator/=</tt> taking a <tt>const Source&amp;</tt> parameter, and of 
<tt>path::append</tt> in 27.10.8.4.3 [path.append] appears to require <tt>Source</tt> to have a <tt>native()</tt> 
and an <tt>empty()</tt> member, and seemingly requires different behavior for <tt>append(<i>empty_range</i>)</tt> 
and <tt>append(first, last)</tt> when <tt>first == last</tt> (the last two bullet points being specified with 
<tt>source</tt> alone), which doesn't make any sense.
<p/>
It appears that these overloads can just be specified using the <tt>operator/=(const path&amp;)</tt> overload.
</p>

<p><i>[2016-07-03, Daniel comments]</i></p>

<p>
The same wording area is affected by LWG <a href="lwg-active.html#2664">2664</a>.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed AM: Move to Tentatively Ready</p>

<p>Friday AM, in discussing <a href="lwg-active.html#2664">2664</a> a comment about missing "equivalent to" language
was made, so PR updated.</p>

<p><strong>Previous Resolution [SUPERSEDED]</strong></p>
<blockquote class="note">
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Edit 27.10.8.4.3 [path.append]/4-5 as indicated:</p>

<blockquote>
<pre>
template &lt;class Source&gt;
  path&amp; operator/=(const Source&amp; source);
template &lt;class Source&gt;
  path&amp; append(const Source&amp; source);
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> <tt>operator/=(path(source))</tt></ins>
<p/>
<ins>-?- <i>Returns:</i> <tt>*this</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class InputIterator&gt;
  path&amp; append(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> <del>Appends <tt>path::preferred_separator</tt> to <tt>pathname</tt>, converting format and encoding
if required (27.10.8.2 [path.cvt]), unless:</del>
</p>
<ul>
<li><p><del>an added <i>directory-separator</i> would be redundant, or</del></p></li>
<li><p><del>an added <i>directory-separator</i> would change an relative path to an absolute path, or</del></p></li>
<li><p><del><tt>source.empty()</tt> is <tt>true</tt>, or</del></p></li>
<li><p><del><tt>*source.native().cbegin()</tt> is a <i>directory-separator</i>.</del></p></li>
</ul>
<p>
<del>Then appends the effective range of <tt>source</tt> (27.10.8.3 [path.req]) or the range <tt>[first, last)</tt> to
<tt>pathname</tt>, converting format and encoding if required
(27.10.8.2 [path.cvt])</del><ins><tt>operator/=(path(first, last))</tt></ins>.
<p/>
-5- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>
<ol>
<li><p>Edit 27.10.8.4.3 [path.append]/4-5 as indicated:</p>

<blockquote>
<pre>
template &lt;class Source&gt;
  path&amp; operator/=(const Source&amp; source);
template &lt;class Source&gt;
  path&amp; append(const Source&amp; source);
</pre>
<blockquote>
<p><ins>-?- <i>Effects:</i> Equivalent to <tt>return operator/=(path(source));</tt>.</ins></p>
</blockquote>
<pre>
template &lt;class InputIterator&gt;
  path&amp; append(InputIterator first, InputIterator last);
</pre>
<blockquote>
<p>-4- <i>Effects:</i> <ins>Equivalent to <tt>return operator/=(path(first, last));</tt>.</ins><del>Appends <tt>path::preferred_separator</tt> to <tt>pathname</tt>,
converting format and encoding if required (27.10.8.2 [path.cvt]), unless:</del></p>
<ol style="list-style-type: none">
<li><del>&mdash; an added <i>directory-separator</i> would be redundant, or</del></li>
<li><del>&mdash; an added <i>directory-separator</i> would change an relative path to an absolute
path, or</del></li>
<li><del>&mdash; <tt>source.empty()</tt> is <tt>true</tt>, or</del></li>
<li><del>&mdash; <tt>*source.native().cbegin()</tt> is a <i>directory-separator</i>.</del></li>
</ol>
<p><del>Then appends the effective range of <tt>source</tt> (27.10.8.3 [path.req]) or the
range <tt>[first, last)</tt> to <tt>pathname</tt>, converting format and encoding if required
(27.10.8.2 [path.cvt]).</del></p>
<p><del>-5- <i>Returns:</i> <tt>*this</tt>.</del></p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2733" href="#2733">2733.</a> [fund.ts.v2] <tt>gcd</tt> / <tt>lcm</tt> and <tt>bool</tt></h3>
<p><b>Section:</b> 99 [fund.ts.v2::numeric.ops.gcd], 99 [fund.ts.v2::numeric.ops.lcm] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-06-15 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
According to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">N4562</a>, <tt>gcd</tt> and 
<tt>lcm</tt> support <tt>bool</tt> as the operand type. The wording doesn't appear to cover the behavior for that case, 
since <tt>bool</tt> does not have a zero value and <tt>gcd</tt> / <tt>lcm</tt> are not normally mathematically defined 
over <tt>{false, true}</tt>.
<p/>
Presumably <tt>gcd</tt> and <tt>lcm</tt> shouldn't accept arguments of type <tt>bool</tt>.
</p>

<p><i>[2016-08-01, Walter Brown suggests wording]</i></p>

<p>
A corresponding issue has been added addressing the WP, see LWG <a href="lwg-active.html#2759">2759</a>.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html">N4600</a>.</p>

<ol>
<li><p>Adjust 99 [numeric.ops.gcd] p3 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; gcd(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Adjust 99 [numeric.ops.lcm] p3 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; lcm(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2734" href="#2734">2734.</a> Questionable specification in [path.concat]</h3>
<p><b>Section:</b> 27.10.8.4.4 [path.concat] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-06-16 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
27.10.8.4.4 [path.concat] specifies that the postcondition for
</p>
<blockquote>
<pre>
path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(const value_type* x);
path&amp; operator+=(value_type x);
template&lt;class Source&gt;
path&amp; operator+=(const Source&amp; x);
template&lt;class EcharT&gt;
path&amp; operator+=(EcharT x);
template&lt;class Source&gt; 
path&amp; concat(const Source&amp; x); 
template&lt;class InputIterator>
path&amp; concat(InputIterator first, InputIterator last);
</pre>
</blockquote>
<p>
is
</p>
<blockquote>
<p>
<tt>native() == prior_native</tt> + <i>effective-argument</i>
</p>
</blockquote>
<p>
where <i>effective-argument</i> is
</p>
<ol>
<li>if <tt>x</tt> is present and is <tt>const path&amp;</tt>, <tt>x.native()</tt>; otherwise</li>
<li>if <tt>source</tt> is present, the effective range of <tt>source</tt> (27.10.8.3 [path.req]); otherwise,</li>
<li>if <tt>first</tt> and <tt>last</tt> are present, the range <tt>[first, last)</tt>; otherwise,</li>
<li><tt>x</tt></li>
</ol>
<p>
It also says that
</p>
<blockquote>
<p>
If the value type of <i>effective-argument</i> would not be <tt>path::value_type</tt>, the actual argument or 
argument range is first converted (27.10.8.2.2 [path.type.cvt]) so that <i>effective-argument</i> has value 
type <tt>path::value_type</tt>.
</p>
</blockquote>
<p>
There are several problems with this specification:
<p/>
First, there is no overload taking "<tt>source</tt>" (note the lower case); all single-argument overloads take 
"<tt>x</tt>". Second, there's nothing that defines what it means to use <tt>operator+</tt> on a string and an 
iterator range; clearly concatentation is intended but there is no wording to that effect.
Third, the final portion uses "value type", but the "value type" of a single character is not a defined concept.
<p/>
Also, the reference only to 27.10.8.2.2 [path.type.cvt] seems to imply that any format conversion specified in 
27.10.8.2.1 [path.fmt.cvt] will not be performed, in seeming contradiction to the rule that <tt>native()</tt> 
is to return the native pathname format (27.10.8.4.6 [path.native.obs]/1). Is that intended?
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2735" href="#2735">2735.</a> <tt>std::abs(short)</tt>, <tt>std::abs(signed char)</tt> and others should return <tt>int</tt> instead of 
<tt>double</tt> in order to be compatible with C++98 and C</h3>
<p><b>Section:</b> 26.9 [c.math] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> J&ouml;rn Heusipp <b>Opened:</b> 2016-06-16 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#c.math">active issues</a> in [c.math].</p>
<p><b>View all other</b> <a href="lwg-index.html#c.math">issues</a> in [c.math].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider this C++98 program:
</p>
<blockquote>
<pre>
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;

int main() {
  return std::abs(static_cast&lt;short&gt;(23)) % 42;
}
</pre>
</blockquote>
<p>
This works fine with C++98 compilers. At the <tt>std::abs(short)</tt> call, short gets promoted to <tt>int</tt> and 
<tt>std::abs(int)</tt> is called.
<p/>
C++11 added the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4594.pdf">following wording</a>
on page 1083 &sect;26.9 p15 b2 [c.math]:
</p>
<blockquote>
<p>
Otherwise, if any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>double</tt> 
or an integer type, then all arguments of arithmetic type corresponding to <tt>double</tt> parameters are effectively 
cast to <tt>double</tt>.
</p>
</blockquote>
<p>
C++17 draft <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4594.pdf">additionally adds</a> on
page 1080 &sect;26.9 p10 [c.math]:
</p>
<blockquote>
<p>
If <tt>abs()</tt> is called with an argument of type <tt>X</tt> for which <tt>is_unsigned&lt;X&gt;::value</tt> is <tt>true</tt> 
and if <tt>X</tt> cannot be converted to <tt>int</tt> by integral promotion (4.5), the program is ill-formed. [<i>Note:</i> 
Arguments that can be promoted to <tt>int</tt> are permitted for compatibility with C. &mdash; <i>end note</i>]
</p>
</blockquote>
<p>
It is somewhat confusing and probably even contradictory to on the one hand specify <tt>abs()</tt> in terms of integral 
promotion in &sect;26.9 p10 and on the other hand demand all integral types to be converted to <tt>double</tt> in 
&sect;26.9 p15 b2.
<p/>
Most compilers (each with their own respective library implementation) I tested (MSVC, Clang, older GCC) appear to not 
consider &sect;26.9 p15 b2 for <tt>std::abs</tt> and compile the code successfully. GCC 4.5-5.3 (for <tt>std::abs</tt> but 
not for <tt>::abs</tt>) as well as GCC &gt;=6.0 (for both <tt>std::abs</tt> and <tt>::abs</tt>) fail to compile in the following 
way: Taking &sect;26.9 p15 b2 literally and applying it to <tt>abs()</tt> (which is listed in &sect;26.9 p12) results in 
<tt>abs(short)</tt> returning <tt>double</tt>, and with <tt>operator%</tt> not being specified for <tt>double</tt>, this 
makes the programm ill-formed.
<p/>
I do acknowledge the reason for the wording and semantics demanded by &sect;26.9 p15 b2, i.e. being able to call math functions 
with integral types or with partly floating point types and partly integral types. Converting integral types to <tt>double</tt>
certainly makes sense here for all the other floating point math functions.
However, <tt>abs()</tt> is special. <tt>abs()</tt> has overloads for the 3 wider integral types which return integral types. 
<tt>abs()</tt> originates in the C standard in <tt>stdlib.h</tt> and had originally been specified for integral types only. 
Calling it in C with a short argument returns an <tt>int</tt>. Calling <tt>std::abs(short)</tt> in C++98 also returns an 
<tt>int</tt>. Calling <tt>std::abs(short)</tt> in C++11 and later with &sect;26.9 p15 b2 applied to <tt>abs()</tt> suddenly 
returns a <tt>double</tt>.
<p/>
Additionally, this behaviour also breaks third-party C headers which contain macros or inline functions calling 
<tt>abs(short)</tt>.
<p/>
As per discussion on std-discussion, my reading of the standard as well as GCC's interpretation seem valid.
However, as can be seen, this breaks existing code.
<p/>
In addition to the compatibilty concerns, having <tt>std::abs(short)</tt> return <tt>double</tt> is also very confusing 
and unintuitive.
<p/>
The other (possibly, depending on their respective size relative to <tt>int</tt>) affected types besides <tt>short</tt> 
are <tt>signed char</tt>, <tt>unsigned char</tt> and <tt>unsigned short</tt>, and also <tt>char</tt>, <tt>char16_t</tt>, 
<tt>char32_t</tt> and <tt>wchar_t</tt>, (all of these are or may be promotable to <tt>int</tt>). Wider integral types 
are not affected because explicit overloads are specified for those types by &sect;26.9 p6, &sect;26.9 p7 and &sect;26.9 p9.
<tt>div()</tt> is also not affected because it is neither listed in &sect;26.9 p12, nor does it actually provide 
any overload for <tt>double</tt> at all.
<p/>
As far as I can see, the proposed or implemented solutions for LWG <a href="lwg-active.html#2294">2294</a>, <a href="lwg-defects.html#2192">2192</a> and/or 
<a href="lwg-defects.html#2086">2086</a> do not resolve this issue.
<p/>
I think both, &sect;26.9 p10 [c.math] and &sect;26.9 p15 [c.math] need some correction and clarification.
<p/>
(Note: These changes would explicitly render the current implementation in GCC's libstdc++ non-conforming, which would 
be a good thing, as outlined above.)
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4594.</p>
<ol>
<li><p>Modify 26.9 [c.math] as indicated:</p>

<blockquote>
<p>
-10- If <tt>abs()</tt> is called with an argument of type <tt>X</tt> for which <tt>is_unsigned&lt;X&gt;::value</tt> is 
<tt>true</tt> and if <tt>X</tt> cannot be converted to <tt>int</tt> by integral promotion (4.5), the program is ill-formed.
<ins>If <tt>abs()</tt> is called with an argument of type <tt>X</tt> which can be converted to <tt>int</tt> by integral 
promotion (4.5), the argument is promoted to <tt>int</tt>.</ins> [<i>Note:</i> Arguments that can be promoted to <tt>int</tt> 
are <ins>promoted to <tt>int</tt> in order to keep</ins><del>permitted for</del> compatibility with C. &mdash; <i>end note</i>]
<p/>
[&hellip;]
<p/>
-15- Moreover, there shall be additional overloads <ins>for these functions, with the exception of <tt>abs()</tt>,</ins> 
sufficient to ensure:
</p>
<ol>
<li><p>If any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>long double</tt>, then
all arguments of arithmetic type (3.9.1) corresponding to <tt>double</tt> parameters are effectively cast to
<tt>long double</tt>.</p></li>
<li><p>Otherwise, if any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>double</tt>
or an integer type, then all arguments of arithmetic type corresponding to <tt>double</tt> parameters are
effectively cast to <tt>double</tt>.</p></li>
<li><p>Otherwise, all arguments of arithmetic type corresponding to <tt>double</tt> parameters have type <tt>float</tt>.</p></li>
</ol>
<p>
See also: ISO C 7.5, 7.10.2, 7.10.6.
<p/>
<ins>[<i>Note:</i> <tt>abs()</tt> is exempted from these rules in order to stay compatible with C. &mdash; <i>end note</i>]</ins>
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-07 Chicago]</i></p>

<p>Monday: Some of this has been changed in N4606; the rest of the changes may be editorial.</p>
<p>Fri PM: Move to Tentatively Ready</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>
<ol>
<li><p>Modify 26.9.1 [cmath.syn] as indicated:</p>

<blockquote>
<p>
-2- For each set of overloaded functions within <tt>&lt;cmath&gt;</tt>,
 <ins>with the exception of <tt>abs</tt>, </ins> there shall be additional
overloads sufficient to ensure:
</p>
<ol>
<li><p>If any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>long double</tt>, then
all arguments of arithmetic type (3.9.1) corresponding to <tt>double</tt> parameters are effectively cast to
<tt>long double</tt>.</p></li>
<li><p>Otherwise, if any argument of arithmetic type corresponding to a <tt>double</tt> parameter has type <tt>double</tt>
or an integer type, then all arguments of arithmetic type corresponding to <tt>double</tt> parameters are
effectively cast to <tt>double</tt>.</p></li>
<li><p>Otherwise, all arguments of arithmetic type corresponding to <tt>double</tt> parameters have type <tt>float</tt>.</p></li>
</ol>
<p><ins>[<i>Note:</i> <tt>abs</tt> is exempted from these rules in order to stay compatible with C. &mdash; <i>end note</i>]</ins></p>
<p>
See also: ISO C 7.5, 7.10.2, 7.10.6.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2736" href="#2736">2736.</a> <tt>nullopt_t</tt> insufficiently constrained</h3>
<p><b>Section:</b> 20.6.4 [optional.nullopt] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-06-17 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.6.4 [optional.nullopt]/2 requires of <tt>nullopt_t</tt> that
</p>
<blockquote>
<p>
Type <tt>nullopt_t</tt> shall not have a default constructor. It shall be a literal type. Constant <tt>nullopt</tt> shall 
be initialized with an argument of literal type.
</p>
</blockquote>
<p>
This does not appear sufficient to foreclose the following implementation:
</p>
<blockquote>
<pre>
struct nullopt_t 
{
  constexpr nullopt_t(const nullopt_t&amp;) = default;
};

constexpr nullopt_t nullopt(nullopt_t{});
</pre>
</blockquote>
<ul>
<li><tt>nullopt_t</tt> has no default constructor because it has a user-declared (copy) constructor;</li>
<li><tt>nullopt_t</tt> has a trivial destructor, is an aggregate, and is a literal type;</li>
<li><tt>nullopt</tt> has been initialized with an argument of literal type, to wit, <tt>nullopt_t</tt>.</li>
</ul>
<p>
But such a <tt>nullopt_t</tt> is still constructible from <tt>{}</tt> and so still makes <tt>opt = {}</tt> ambiguous.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>This is related to LWG <a href="lwg-active.html#2510">2510</a>.</p>
<p>Monday PM: Ville to provide updated wording</p>
<p>Fri AM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Edit 20.6.4 [optional.nullopt]/2 as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: <tt>{}</tt> can do one of three things for a class type:
it may be aggregate initialization, it may call a default constructor,
or it may call an initializer-list constructor (see 8.6.4 [dcl.init.list], 13.3.1.7 [over.match.list]).
The wording below forecloses all three possibilities. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
<blockquote>
<p>
-2- Type <tt>nullopt_t</tt> shall not have a default constructor <ins>or an initializer-list constructor</ins>. 
It <ins>shall not be an aggregate and</ins> shall be a literal type. Constant <tt>nullopt</tt> shall 
be initialized with an argument of literal type.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2737" href="#2737">2737.</a> Consider relaxing object size restrictions for single-object allocation functions</h3>
<p><b>Section:</b> 18.6.2.1 [new.delete.single] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Clark Nelson <b>Opened:</b> 2016-06-21 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#new.delete.single">issues</a> in [new.delete.single].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It should be considered whether the description of the
single-object allocation functions should say "or smaller", like
the array allocation functions. For example, according to 18.6.2.1 [new.delete.single] p1 (emphasis mine):
</p>
<blockquote>
<p>
The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate <tt>size</tt> bytes of
storage suitably aligned to represent any object <em>of that size</em>.
</p>
</blockquote>
<p>
In contrast to this, 18.6.2.2 [new.delete.array] p1 says (emphasis mine):
</p>
<blockquote>
<p>
The allocation function (3.7.4.1) called by the array form of a new-expression (5.3.4) to allocate
<tt>size</tt> bytes of storage suitably aligned to represent any array object <em>of that size or smaller</em>. 
(footnote: It is not the direct responsibility of <tt>operator new[](std::size_t)</tt> or <tt>operator delete[](void*)</tt> 
to note the repetition count or element size of the array. Those operations are performed elsewhere in the array 
<tt>new</tt> and <tt>delete</tt> expressions. The array <tt>new</tt> expression, may, however, increase the size 
argument to operator <tt>new[](std::size_t)</tt> to obtain space to store supplemental information.)
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2738" href="#2738">2738.</a> <tt>is_constructible</tt> with <tt>void</tt> types</h3>
<p><b>Section:</b> 20.15.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> S. B. Tam <b>Opened:</b> 2016-06-22 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#2560">2560</a> mention that there is no variable of function type. There's also no variable of <tt>void</tt> type, 
so should 20.15.4.3 [meta.unary.prop] also explicitly say that for a <tt>void</tt> type <tt>T</tt>, 
<tt>is_constructible&lt;T, Args...&gt;::value</tt> is <tt>false</tt>?
</p>

<p><i>[2016-07-03, Daniel provides wording]</i></p>


<p><i>[2016-08 Chicago]</i></p>

<p>Wed PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Change 20.15.4.3 [meta.unary.prop], Table 52 &mdash; "Type property predicates", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 52 &mdash; Type property predicates</caption>
<tr>
<th align="center">Template</th>
<th align="center">Condition</th>
<th align="center">Preconditions</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T, class... Args&gt;<br/>
struct is_constructible;</tt>
</td>

<td>
For a function type <tt>T</tt><br/> 
<ins>or for a (possibly <i>cv</i>-qualified) <tt>void</tt> type <tt>T</tt></ins>,<br/> 
<tt>is_constructible&lt;T, Args...&gt;::value</tt><br/>
is <tt>false</tt>, otherwise <i>see below</i>
</td>

<td align="center">
<tt>T</tt> and all types in the<br/>
parameter pack <tt>Args</tt> shall<br/>
be complete types,<br/>
(possibly <i>cv</i>-qualified)<br/>
<tt>void</tt>, or arrays of<br/>
unknown bound.
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2739" href="#2739">2739.</a> Issue with <tt>time_point</tt> non-member subtraction with an unsigned duration</h3>
<p><b>Section:</b> 20.17.6.5 [time.point.nonmember] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Michael Winterberg <b>Opened:</b> 2016-06-23 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#time.point.nonmember">issues</a> in [time.point.nonmember].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4594, 20.17.6.5 [time.point.nonmember], <tt>operator-(time_point, duration)</tt> is specified as:
</p>
<blockquote>
<pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <tt>lhs + (-rhs)</tt>.
</p>
</blockquote>
</blockquote>
<p>
When <tt>Rep2</tt> is an unsigned integral type, the behavior is quite different with arithmetic of the underlying 
integral types because of the requirement to negate the incoming duration and then add that. It also ends up 
producing different results than the underlying durations as well as the non-member <tt>time_point::operator-=</tt>.
<p/>
Consider this program:
</p>
<blockquote>
<pre>
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;cstdint&gt;

using namespace std;
using namespace std::chrono;

int main()
{
  const duration&lt;uint32_t&gt; unsignedSeconds{5};

  auto someValue = system_clock::from_time_t(200);
  cout &lt;&lt; system_clock::to_time_t(someValue) &lt;&lt; '\n';
  cout &lt;&lt; system_clock::to_time_t(someValue - unsignedSeconds) &lt;&lt; '\n';
  someValue -= unsignedSeconds;
  cout &lt;&lt; system_clock::to_time_t(someValue) &lt;&lt; '\n';

  std::chrono::seconds signedDur{200};
  cout &lt;&lt; signedDur.count() &lt;&lt; '\n';
  cout &lt;&lt; (signedDur - unsignedSeconds).count() &lt;&lt; '\n';
  signedDur -= unsignedSeconds;
  cout &lt;&lt; signedDur.count() &lt;&lt; '\n';
}
</pre>
</blockquote>
<p>
The goal of the program is to compare the behavior of <tt>time_point</tt> non-member <tt>operator-</tt>, 
<tt>time_point</tt> member <tt>operator-=</tt>, <tt>duration</tt> non-member <tt>operator-</tt>, and 
<tt>duration</tt> member <tt>operator-=</tt> with basically the same inputs.
<p/>
libc++ produces this output, which appears mandated by the standard:
</p>
<blockquote>
<pre>
200
4294967491
195
200
195
195
</pre>
</blockquote>
<p>
On the other hand, libstdc++ produces this output, which is what I "intuitively" expect and behaves more consistently:
</p>
<blockquote>
<pre>
200
195
195
200
195
195
</pre>
</blockquote>
<p>
Given the seemingly brief coverage of durations with unsigned representations in the standard, this seems to be an 
oversight rather than a deliberate choice for this behavior. Additionally, there may be other "unexpected" behaviors 
with durations with an unsigned representation, this is just the one that I've come across.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Change 20.17.6.5 [time.point.nonmember] as indicated:</p>

<blockquote>
<pre>
template &lt;class Clock, class Duration1, class Rep2, class Period2&gt;
  constexpr time_point&lt;Clock, common_type_t&lt;Duration1, duration&lt;Rep2, Period2&gt;&gt;&gt;
  operator-(const time_point&lt;Clock, Duration1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre>
<blockquote>
<p>
-3- <i>Returns:</i> <del><tt>lhs + (-rhs)</tt></del><ins><tt><i>CT</i>(lhs.time_since_epoch() - rhs)</tt>, where 
<tt><i>CT</i></tt> is the type of the return value</ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2740" href="#2740">2740.</a> <tt>constexpr optional&lt;T&gt;::operator-&gt;</tt></h3>
<p><b>Section:</b> 20.6.3.5 [optional.object.observe] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-07-02 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>optional&lt;T&gt;::operator-&gt;</tt>s are constrained to be <tt>constexpr</tt> functions
only when <tt>T</tt> is not a type with an overloaded unary <tt>operator&amp;</tt>. This
constrain comes from the need to use <tt>addressof</tt> (or a similar
mechanism), and the inability to do so in a constant expression in
C++14. Given that <tt>addressof</tt> is now <tt>constexpr</tt>, this constrain is no
longer needed.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Modify 20.6.3.5 [optional.object.observe] as indicated:</p>

<blockquote>
<pre>
constexpr T const* operator-&gt;() const;
constexpr T* operator-&gt;();
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <tt>*this</tt> contains a value.
<p/>
-2- <i>Returns:</i> <tt>val</tt>.
<p/>
-3- <i>Throws:</i> Nothing.
<p/>
-4- <i>Remarks:</i> <del>Unless <tt>T</tt> is a user-defined type with overloaded unary <tt>operator&amp;</tt>, 
t</del><ins>T</ins>hese functions shall be <tt>constexpr</tt> functions.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2741" href="#2741">2741.</a> <tt>is_partitioned</tt> requirements need updating</h3>
<p><b>Section:</b> 25.4.14 [alg.partitions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-07-06 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.partitions">issues</a> in [alg.partitions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<blockquote class="note">
<p>
<i>Requires:</i> <tt>InputIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument type.
</p>
</blockquote>
<p>
This seems to date from the days of adaptable function objects with an <tt>argument_type</tt> typedef, but in 
modern C++ the predicate might not have an argument type. It could have a function template that accepts various 
arguments, so it doesn't make sense to state requirements in terms of a type that isn't well defined.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4594.</p>

<ol>
<li><p>Edit 25.4.14 [alg.partitions] as indicated:</p>

<blockquote>
<pre>
template &lt;class InputIterator, class Predicate&gt;
bool is_partitioned(InputIterator first, InputIterator last, Predicate pred);
</pre>
<blockquote>
<p>
-1- <i>Requires:</i> <del><tt>InputIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument 
type</del><ins>The expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template &lt;class InputIterator, class OutputIterator1,
          class OutputIterator2, class Predicate&gt;
  pair&lt;OutputIterator1, OutputIterator2&gt;
  partition_copy(InputIterator first, InputIterator last,
                 OutputIterator1 out_true, OutputIterator2 out_false,
                 Predicate pred);
</pre>
<blockquote>
<p>
-12- <i>Requires:</i> <tt>InputIterator</tt>'s value type shall be <tt>CopyAssignable</tt>, and shall be writable 
(24.2.1 [iterator.requirements.general]) to the <tt>out_true</tt> and <tt>out_false</tt> 
<tt>OutputIterator</tt>s, and <del>shall be convertible to <tt>Predicate</tt>'s argument type</del><ins>the
expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>. 
The input range shall not overlap with either of the output ranges.
<p/>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class ForwardIterator, class Predicate&gt;
  ForwardIterator partition_point(ForwardIterator first,
                                  ForwardIterator last,
                                  Predicate pred);
</pre>
<blockquote>
<p>
-16- <i>Requires:</i> <del><tt>ForwardIterator</tt>'s value type shall be convertible to <tt>Predicate</tt>'s argument 
type</del><ins>The expression <tt>pred(*i)</tt> shall be well-formed for all <tt>i</tt> in <tt>[first, last)</tt></ins>. 
<tt>[first, last)</tt> shall be partitioned by <tt>pred</tt>, i.e. all elements that satisfy <tt>pred</tt> shall appear 
before those that do not.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2742" href="#2742">2742.</a> Inconsistent <tt>string</tt> interface taking <tt>string_view</tt></h3>
<p><b>Section:</b> 21.3.1.2 [string.cons] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-06 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#string.cons">issues</a> in [string.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Generally, <tt>basic_string</tt> has a constructor matching each <tt>assign</tt> function and vice versa (except the 
constructor takes an allocator where <tt>assign</tt> does not). <a href="http://wg21.link/p0254r2">P0254R2</a> violates 
this by adding an <tt>assign(basic_string_view, size_type pos, size_type n = npos)</tt> but no corresponding constructor.
</p>

<p><i>[2016-08-04 Chicago LWG]</i></p>

<p>
Robert Douglas provides initial wording.
<p/>
We decided against another constructor overload to avoid the semantic confusion between:
</p>
<blockquote><pre>
basic_string(char const*, size_type length, Allocator = Allocator())
</pre></blockquote>
<p>
and
</p>
<blockquote><pre>
template&lt;class T, class Foo = is_convertible_v&lt;T const&amp;, basic_string_view&lt;charT, traits&gt;&gt;
basic_string(T const&amp;, size_type pos, Allocator = Allocator())
</pre></blockquote>
<p>
where someone might call:
</p>
<blockquote><pre>
basic_string("HelloWorld", 5, 5);
</pre></blockquote>
<p>
and get "World", but then call
</p>
<blockquote><pre>
basic_string("HelloWorld", 5);
</pre></blockquote>
<p>
and instead get "Hello". The second parameter changes between length and position. 
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Fri PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 21.3.1 [basic.string] add the following constructor overload:</p>

<blockquote><pre>
[&hellip;]
basic_string(const basic_string&amp; str, size_type pos,
             const Allocator&amp; a = Allocator());
basic_string(const basic_string&amp; str, size_type pos, size_type n,
             const Allocator&amp; a = Allocator());
<ins>template&lt;class T&gt;
basic_string(const T&amp; t, size_type pos, size_type n, const Allocator&amp; a = Allocator());</ins>
explicit basic_string(basic_string_view&lt;charT, traits&gt; sv,
                      const Allocator&amp; a = Allocator());
[&hellip;]
</pre></blockquote>
</li>

<li><p>In 21.3.1.2 [string.cons] add the following ctor definition:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;
basic_string(const T&amp; t, size_type pos, size_type n, const Allocator&amp; a = Allocator());</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Creates a variable, <tt>sv</tt>, as if by <tt>basic_string_view&lt;charT, traits&gt; sv = t;</tt> 
and then behaves the same as:</ins>
<blockquote>
<pre>
<ins>basic_string(sv.substr(pos, n), a)</ins>
</pre>
</blockquote>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless 
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2743" href="#2743">2743.</a> p0083r3 <tt>node_handle</tt> private members missing "exposition only" comment</h3>
<p><b>Section:</b> 23.1.1.1 [container.node.overview] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-08 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The private members of <tt>node_handle</tt> are missing the usual "exposition only" comment. As a consequence, 
<tt>ptr_</tt> and <tt>alloc_</tt> now appear to be names defined by the library (so programs defining these names 
as macros before including a library header have undefined behavior).
<p/>
Presumably this is unintentional and these members should be considered to be for exposition only.
<p/>
It's also not clear whether the name <tt>node_handle</tt> is reserved for library usage or not; 
23.1.1.1 [container.node.overview]/3 says the implementation need not provide a type with this name, but 
doesn't seem to rule out the possibility that an implementation will choose to do so regardless.
</p>
<p>
<b>Daniel:</b>
<p/>
A similar problem seems to exist for the exposition-only type <tt><i>call_wrapper</i></tt> from 
<a href="http://wg21.link/p0358r1">p0358r1</a>, which exposes a private data member named <tt>fd</tt> and 
a typedef <tt>FD</tt>.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Jonathan says that we need to make clear that the name <tt>node_handle</tt> is not reserved</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2744" href="#2744">2744.</a> <tt>any</tt>'s <tt>in_place</tt> constructors</h3>
<p><b>Section:</b> 20.8.3.1 [any.cons] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-07-10 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.cons">active issues</a> in [any.cons].</p>
<p><b>View all other</b> <a href="lwg-index.html#any.cons">issues</a> in [any.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>in_place</tt> constructor that takes an <tt>initializer_list</tt> has both a <i>Requires:</i>
for <tt>is_constructible</tt> and a <i>Remarks:</i> for <tt>is_constructible</tt>. The one
that takes just a pack has just a <i>Requires:</i> for <tt>is_constructible</tt>.
<p/>
I think both of those should be <i>Remarks:</i>, i.e. SFINAEable constraints.
Otherwise querying is_constructible for an any with <tt>in_place_t</tt> will
not give a reasonable answer, and I utterly fail to see any implementation
burden in SFINAEing those constructors.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.
<p/>
-8- <i>Effects:</i> Constructs an object of type <tt>any</tt> that contains an object of type <tt>T</tt> 
direct-initialized with <tt>std::forward&lt;ValueType&gt;(value)</tt>.
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution if <tt>decay_t&lt;ValueType&gt;</tt> is the
same type as <tt>any</tt> <ins>or if <tt>ValueType</tt> is a specialization of <tt>in_place_type_t</tt></ins>.
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-11- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</del>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution unless
<tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></ins>
<p/>
[&hellip;]
</p>
</blockquote>

<pre>
template &lt;class T, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> <del>The function</del><ins>This constructor</ins> shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2745" href="#2745">2745.</a> [fund.ts.v2] Implementability of LWG 2451</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-10 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#fund.ts.v2::optional.object">issues</a> in [fund.ts.v2::optional.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
LWG <a href="lwg-defects.html#2451">2451</a> adds conditionally explicit converting constructors to <tt>optional&lt;T&gt;</tt> that accept:
</p>
<ol>
<li>Types convertible to <tt>T</tt>: <tt>template &lt;class U&gt; constexpr optional(T&amp;&amp;);</tt></li>
<li>Rvalue <tt>optional&lt;U&gt;</tt> when <tt>U&amp;&amp;</tt> is convertible to <tt>T</tt>: 
<tt>template &lt;class U&gt; constexpr optional(optional&lt;U&gt;&amp;&amp;);</tt></li>
<li>Lvalue <tt>const optional&lt;U&gt;</tt> when <tt>const U&amp;</tt> is convertible to <tt>T</tt>: 
<tt>template &lt;class U&gt; constexpr optional(const optional&lt;U&gt;&amp;);</tt></li>
</ol>
<p>
All three of these constructors are required to be <tt>constexpr</tt> "If <tt>T</tt>'s selected constructor is a 
<tt>constexpr</tt> constructor". While this is not problematic for #1, it is not possible in the current language 
to implement signatures #2 and #3 as <tt>constexpr</tt> functions for the same reasons that <tt>optional</tt>'s 
<em>non-converting</em> constructors from <tt>optional&lt;T&gt;&amp;&amp;</tt> and <tt>const optional&lt;T&gt;&amp;</tt> 
cannot be <tt>constexpr</tt>.
<p/>
We should remove the "<tt>constexpr</tt>" specifier from the declarations of the conditionally explicit converting 
constructors that accept <tt>optional&lt;U&gt;&amp;&amp;</tt> and <tt>const optional&lt;U&gt;&amp;</tt>, and strike 
the remarks requiring these constructors to be <tt>constexpr</tt>.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>
<p>This needs to be considered for C++17 as well</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html">N4600</a>.</p>

<blockquote class="note">
<p>
Wording relative to N4600 + LWG <a href="lwg-defects.html#2451">2451</a>, although it should be noted that this resolution should be applied 
wherever LWG <a href="lwg-defects.html#2451">2451</a> is applied, be that to the fundamentals TS or the specification of <tt>optional</tt> in the 
C++ Working Paper.
</p>
</blockquote>

<ol>
<li><p>Edit 99 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt;
class optional
{
public:
  typedef T value_type;

  // 5.3.1, Constructors
  [&hellip;]
  template &lt;class U&gt; constexpr optional(U&amp;&amp;);
  template &lt;class U&gt; <del>constexpr</del> optional(const optional&lt;U&gt;&amp;);
  template &lt;class U&gt; <del>constexpr</del> optional(optional&lt;U&lt;&amp;&amp;);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>In 99 [optional.object.ctor], modify the new signature specifications added by LWG <a href="lwg-defects.html#2451">2451</a></p>

<blockquote>
<pre>
template &lt;class U&gt;
  <del>constexpr</del> optional(const optional&lt;U&gt;&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-48- <i>Remarks:</i> <del>If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.</del> This constructor shall not participate in overload resolution 
unless [&hellip;]
</p>
</blockquote>
<pre>
template &lt;class U&gt;
  <del>constexpr</del> optional(optional&lt;U&gt;&amp;&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-53- <i>Remarks:</i> <del>If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.</del> This constructor shall not participate in overload resolution 
unless [&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2746" href="#2746">2746.</a> Inconsistency between requirements for <tt>emplace</tt> between <tt>optional</tt> and <tt>variant</tt></h3>
<p><b>Section:</b> 20.6.3 [optional.object] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-07-13 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.object">active issues</a> in [optional.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.object">issues</a> in [optional.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Referring to N4604:
</p>
<p>
In 20.6.3.3 [optional.object.assign]: <tt>emplace</tt> (normal form) has a Requires that the construction works.
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> 
is <tt>true</tt>.
</p>
</blockquote>
<p>
In 20.8.3.3 [any.modifiers]: <tt>emplace</tt> (normal form) has a Requires that the construction works:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
<p>
In 20.7.2.4 [variant.mod]: <tt>emplace</tt> (<tt>T</tt>, normal form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>, and <tt>T</tt> occurs exactly 
once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (Idx, normal form) has a <em>both</em> a Requires and a SFINAE condition:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>I &lt; sizeof...(Types)</tt>
<p/>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>, and <tt>T</tt> 
occurs exactly once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (<tt>T</tt>, <tt>initializer_list</tt> form) has a SFINAE condition:
</p>
<blockquote>
<p>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is 
<tt>true</tt>, and <tt>T</tt> occurs exactly once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
<tt>emplace</tt> (Idx, <tt>initializer_list</tt> form) has a both a Requires and a SFINAE condition:
</p>
<blockquote>
<p>
<i>Requires:</i> <tt>I &lt; sizeof...(Types)</tt>
<p/>
<i>Remarks:</i> [&hellip;] unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is true, and <tt>T</tt> occurs exactly 
once in <tt>Types...</tt>.
</p>
</blockquote>
<p>
Why the inconsistency? Should all the cases have a SFINAE requirement?
<p/>
I see that variant has an additional requirement (<tt>T</tt> occurs exactly once in <tt>Types...</tt>), but that 
only agues that it must be a SFINAE condition &mdash; doesn't say that the other cases (any/variant) should not.
<p/>
<tt>map</tt>/<tt>multimap</tt>/<tt>unordered_map</tt>/<tt>unordered_multimap</tt> have SFINAE'd versions of 
<tt>emplace</tt> that don't take <tt>initializer_list</tt>s, but they don't have any <tt>emplace</tt> versions 
that take ILs.
<p/>
Suggested resolution:
<p/>
Add SFINAE requirements to <tt>optional::emplace(Args&amp;&amp;... args)</tt> and 
<tt>any::emplace(Args&amp;&amp;... args);</tt>
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>During issue prioritization, people suggested that this might apply to <tt>any</tt> as well.</p>
<p>Ville notes that <a href="lwg-active.html#2746">2746</a>, <a href="lwg-active.html#2754">2754</a> and <a href="lwg-active.html#2756">2756</a> all go together.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2747" href="#2747">2747.</a> Possibly redundant <tt>std::move</tt> in [alg.foreach]</h3>
<p><b>Section:</b> 25.3.4 [alg.foreach] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-07-15 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.foreach">issues</a> in [alg.foreach].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
25.3.4 [alg.foreach] p3 says <i>Returns:</i> <tt>std::move(f)</tt>.
<p/>
12.8 [class.copy] says that since <tt>f</tt> is a function parameter overload resolution to select the constructor 
for the return value is first performed as if for an rvalue, so the <tt>std::move</tt> is redundant.
<p/>
It could be argued that it isn't entirely redundant, because it says that implementations can't do something slightly different like return an lvalue reference that is bound to <tt>f</tt>, which would prevent it being treated as an rvalue. We should discuss it.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 25.3.4 [alg.foreach] as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class Function&gt;
  Function for_each(InputIterator first, InputIterator last, Function f);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-3- <i>Returns:</i> <tt><del>std::move(</del>f<del>)</del></tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2748" href="#2748">2748.</a> <tt>swappable</tt> traits for <tt>optional</tt>s</h3>
<p><b>Section:</b> 20.6.3.4 [optional.object.swap], 20.6.9 [optional.specalg] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-07-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>optional</tt> didn't benefit from the wording modifications by P0185 "Adding [<tt>nothrow_</tt>]<tt>swappable</tt> 
traits"; as such, it suffers from LWG <a href="lwg-defects.html#2456">2456</a>, and does not play nice with swappable traits.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3.4 [optional.object.swap] as indicated:</p>

<blockquote>
<pre>
void swap(optional&lt;T&gt;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote>
<pre>
is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; <ins>is_nothrow_swappable_v&lt;T&gt;</ins><del>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</del>
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.6.9 [optional.specalg] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <tt>x.swap(y)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2749" href="#2749">2749.</a> <tt>swappable</tt> traits for <tt>variant</tt>s</h3>
<p><b>Section:</b> 20.7.2.6 [variant.swap], 20.7.9 [variant.specalg] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-07-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>variant</tt> does not play nice with swappable traits, the non-member specialized <tt>swap</tt> overload is not 
SFINAE friendly. On the other hand, the member <tt>swap</tt> is SFINAE friendly, albeit with an incomplete condition, 
when arguably it shouldn't be. Given the <i>Effects</i>, <i>Throws</i>, and <i>Remarks</i> clauses, the SFINAE 
condition should include <tt>is_move_constructible_v</tt> and <tt>is_move_assignable_v</tt> to account for the 
involvement of <tt>variant</tt>'s move constructor and move assignment operator (the <tt>noexcept</tt> specification is 
correct as is, since the move assignment operator would only be called for <tt>variant</tt>s with different alternatives). 
This SFINAE condition should apply to the non-member <tt>swap</tt> overload, while the member <tt>swap</tt> should require 
all alternatives are swappable (as defined by 17.6.3.2 [swappable.requirements]).
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P1 - review later in the week</p>
<p>Fri PM: Move to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.7.2.6 [variant.swap] as indicated:</p>

<blockquote>
<pre>
void swap(variant&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires:</i> Lvalues of type <tt>T<sub><i>i</i></sub></tt> shall be swappable and 
<tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; is_move_assignable_v&lt;T<sub><i>i</i></sub>&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>.</ins>
<p/>
[&hellip;]
<p/>
-3- <i>Remarks:</i> <del>This function shall not participate in overload resolution unless <tt>is_swappable_v&lt;Ti&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>.</del> If an exception is thrown during the call to function 
<tt>swap(get&lt;<i>i</i>&gt;(*this), get&lt;<i>i</i>&gt;(rhs))</tt>, the states of the contained values of 
<tt>*this</tt> and of <tt>rhs</tt> are determined by the exception safety guarantee of swap for lvalues of 
<tt>T<sub><i>i</i></sub></tt> with <tt><i>i</i></tt> being <tt>index()</tt>. If an exception is thrown during the 
exchange of the values of <tt>*this</tt> and <tt>rhs</tt>, the states of the values of <tt>*this</tt> and of <tt>rhs</tt> 
are determined by the exception safety guarantee of <tt>variant</tt>'s move constructor and move assignment operator. 
The expression inside <tt>noexcept</tt> is equivalent to the logical AND of 
<tt>is_nothrow_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; 
is_nothrow_swappable_v&lt;T<sub><i>i</i></sub>&gt;</tt> for all <tt><i>i</i></tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.7.9 [variant.specalg] as indicated:</p>

<blockquote>
<pre>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <tt>v.swap(w)</tt>.
<p/>
-2- <i>Remarks:</i> <ins>This function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; is_move_assignable_v&lt;T<sub><i>i</i></sub>&gt; 
&amp;&amp; is_swappable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>.</ins> The 
expression inside <tt>noexcept</tt> is equivalent to <tt>noexcept(v.swap(w))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-13, Reopened by Casey Carter]</i></p>

<p>
It is possible to exchange the value of two variants using only move construction on the alternative types, as if by
<pre>
auto tmp = move(x);
x.emplace&lt;<i>i</i>&gt;(move(y));
y.emplace&lt;<i>j</i>&gt;(move(tmp));
</pre> 
where <i>i</i> is <tt>y.index()</tt> and <i>j</i> is <tt>tmp.index()</tt>. Consequently, <tt>variant</tt>'s member swap
need not require move assignable alternatives.
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.7.2.6 [variant.swap] as indicated:</p>

<blockquote>
<pre>
void swap(variant&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p/>
<ins>-?- <i>Requires:</i> Lvalues of type <tt>T<sub><i>i</i></sub></tt> shall be swappable and 
<tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt;</tt> shall be <tt>true</tt> for all <tt><i>i</i></tt>.</ins>
<p/>
[&hellip;]
<p/>
-2- <i>Throws:</i> <ins>If <tt>index() == rhs.index()</tt>, a</ins><del>A</del>ny exception thrown by
<tt>swap(get&lt;<i>i</i>&gt;(*this), get&lt;<i>i</i>&gt;(rhs))</tt> with <i>i</i> being <tt>index()</tt><del> and
<tt>variant</tt>'s move constructor and assignment operator</del>. <ins>Otherwise, any exception thrown by the move
constructor of <tt>T<sub><i>i</i></sub></tt> or <tt>T<sub><i>j</i></sub></tt> with <tt><i>i</i></tt> being
<tt>index()</tt> and <tt><i>j</i></tt> being <tt>rhs.index()</tt>.</ins>
<p/>
-3- <i>Remarks:</i> <del>This function shall not participate in overload resolution unless <tt>is_swappable_v&lt;Ti&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>.</del> If an exception is thrown during the call to function
<tt>swap(get&lt;<i>i</i>&gt;(*this), get&lt;<i>i</i>&gt;(rhs))</tt>, the states of the contained values of
<tt>*this</tt> and of <tt>rhs</tt> are determined by the exception safety guarantee of swap for lvalues of
<tt>T<sub><i>i</i></sub></tt> with <tt><i>i</i></tt> being <tt>index()</tt>. If an exception is thrown during the 
exchange of the values of <tt>*this</tt> and <tt>rhs</tt>, the states of the values of <tt>*this</tt> and of <tt>rhs</tt> 
are determined by the exception safety guarantee of <tt>variant</tt>'s move constructor <del>and move assignment operator</del>. 
The expression inside <tt>noexcept</tt> is equivalent to the logical AND of 
<tt>is_nothrow_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; 
is_nothrow_swappable_v&lt;T<sub><i>i</i></sub>&gt;</tt> for all <tt><i>i</i></tt>.
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.7.9 [variant.specalg] as indicated:</p>

<blockquote>
<pre>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <tt>v.swap(w)</tt>.
<p/>
-2- <i>Remarks:</i> <ins>This function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T<sub><i>i</i></sub>&gt; &amp;&amp; is_swappable_v&lt;T<sub><i>i</i></sub>&gt;</tt> is
<tt>true</tt> for all <tt><i>i</i></tt>.</ins> The expression inside <tt>noexcept</tt> is equivalent to <tt>noexcept(v.swap(w))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2750" href="#2750">2750.</a> [fund.ts.v2] LWG 2451 conversion constructor constraint</h3>
<p><b>Section:</b> 99 [fund.ts.v2::optional.object.ctor] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-20 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses: fund.ts.v2</b></p>
<p>
LWG <a href="lwg-defects.html#2451">2451</a> adds a converting constructor to <tt>optional</tt> with signature:
</p>
<blockquote>
<pre>
template &lt;class U&gt;
constexpr optional(U&amp;&amp; v);
</pre>
</blockquote>
<p>
and specifies that "This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt>U</tt> is not the same type as <tt>T</tt>." 
This suffices to avoid this constructor being selected by overload resolution for arguments that should match the 
move constructor, but not for arguments that should match the copy constructor. The recent churn around tuple's 
constructors suggests that we want this constructor to not participate in overload resolution if 
<tt>remove_cv_t&lt;remove_reference_t&lt;U&gt;&gt;</tt> is the same type as <tt>T</tt>.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4600.html">N4600</a>.</p>

<blockquote class="note">
<p>
Wording relative to N4600 + LWG <a href="lwg-defects.html#2451">2451</a>, although it should be noted that this resolution should be applied 
wherever LWG <a href="lwg-defects.html#2451">2451</a> is applied, be that to the fundamentals TS or the specification of <tt>optional</tt> in the 
C++ Working Paper.
</p>
</blockquote>

<ol>
<li><p>In 99 [optional.object.ctor], modify as indicated:</p>

<blockquote>
<pre>
template &lt;class U&gt;
  constexpr optional(U&amp;&amp; v);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-43- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall 
be a <tt>constexpr</tt> constructor. This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt><ins>decay_t&lt;</ins>U<ins>&gt;</ins></tt> 
is not the same type as <tt>T</tt>. The constructor is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> 
is <tt>false</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2751" href="#2751">2751.</a> <tt>shared_ptr</tt> deleter not specified to observe expired <tt>weak_ptr</tt> instances</h3>
<p><b>Section:</b> 20.11.2.2.2 [util.smartptr.shared.dest] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Aaron Jacobs <b>Opened:</b> 2016-07-21 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>4
</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.dest">issues</a> in [util.smartptr.shared.dest].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The C++14 standard contains no language that guarantees the deleter run by a
<tt>shared_ptr</tt> will see all associated <tt>weak_ptr</tt> instances as expired. For example,
the standard doesn't appear to guarantee that the assertion in the following
snippet won't fire:
</p>
<blockquote><pre>
std::weak_ptr&lt;Foo&gt; weak;
std::shared_ptr&lt;Foo&gt; strong{
  new Foo,
  [&amp;weak] (Foo* f) {
    assert(weak.expired());
    delete f;
  },
};

weak = strong;
strong.reset();
</pre></blockquote>
<p>
It seems clear that the intent is that associated <tt>weak_ptr</tt>s are expired,
because otherwise <tt>shared_ptr</tt> deleters could resurrect a reference to an object
that is being deleted.
<p/>
Suggested fix: 20.11.2.2.2 [util.smartptr.shared.dest] should specify that the decrease in
<tt>use_count()</tt> caused by the destructor is sequenced before the call to the
deleter or the call to <tt>delete p</tt>.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2752" href="#2752">2752.</a> &quot;Throws:&quot; clauses of <tt>async</tt> and <tt>packaged_task</tt> are unimplementable</h3>
<p><b>Section:</b> 30.6.8 [futures.async], 30.6.9.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-07-07 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::async</tt> is a request from the user for type erasure; as any given function gets passed to <tt>async</tt>
which returns only <tt>future&lt;ReturnType&gt;</tt>. Therefore, it needs to be able to allocate memory, as other issues
(e.g. LWG <a href="lwg-active.html#2202">2202</a>) indicate. However, async's <em>Throws</em> clause doesn't allow an implementation to do
this, as it permits only <tt>future_error</tt>.
<p/>
<tt>std::packaged_task</tt>'s constructor allocates memory using a user supplied allocator. An implementation needs to
call the user's <tt>allocate</tt> to allocate such memory. The user's allocate function is not constrained to throwing
only <tt>bad_alloc</tt>; it can raise whatever it wants, but <tt>packaged_task</tt>'s constructor prohibits this.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Alisdair thinks the third bullet is not quite right.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<ol>
<li><p>Change 30.6.8 [futures.async] p6 to:</p>

<blockquote>
<p>
<em>Throws:</em> <tt>system_error</tt> if <tt>policy == launch::async</tt> and the implementation is unable to start a
new thread<ins>, or <tt>std::bad_alloc</tt> if memory for the internal data structures could not be allocated</ins>.
</p>
</blockquote>
</li>
<li><p>Change 30.6.9.1 [futures.task.members] p5 to:</p>

<blockquote>
<pre>
template &lt;class F&gt;
  packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre>
<blockquote>
<p>
<em>Throws:</em>
</p>
<ol style="list-style-type: none">
<li>
<ins>(?) &mdash; A</ins><del>a</del>ny exceptions thrown by the copy or move constructor of <tt>f</tt><ins>.</ins><del>, or </del>
</li>
<li>
<ins>(?) &mdash; For the first version,</ins> <tt>std::bad_alloc</tt> if memory for the internal data structures
could not be allocated<ins>.</ins>
</li>
<li>
<ins>(?) &mdash; For the second version, any exceptions thrown by
<tt>std::allocator_traits&lt;Allocator&gt;::template rebind&lt;<em>unspecified</em>&gt;::allocate</tt></ins>.
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 30.6.8 [futures.async] p6 to:</p>

<blockquote>
<p>
<em>Throws:</em> <tt>system_error</tt> if <tt>policy == launch::async</tt> and the implementation is unable to start a
new thread<ins>, or <tt>std::bad_alloc</tt> if memory for the internal data structures could not be allocated</ins>.
</p>
</blockquote>
</li>
<li><p>Change 30.6.9.1 [futures.task.members] p5 to:</p>

<blockquote>
<pre>
template &lt;class F&gt;
  packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
  packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre>
<blockquote>
<p>
<em>Throws:</em>
</p>
<ol style="list-style-type: none">
<li>
<ins>(?) &mdash; A</ins><del>a</del>ny exceptions thrown by the copy or move constructor of <tt>f</tt><ins>.</ins><del>, or </del>
</li>
<li>
<ins>(?) &mdash; For the first version,</ins> <tt>std::bad_alloc</tt> if memory for the internal data structures
could not be allocated<ins>.</ins>
</li>
<li>
<ins>(?) &mdash; For the second version, any exceptions thrown by
<tt>std::allocator_traits&lt;Allocator&gt;::template rebind_traits&lt;<em>unspecified</em>&gt;::allocate</tt></ins>.
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2753" href="#2753">2753.</a> Optional's constructors and assignments need constraints</h3>
<p><b>Section:</b> 20.6.3.1 [optional.object.ctor], 20.6.3.3 [optional.object.assign] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-22 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
To use <tt>optional&lt;T&gt;</tt> as if it were a <tt>T</tt> in generic contexts, <tt>optional&lt;T&gt;</tt>'s "generic" 
operations must behave as do those of <tt>T</tt> under overload resolution. At minimum, <tt>optional</tt>'s constructors 
and assignment operators should not participate in overload resolution with argument types that cannot be used to 
construct/assign the contained <tt>T</tt> so that <tt>is_constructible_v&lt;optional&lt;T&gt;, Args...&gt;</tt> 
(respectively <tt>is_assignable_v&lt;optional&lt;T&gt;&amp;, RHS&gt;</tt>) is equivalent to 
<tt>is_constructible_v&lt;T, Args...&gt;</tt> (respectively <tt>is_assignable_v&lt;T&amp;, RHS&gt;</tt>).
</p>
<p>
In passing, note that the Requires element for <tt>optional</tt>'s in-place <tt>initializer_list</tt> constructor 
unnecessarily duplicates its Remarks element; it should be removed.
</p>
<p>
It should also be noted that the resolution of LWG <a href="lwg-defects.html#2451">2451</a> adds constructors to <tt>optional</tt> with 
appropriate constraints, but does not constrain the additional assignment operators. If LWG chooses to apply the 
resolution of 2451 to the WP, the Requires elements of the additional assignment operators should also be converted 
to constraints as the wording herein does for the assignment operators in N4606.
</p>
<p><i>[2016-07 Chicago]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Remove 20.6.3.1 [optional.object.ctor] p3, and add a new paragraph after p6:</p>

<blockquote>
<pre>
optional(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-3- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
<ins>-?- <em>Remarks:</em> The function shall not participate in overload resolution unless 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p7, and change p11 to:</p>

<blockquote>
<pre>
optional(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-7- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-11- <em>Remarks:</em> The expression inside <tt>noexcept</tt> is equivalent to 
<tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>. <ins>The function shall not participate in 
overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p12, and change p16 to:</p>

<blockquote>
<pre>
constexpr optional(const T&amp; v);
</pre>
<blockquote>
<p>
<del>-12- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-16- <em>Remarks:</em> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>The function shall not participate 
in overload resolution unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p17, and change p21 to:</p>

<blockquote>
<pre>
constexpr optional(T&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-17- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-21- <em>Remarks:</em> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall 
be a <tt>constexpr</tt> constructor. <ins>The function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p22, and change p26 to:</p>

<blockquote>
<pre>
template &lt;class... Args&gt; 
  constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-26- <em>Remarks:</em> If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>The function shall not participate in overload 
resolution unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.1 [optional.object.ctor] p27.</p>

<blockquote>
<pre>
template &lt;class U, class... Args&gt; 
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-27- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is 
<tt>true</tt>.</del>
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p4, and change p8 to:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-4- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-8- <em>Remarks:</em> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s copy constructor, no effect. If an exception is thrown 
during the call to <tt>T</tt>'s copy assignment, the state of its contained value is as defined by the exception 
safety guarantee of <tt>T</tt>'s copy assignment. <ins>The function shall not participate in overload resolution 
unless <tt>is_copy_constructible_v&lt;T&gt; &amp;&amp; is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p9, and add a new paragraph after p14:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-9- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-14- <i>Remarks:</i> [&hellip;] If an exception is thrown during the call to <tt>T</tt>'s move
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety 
guarantee of <tt>T</tt>'s move assignment.
<p/>
<ins>The function shall not participate in overload resolution unless 
<tt>is_move_constructible_v&lt;T&gt; &amp;&amp; is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins></p>
</blockquote>
</blockquote>
</li>

<li><p>Remove 20.6.3.3 [optional.object.assign] p15, and change p19 to (yes, this wording is odd - the intent 
is that it will "do the right thing" after incorporation of LWG <a href="lwg-defects.html#2451">2451</a>):</p>

<blockquote>
<pre>
template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <em>Remarks:</em> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>v</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. The function shall not participate in overload resolution unless <tt>is_same_v&lt;decay_t&lt;U&gt;, 
T&gt;<ins> &amp;&amp; is_constructible_v&lt;T, U&gt; &amp;&amp; is_assignable_v&lt;T&amp;, U&gt;</ins></tt> is 
<tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2754" href="#2754">2754.</a> The <tt>in_place</tt> constructors and <tt>emplace</tt> functions added by P0032R3 don't require <tt>CopyConstructible</tt></h3>
<p><b>Section:</b> 20.8.3.1 [any.cons], 20.8.3.2 [any.assign], 20.8.3.3 [any.modifiers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-07-05 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.cons">active issues</a> in [any.cons].</p>
<p><b>View all other</b> <a href="lwg-index.html#any.cons">issues</a> in [any.cons].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>in_place</tt> constructors and <tt>emplace</tt> functions
added by <a href="http://wg21.link/p0032r3">P0032R3</a> don't require <tt>CopyConstructible</tt>.
<p/>
They must. Otherwise copying an <tt>any</tt> that's made to hold a non-<tt>CopyConstructible</tt>
type must fail with a run-time error. Since that's crazy, we want to prevent
storing non-<tt>CopyConstructible</tt> types in an <tt>any</tt>.
<p/>
Previously, the requirement for <tt>CopyConstructible</tt> was just on the converting
constructor template and the converting assignment operator template on <tt>any</tt>.
Now that we are adding two <tt>in_place</tt> constructor overloads and two
<tt>emplace</tt> overloads, it seems reasonable to require <tt>CopyConstructible</tt> in some more 
general location, in order to avoid repeating that requirement all over the place.
</p>

<p><i>[2016-07 &mdash; Chicago]</i></p>

<p>Monday: P1</p>
<p>Tuesday: Ville/Billy/Billy provide wording</p>

<p><i>[2016-08-02: Daniel comments]</i></p>

<p>
The P/R wording of this issue brought to my intention that the recently added <tt>emplace</tt> functions
of <tt>std::any</tt> introduced a breakage of a previous class invariant that only a <tt>decay</tt>ed type could
be stored as object into an <tt>any</tt>, this prevented storing arrays, references, functions, and <i>cv</i>-qualified
types. The new constraints added my Ville do prevent some of these types (e.g. neither arrays nor functions meet
the <tt>CopyConstructible</tt> requirements), but we need to cope with <i>cv</i>-qualified types and reference types.
</p>

<p><i>[2016-08-02: Agust&iacute;n K-ballo Berg&eacute; comments]</i></p>

<p>
Presumably the constructors <tt>any(in_place_type_t&lt;T&gt;, ...)</tt> would need to be modified in the same way 
the <tt>emplace</tt> overloads were.
</p>

<p><i>[2016-08-02: Ville adjusts the P/R to cope with the problems pointed out by Daniel's and Agust&iacute;n's comments]</i></p>

<p>Ville notes that <a href="lwg-active.html#2746">2746</a>, <a href="lwg-active.html#2754">2754</a> and <a href="lwg-active.html#2756">2756</a> all go together.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>
<blockquote class="note">
<p>
Drafting note: this P/R doesn't turn the <i>Requires</i>-clauses into <i>Remarks</i>-clauses.
We might want to do that separately, because SFINAEing the constructors
allows users to query for <tt>is_constructible</tt> and get the right answer. Failing
to mandate the SFINAE will lead to non-portable answers for <tt>is_constructible</tt>.
Currently, libstdc++ SFINAEs. That should be done as a separate issue,
as this issue is an urgent bug-fix but the mandated SFINAE is not.
</p>
</blockquote>

<ol>
<li><p>Change 20.8.3 [any.class], class <tt>any</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class any {
public:
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    void emplace(Args&amp;&amp; ...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Change 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
-6- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. 
<del>If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-11- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is <tt>false</tt>,
<tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-15- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The function shall not participate in overload resolution unless 
<ins><tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is <tt>false</tt>,
<tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and</ins> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.2 [any.assign] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any&amp; operator=(ValueType&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-7- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-8- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. <del>If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> This operator shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.3 [any.modifiers] as indicated:</p>

<blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  void emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-1- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-5- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does not 
contain a value, and any previously contained object has been destroyed. <ins>This function shall not participate 
in overload resolution unless <tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is 
<tt>false</tt>, <tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>

<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<ins>-?- <i>Requires</i>: <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements.</ins>
<p/>
-6- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does 
not contain a value, and any previously contained object has been destroyed. The function shall not participate in overload
resolution unless <ins><tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is <tt>false</tt>,
<tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and</ins> 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-03: Ville comments and revises his proposed wording]</i></p>

<p>
After discussing the latest P/R, here's an update. What this update does is that:
</p>
<ol>
<li><p>It strikes the <i>Requires</i>-clauses and does <em>not</em> add
<tt>CopyConstructible</tt> to the <i>Requires</i>-clauses.
<p/>
Rationale: <tt>any</tt> doesn't care whether the type it holds satisfies the
semantic requirements of the <tt>CopyConstructible</tt> concept. The syntactic 
requirements are now SFINAE constraints in <i>Requires</i>-clauses.</p></li>
<li><p>It reverts back towards <tt>decay_t</tt> rather than <tt>remove_cv_t</tt>, and does
<em>not</em> add the suggested SFINAE constraints for <tt>is_reference</tt>/<tt>is_array</tt>/<tt>is_function</tt>.
<p/>
Rationale:
</p>
<ol style="list-style-type:lower-alpha">
<li><p><tt>any</tt> decays by design. It's to some extent inconsistent
to not protect against decay in the <tt>ValueType</tt> constructor/assignment operator, but to protect
against decay in the <tt>in_place_t</tt> constructors and <tt>emplace</tt> functions</p></li>
<li><p>I think it's saner to just decay than to potentially run into
situations where I need to <tt>remove_reference</tt> inside <tt>in_place_t</tt>.</p></li>
</ol>
</li>
</ol>
<p>
Based on that, this P/R should supersede the previous one. We want to
look at this new P/R in LWG and potentially send it to LEWG for verification. 
Personally, I think this P/R is the more conservative one, doesn't add 
significant new functionality, and is consistent, and is
thus not really Library-Evolutionary.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 20.8.3 [any.class], class <tt>any</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class any {
public:
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    void emplace(Args&amp;&amp; ...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Change 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
-6- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
<del>-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. 
If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<del>-11- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The function shall not participate in overload resolution unless 
<ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and</ins> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.2 [any.assign] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any&amp; operator=(ValueType&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-7- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
<del>-8- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> This operator shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.3 [any.modifiers] as indicated:</p>

<blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  void emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<del>-1- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-5- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does not 
contain a value, and any previously contained object has been destroyed. <ins>This function shall not participate 
in overload resolution unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>

<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-6- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does 
not contain a value, and any previously contained object has been destroyed. The function shall not participate in overload
resolution unless <ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and</ins> 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-03: Ville comments and revises his proposed wording]</i></p>

<p>
This P/R brings back the <tt>CopyConstructible</tt> parts of the relevant
Requires-clauses but removes the other parts of the Requires-clauses.
</p>
<p><i>[2016-08 - Chicago]</i></p>

<p>Thurs PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 20.8.3 [any.class], class <tt>any</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class any {
public:
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    void emplace(Args&amp;&amp; ...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Change 20.8.3.1 [any.cons] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
-6- Let <tt>T</tt> be <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. 
<del>If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt><ins>T</ins><del>decay_t&lt;ValueType&gt;</del></tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-11- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> 
requirements</ins><del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;<del>T</del><ins>ValueType</ins>&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-15- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> 
requirements</ins><del><tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The function shall not participate in overload resolution unless 
<ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> 
and</ins> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.2 [any.assign] as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any&amp; operator=(ValueType&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-7- Let <tt>T</tt> be <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-8- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. <del>If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> This operator shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt><ins>T</ins><del>decay_t&lt;ValueType&gt;</del></tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change 20.8.3.3 [any.modifiers] as indicated:</p>

<blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  void emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-1- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> 
requirements</ins><del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-5- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does not 
contain a value, and any previously contained object has been destroyed. <ins>This function shall not participate 
in overload resolution unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>

<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>-?- Let <tt>T</tt> be <tt>decay_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<ins>-?- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements.</ins>
<p/>
-6- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does 
not contain a value, and any previously contained object has been destroyed. The function shall not participate in overload
resolution unless <ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and</ins> 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2755" href="#2755">2755.</a> &sect;[string.view.io] uses non-existent <tt>basic_string_view::to_string</tt> function</h3>
<p><b>Section:</b> 21.4.4 [string.view.io], 21.3.2.9 [string.io] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Baker <b>Opened:</b> 2016-07-26 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In looking at N4606, [string.view.io] has an <i>Effects</i> clause that references <tt>basic_string_view::to_string</tt> 
which no longer exists after the application of <a href="http://wg21.link/p0254r2">P0254R2</a>.
</p>

<p><i>[2016-07-26, Marshall suggests concrete wording]</i></p>

<p><i>[2016-07 Chicago LWG]</i></p>

<p>Monday: P0 - tentatively ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 21.3.2.9 [string.io] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               const basic_string&lt;charT, traits, Allocator&gt;&amp; str);
</pre>
<blockquote>
<p>
-5- <i>Effects:</i> <ins>Equivalent to: <tt>return os &lt;&lt; basic_string_view&lt;charT, 
traits&gt;(str);</tt></ins><del>Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) 
of <tt>os</tt>. Forms a character sequence <tt>seq</tt>, initially consisting of the elements defined by the 
range <tt>[str.begin(), str.end())</tt>. Determines padding for <tt>seq</tt> as described in 
27.7.3.6.1 [ostream.formatted.reqmts]. Then inserts <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, 
where <tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.</del>
<p/>
<del>-6- <i>Returns:</i> <tt>os</tt></del>
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 21.4.4 [string.view.io] as indicated:</p>

<blockquote>
<pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               basic_string_view&lt;charT, traits&gt; str);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> <del>Equivalent to: <tt>return os &lt;&lt; str.to_string();</tt></del><ins>Behaves 
as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]) of <tt>os</tt>. Forms a character 
sequence <tt>seq</tt>, initially consisting of the elements defined by the range <tt>[str.begin(), 
str.end())</tt>. Determines padding for <tt>seq</tt> as described in 27.7.3.6.1 [ostream.formatted.reqmts]. Then 
inserts <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of 
<tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.</ins>
<p/>
<ins>-?- <i>Returns:</i> <tt>os</tt></ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2756" href="#2756">2756.</a> C++ WP <tt>optional&lt;T&gt;</tt> should 'forward' <tt>T</tt>'s implicit conversions</h3>
<p><b>Section:</b> 20.6.3 [optional.object] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-07-26 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>1
</p>
<p><b>View other</b> <a href="lwg-index-open.html#optional.object">active issues</a> in [optional.object].</p>
<p><b>View all other</b> <a href="lwg-index.html#optional.object">issues</a> in [optional.object].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#2451">2451</a> adds converting constructors and assignment operators to <tt>optional</tt>. The committee 
voted to apply it to the Library Fundamentals 2 TS WP in Oulu as part of LWG Motion 3. In both LWG and LEWG 
discussion of this issue, it was considered to be critical to apply to the specification of <tt>optional</tt> 
before shipping C++17 &mdash; it was an oversight on the part of LWG that there was no motion brought to apply 
this resolution to the C++ WP.
<p/>
LWG <a href="lwg-active.html#2745">2745</a> proposes removal of the <tt>constexpr</tt> specifier from the declarations of the 
converting constructors from <tt>const optional&lt;U&gt;&amp;</tt> and <tt>optional&lt;U&gt;&amp;&amp;</tt> 
since they are not implementable as <tt>constexpr</tt> constructors in C++17.
<p/>
This issue proposes application of the resolution of LWG <a href="lwg-defects.html#2451">2451</a> as amended by LWG <a href="lwg-active.html#2745">2745</a> 
to the specification of <tt>optional</tt> in the C++ WP.
</p>

<p><i>[2016-07 &mdash; Chicago]</i></p>

<p>Monday: Priority set to 1; will re-review later in the week</p>

<p><i>[2016-08-03, Tomasz comments]</i></p>

<ol>
<li><p>Value forwarding constructor (<tt>template&lt;typename U&gt; optional(U&amp;&amp;)</tt>) is underspecified.</p>
<p>For the following use code:</p>

<blockquote><pre>
optional&lt;T&gt; o1;
optional&lt;T&gt; o2(o1);
</pre></blockquote>

<p>
The second constructor will invoke value forwarding <tt>(U = optional&lt;T&gt;&amp;)</tt> constructor (better match) 
instead of the <tt>optional&lt;T&gt;</tt> copy constructor, in case if <tt>T</tt> can be constructed from 
<tt>optional&lt;T&gt;</tt>. This happens for any type <tt>T</tt> that has unconstrained perfect forwarding constructor, 
especially <tt>optional&lt;any&gt;</tt>.
</p>
</li>
<li>
<p>The behavior of the construction of the <tt>optional&lt;T&gt; ot</tt> from <tt>optional&lt;U&gt; ou</tt> is 
inconsistent for classes <tt>T</tt> than can be constructed both from <tt>optional&lt;U&gt;</tt> and <tt>U</tt>. 
There are two possible semantics for such operation:
</p>
<ul>
<li><p><em>unwrapping:</em> if <tt>ou</tt> is initialized (<tt>bool(ou)</tt>), initialize contained value of <tt>ot</tt> 
from <tt>*ou</tt>, otherwise make <tt>ot</tt> uninitialized (<tt>!bool(ot)</tt>)</p></li>
<li><p><em>value forwarding:</em> initialize contained value of <tt>ot</tt> from <tt>ou</tt>, <tt>ot</tt> is always 
initialized (<tt>bool(ot)</tt>). 
<p/>
With the proposed resolution, construction is preferring <em>value forwarding</em>, 
while assignment is always using <em>unwrapping</em>.</p></li>
</ul>
<p>
For example, if we consider following class:
</p>
<blockquote>
<pre>
struct Widget
{
  Widget(int);
  Widget(optional&lt;int&gt;);
};
</pre>
</blockquote>
<p>
Notice, that such set of constructor is pretty common in situation when the construction of the 
<tt>Widget</tt> from known value is common and usage of <tt>optional</tt> version is rare. In such situation, 
presence of <tt>Widget(int)</tt> construction is an optimization used to avoid unnecessary empty checks and 
construction <tt>optional&lt;int&gt;</tt>.
<p/>
For the following declarations:
</p>
<blockquote>
<pre>
optional&lt;Widget&gt; w1(make_optional(10));
optional&lt;Widget&gt; w2;
w2 = make_optional(10);
</pre>
</blockquote>
<p>
The <tt>w1</tt> will contain a value created using <tt>Widget(optional&lt;int&gt;)</tt> constructor, 
as corresponding <em>unwrapping</em> constructor (<tt>optional&lt;U&gt; const&amp;</tt>) is eliminated by 
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> 
(<tt>is_constructible_v&lt;Widget, const optional&lt;int&gt;&amp;&gt;</tt>) having a <tt>true</tt> value.
In contrast <tt>w2</tt> will contain a value created using <tt>Widget(int)</tt> constructor, as corresponding 
value forwarding assignment (<tt>U&amp;&amp;</tt>) is eliminated by the fact that 
<tt>std::decay_t&lt;U&gt;</tt> (<tt>optional&lt;int&gt;</tt>) is specialization of <tt>optional</tt>.
<p/>
In addition, the construction is having a preference for <em>value forwarding</em> and assignment is always using 
<em>unwrapping</em>. That means that for the following class:
</p>
<blockquote><pre>
struct Thingy
{
   Thingy(optional&lt;string&gt;);
};

optional&lt;Thingy&gt; t1(optional&lt;string&gt;("test"));
</pre></blockquote>
<p>
The <tt>t1</tt> has a contained value constructed from using <tt>Thingy(optional&lt;std::string&gt;)</tt>, 
as unwrapping constructor (<tt>optional&lt;U&gt; const&amp;</tt>) are eliminated by the 
<tt>is_constructible&lt;T, U const&amp;&gt;</tt> (<tt>is_constructible&lt;Thingy, std::string const&amp;&gt;</tt>) 
being <tt>false</tt>. However the following:
</p>
<blockquote><pre>
t1 = optional&lt;std::string&gt;("test2");
</pre></blockquote>
<p>
will not compile, because, the <em>value forwarding</em> assignment (<tt>U&amp;&amp;</tt>) is eliminated by 
<tt>std::decay_t&lt;U&gt;</tt> (<tt>optional&lt;std::string&gt;</tt>) being optional specialization and the 
<em>unwrapping</em> assignment (<tt>optional&lt;U&gt; const&amp;</tt>) is ill-formed because 
<tt>is_constructible&lt;T, U const&amp;&gt;</tt> (<tt>is_constructible&lt;Thingy, std::string const&amp;&gt;</tt>) 
is <tt>false</tt>.
</p>
</li>
<li>
<p>
The semantics of construction and assignment, of <tt>optional&lt;optional&lt;V&gt;&gt;</tt> from 
<tt>optional&lt;U&gt;</tt> where <tt>U</tt> is convertible to/ same as <tt>T</tt> is also inconsistent. Firstly, 
in this situation the <tt>optional&lt;V&gt;</tt> is a type that can be constructed both from 
<tt>optional&lt;U&gt;</tt> and <tt>U</tt> so it fails into set of problem described above. However in 
addition we have following non-template constructor in <tt>optional&lt;T&gt;</tt>:
</p>
<blockquote><pre>
optional(T const&amp;);
</pre></blockquote>
<p>
Which for <tt>optional&lt;optional&lt;V&gt;&gt;</tt> is equivalent to:
</p>
<blockquote><pre>
optional(optional&lt;V&gt; const&amp;);
</pre></blockquote>
<p>
While there is no corresponding non-template assignment from <tt>T const&amp;</tt>, to make sure that 
<tt>o = {};</tt> always clear an <tt>optional o</tt>.
<p/>
So for the following declarations:
</p>
<blockquote><pre>
optional&lt;int&gt; oi;
optional&lt;short&gt; os;

optional&lt;optional&lt;int&gt;&gt; ooi1(oi);
optional&lt;optional&lt;int&gt;&gt; ooi2(os);
</pre></blockquote>
<p>
The <tt>ooi1</tt> uses <em>from-<tt>T</tt></em> constructor, while <tt>ooi2</tt> uses <em>value forwarding</em> constructor. 
In this case both <tt>ooi1</tt> and <tt>ooi2</tt> are initialized and their contained values <tt>*ooi1</tt>, 
<tt>*ooi2</tt> are uninitialized <tt>optional</tt>s. However, if we will attempt to make construction consistent 
with assignment, by preferring <em>unwrapping</em> (<tt>optional&lt;U&gt; const&amp;</tt>), then <tt>ooi2</tt> 
will end up being uninitialized.
<p/>
In summary, I believe that relation between <em>unwrapping</em>, <em>value forwarding</em> and 
<em>from-<tt>T</tt></em> construction/assignment is to subtle to being handled as defect report and requires 
a full paper analyzing possible design and their pros/cons.
</p>
</li>
</ol>

<p>Tuesday PM: Ville and Eric to implement and report back in Issaquah. Moved to Open</p>
<p>Ville notes that <a href="lwg-active.html#2746">2746</a>, <a href="lwg-active.html#2754">2754</a> and <a href="lwg-active.html#2756">2756</a> all go together.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; class optional
{
public:
  using value_type = T;
  
  <i>// 20.6.3.1, Constructors</i>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional &amp;);
  optional(optional &amp;&amp;) noexcept(<i>see below</i>);
  constexpr optional(const T &amp;);
  constexpr optional(T &amp;&amp;);
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args &amp;&amp;...);
  <ins>template &lt;class U&gt; constexpr optional(U &amp;&amp;);
  template &lt;class U&gt; optional(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; optional(optional&lt;U&gt; &amp;&amp;);</ins>
  
  [&hellip;]
  
  <i>// 20.6.3.3, Assignment</i>
  optional &amp;operator=(nullopt_t) noexcept;
  optional &amp;operator=(const optional &amp;);
  optional &amp;operator=(optional &amp;&amp;) noexcept(<i>see below</i>);
  template &lt;class U&gt; optional &amp;operator=(U &amp;&amp;);
  <ins>template &lt;class U&gt; optional&amp; operator=(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; optional&amp; operator=(optional&lt;U&gt; &amp;&amp;);</ins>
  template &lt;class... Args&gt; void emplace(Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args &amp;&amp;...);

  [&hellip;]
  
};
</pre>
</blockquote>
</li>

<li><p>In 20.6.3.1 [optional.object.ctor], insert new signature specifications after p31:</p>

<blockquote>
<p>
<ins>[<i>Note</i>: The following constructors are conditionally specified as <tt>explicit</tt>. This is typically 
implemented by declaring two such constructors, of which at most one participates in overload resolution. &mdash; 
<i>end note</i>]</ins>
</p>
<pre>
<ins>template &lt;class U&gt;
constexpr optional(U&amp;&amp; v);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Initializes the contained value as if direct-non-list-initializing an object of type <tt>T</tt> 
with the expression <tt>std::forward&lt;U&gt;(v)</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>*this</tt> contains a value.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor 
    shall be a <tt>constexpr</tt> constructor. This constructor shall not participate in overload resolution unless 
    <tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt> and <tt>U</tt> is not the same type as <tt>T</tt>.
    The constructor is <tt>explicit</tt> if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
optional(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: If <tt>rhs</tt> contains a value, initializes the contained value as if direct-non-list-initializing 
an object of type <tt>T</tt> with the expression <tt>*rhs</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same&lt;decay_t&lt;U&gt;, T&gt;</tt> is 
<tt>false</tt>, <tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt> and 
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>. The constructor is <tt>explicit</tt> 
if and only if <tt>is_convertible_v&lt;const U&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
optional(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: If <tt>rhs</tt> contains a value, initializes the contained value as if 
direct-non-list-initializing an object of type <tt>T</tt> with the expression <tt>std::move(*rhs)</tt>. 
<tt>bool(rhs)</tt> is unchanged.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws</i>: Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same&lt;decay_t&lt;U&gt;, T&gt;</tt> is 
<tt>false</tt>, <tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt> and 
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt> and <tt>U</tt> is not the same type 
as <tt>T</tt>. The constructor is <tt>explicit</tt> if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt>
is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 20.6.3.3 [optional.object.assign], change as indicated:</p>

<blockquote>
<pre>
template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
-22- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>v</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. The function shall not participate in overload resolution unless 
<ins><ins><tt>decay_t&lt;U&gt;</tt> is not <tt>nullopt_t</tt> and <tt>decay_t&lt;U&gt;</tt> is not a specialization of 
<tt>optional</tt></ins></ins><del><tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt> is <tt>true</tt></del>.
<p/>
<del>-23- <i>Notes</i>: The reason for providing such generic assignment and then constraining it so that effectively 
<tt>T == U</tt> is to guarantee that assignment of the form <tt>o = {}</tt> is unambiguous.</del>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt>.</ins>
<p/>
<ins>-?- <i>Effects</i>:</ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(const optional&lt;U&gt;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>*rhs</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s assignment, 
the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s assignment. 
The function shall not participate in overload resolution unless <tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt> is 
<tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</ins>
<p/>
<ins>-?- <i>Effects</i>: The result of the expression <tt>bool(rhs)</tt> remains unchanged. </ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(optional&lt;U&gt;&amp;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>std::move(*rhs)</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>std::move(*rhs)</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. The function shall not participate in overload resolution unless
<tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-05 Chicago LWG]</i></p>

<p>
Ville provides revised wording, that also fixes LWG <a href="lwg-active.html#2753">2753</a>.
<p/>
Rationale:
</p>
<ol>
<li><p>The resolution of LWG <a href="lwg-active.html#2753">2753</a> makes special
member functions defined as deleted in case the desired
constraints aren't met.</p></li>
<li><p>There is no decay for the converting
constructor <tt>optional(U&amp;&amp;)</tt>, there is a <tt>remove_reference</tt> instead.
The target type may hold a <i>cv</i>-qualified type, and the incoming
type may hold a <i>cv</i>-qualified type, but neither can hold a reference.
Thus, <tt>remove_reference</tt> is what we need, <tt>remove_cv</tt> would
be wrong, and <tt>decay</tt> would be wrong.</p></li>
<li><p>There is no <tt>decay</tt> or <tt>remove_reference</tt> for converting constructors like
<tt>optional(optional&lt;U&gt;)</tt>, because none is needed.</p></li>
<li><p>For <tt>optional(U&amp;&amp;)</tt>, an added constraint is that <tt>U</tt> is
not a specialization of <tt>optional</tt></p></li>
</ol>

<p><i>[2016-08, Chicago]</i></p>

<p>Fri PM: Move to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; class optional
{
public:
  using value_type = T;
  
  <i>// 20.6.3.1, Constructors</i>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional &amp;);
  optional(optional &amp;&amp;) noexcept(<i>see below</i>);
  constexpr optional(const T &amp;);
  constexpr optional(T &amp;&amp;);
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args &amp;&amp;...);
  <ins>template &lt;class U&gt; <em>EXPLICIT</em> constexpr optional(U &amp;&amp;);
  template &lt;class U&gt; <em>EXPLICIT</em> optional(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; <em>EXPLICIT</em> optional(optional&lt;U&gt; &amp;&amp;);</ins>
  
  [&hellip;]
  
  <i>// 20.6.3.3, Assignment</i>
  optional &amp;operator=(nullopt_t) noexcept;
  optional &amp;operator=(const optional &amp;);
  optional &amp;operator=(optional &amp;&amp;) noexcept(<i>see below</i>);
  template &lt;class U&gt; optional &amp;operator=(U &amp;&amp;);
  <ins>template &lt;class U&gt; optional&amp; operator=(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; optional&amp; operator=(optional&lt;U&gt; &amp;&amp;);</ins>
  template &lt;class... Args&gt; void emplace(Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args &amp;&amp;...);

  [&hellip;]
  
};
</pre>
</blockquote>
</li>

<li><p>Change 20.6.3.1 [optional.object.ctor] as indicated:</p>

<blockquote>
<pre>
optional(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-3- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall be defined as deleted
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
optional(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-7- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to <tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>.
<ins>This constructor shall be defined as deleted unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
constexpr optional(const T&amp; v);
</pre>
<blockquote>
<p>
<del>-12- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-16- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor. <ins>This constructor shall not participate in overload
resolution unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
constexpr optional(T&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-17- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-21- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor. <ins>This constructor shall not participate in overload
resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-26- <i>Remarks:</i> If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>This constructor shall not participate in overload
resolution unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-27- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is 
<tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-31- <i>Remarks:</i> The <del>function</del><ins>constructor</ins> shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>. 
If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.
</p>
</blockquote>
<p>
<ins>[<i>Note:</i> The following constructors are conditionally specified
as explicit. This is typically implemented by declaring two such
constructors, of which at most one participates in overload
resolution. &mdash; <i>end note</i>]</ins>
</p>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> constexpr optional(U&amp;&amp; v);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Initializes the contained value as if
direct-non-list-initializing an object of type <tt>T</tt> with the expression
<tt>std::forward&lt;U&gt;(v)</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>*this</tt> contains a value.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt>
constructor, this constructor shall be a <tt>constexpr</tt> constructor. This
constructor shall not participate in overload resolution unless
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, <tt>remove_reference_t&lt;U&gt;</tt> 
is not the same type as <tt>T</tt>, and <tt>U</tt> is not a specialization of <tt>optional</tt>. The
constructor is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is
<tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> optional(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> If <tt>rhs</tt> contains a value, initializes the
contained value as if direct-non-list-initializing an object of type <tt>T</tt>
with the expression <tt>*rhs</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in
overload resolution unless <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is 
<tt>true</tt> and <tt>is_same_v&lt;U, T&gt;</tt> is <tt>false</tt>. The constructor is 
explicit if and only if <tt>is_convertible_v&lt;const U&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> optional(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> If <tt>rhs</tt> contains a value, initializes the
contained value as if direct-non-list-initializing an object of type <tt>T</tt>
with the expression <tt>std::move(*rhs)</tt>. <tt>bool(rhs)</tt> is unchanged.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in
overload resolution unless <tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is 
<tt>true</tt> and <tt>is_same_v&lt;U, T&gt;</tt> is <tt>false</tt>. The constructor is 
explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>

<li><p>Change 20.6.3.3 [optional.object.assign] as indicated:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-4- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-8- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
If an exception is thrown during the call to <tt>T</tt>'s copy constructor, no effect. If an exception is thrown
during the call to <tt>T</tt>'s copy assignment, the state of its contained value is as defined by the exception
safety guarantee of <tt>T</tt>'s copy assignment. <ins>This operator shall be defined as deleted unless
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_copy_assignable_v&lt;T&gt;</tt> is
<tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-9- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-13- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T&gt; &amp;&amp; is_nothrow_move_constructible_v&lt;T&gt;
</pre></blockquote>
<p>
-14- If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s move constructor, the state of <tt>*rhs.val</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s move constructor. If an exception is 
thrown during the call to <tt>T</tt>'s move assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s move assignment. <ins>This operator 
shall be defined as deleted unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> 
remains unchanged. If an exception is thrown during the call to <tt>T</tt>'s constructor, the state 
of <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s constructor. If an 
exception is thrown during the call to <tt>T</tt>'s assignment, the state of <tt>*val</tt> and <tt>v</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s assignment. <del>The</del><ins>This</ins> function
shall not participate in overload resolution unless <del><tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt></del> 
<ins><tt>decay_t&lt;U&gt;</tt> is not <tt>nullopt_t</tt>, <tt>decay_t&lt;U&gt;</tt> is not a specialization of 
<tt>optional</tt>, <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and <tt>is_assignable_v&lt;T&amp;, 
U&gt;</tt></ins> is <tt>true</tt>.
<p/>
<del>-20- <i>Notes:</i> The reason for providing such generic assignment and then constraining it so that effectively 
<tt>T == U</tt> is to guarantee that assignment of the form <tt>o = {}</tt> is unambiguous.</del>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>:</ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(const optional&lt;U&gt;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>*rhs</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s assignment, 
the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s assignment. 
The function shall not participate in overload resolution unless <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is 
<tt>true</tt> and <tt>is_assignable_v&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt> and <tt>is_same_v&lt;U, T&gt;</tt> 
is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: The result of the expression <tt>bool(rhs)</tt> remains unchanged. </ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(optional&lt;U&gt;&amp;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>std::move(*rhs)</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>std::move(*rhs)</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. The function shall not participate in overload resolution unless <tt>is_constructible_v&lt;T, U&gt;</tt> is 
<tt>true</tt> and <tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt> and <tt>is_same_v&lt;U, T&gt;</tt> is 
<tt>false</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-08 Ville reopens and provides improved wording]</i></p>

<p>
This alternative proposed wording also resolves <a href="lwg-active.html#2753">2753</a>.
<p/>
The constructors that take a const <code>T&amp;</code> or <code>T&amp;&amp;</code> are replaced by 
a constructor template that takes a <code>U&amp;&amp;</code> and defaults <code>U = T</code>. This 
allows copy-list-initialization with empty braces to still work:
</p>
<blockquote><pre>
optional&lt;<em>whatever</em>&gt; o = {}; <i>// equivalent to initializing <code>optional</code> with <code>nullopt</code></i>
</pre></blockquote>
<p>
This resolution makes converting constructors and assignments have the same capabilities, including 
using arguments that can't be deduced. That is achieved by using a perfect-forwarding constructor
and an assignment operator that default their argument to <code>T</code>. We don't need separate 
overloads for <code>T</code>, the overload for <code>U</code> does the job:
</p>
<blockquote><pre>
optional&lt;vector&lt;int&gt;&gt; ovi{{1, 2, 3}}; // still works
ovi = {4, 5, 6, 7}; // now works, didn't work before
</pre></blockquote>
<p>
Furthermore, this proposed wording makes <code>optional</code> "always unwrap". That is, the result 
of the following initializations is the same:
</p>
<blockquote><pre>
optional&lt;optional&lt;int&gt;&gt; oi = optional&lt;int&gt;();
optional&lt;optional&lt;int&gt;&gt; oi = optional&lt;short&gt;();
</pre></blockquote>
<p>
Both of those initializations initialize the <code>optional</code> wrapping
another <code>optional</code> as if initializing with <code>nullopt</code>. Assignments
do the same. These changes solve the issues pointed out by Tomasz Kami&nacute;ski.
<p/>
This P/R has been implemented and tested as a modification on top of libstdc++'s <code>optional</code>.
</p>

<p><i>[2016-08-08 Ville and Tomasz collaborate and improve wording]</i></p>

<p>
The suggested wording retains <tt>optional</tt>'s converting constructors and assignment
operators, but provides sane results for the types Tomasz Kaminski depicts
in previous discussions.
<p/>
As opposed to the current P/R of this issue, which does "always unwrap",
this P/R does "always value-forward unless the incoming type is exactly
a type that a special member function takes by reference, and don't
unwrap if a value-forwarder can take an optional by any kind of reference".
<p/>
I and Tomasz believe this is the best compromise between the different
desires, and thus the best outcome so far.
<p/>
This P/R has been implemented and tested on libstdc++.
</p>

<p><i>[2016-09-08 Casey Carter finetunes existing resolution for move members]</i></p>


<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>Move to Tentatively Ready</p>

<p><i>[2016-10-06 Ville Voutilainen finetunes the resolution for assignment from scalars]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; class optional
{
public:
  using value_type = T;
  
  <i>// 20.6.3.1, Constructors</i>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional &amp;);
  optional(optional &amp;&amp;) noexcept(<i>see below</i>);
  <del>constexpr optional(const T &amp;);</del>
  <del>constexpr optional(T &amp;&amp;);</del>
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args &amp;&amp;...);
  <ins>template &lt;class U = T&gt; <em>EXPLICIT</em> constexpr optional(U &amp;&amp;);
  template &lt;class U&gt; <em>EXPLICIT</em> optional(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; <em>EXPLICIT</em> optional(optional&lt;U&gt; &amp;&amp;);</ins>
  
  [&hellip;]
  
  <i>// 20.6.3.3, Assignment</i>
  optional &amp;operator=(nullopt_t) noexcept;
  optional &amp;operator=(const optional &amp;);
  optional &amp;operator=(optional &amp;&amp;) noexcept(<i>see below</i>);
  template &lt;class U <ins>= T</ins>&gt; optional &amp;operator=(U &amp;&amp;);
  <ins>template &lt;class U&gt; optional&amp; operator=(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; optional&amp; operator=(optional&lt;U&gt; &amp;&amp;);</ins>
  template &lt;class... Args&gt; void emplace(Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args &amp;&amp;...);

  [&hellip;]
  
};
</pre>
</blockquote>
</li>

<li><p>Change 20.6.3.1 [optional.object.ctor] as indicated:</p>

<blockquote>
<pre>
optional(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-3- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall be defined as deleted
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
optional(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-7- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to <tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>.
<ins>This constructor shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
<del>constexpr optional(const T&amp; v);</del>
</pre>
<blockquote>
<p>
<del>-12- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
<del>-13- <i>Effects:</i> Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> 
with the expression <code>v</code>.</del>
<p/>
<del>-14- <i>Postcondition:</i> <code>*this</code> contains a value.</del>
<p/>
<del>-15- <i>Throws:</i> Any exception thrown by the selected constructor of <code>T</code>.</del>
<p/>
<del>-16- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor.</del>
</p>
</blockquote>
<pre>
<del>constexpr optional(T&amp;&amp; v);</del>
</pre>
<blockquote>
<p>
<del>-17- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
<del>-18- <i>Effects:</i> Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> 
with the expression <code>std::move(v)</code>.</del>
<p/>
<del>-19- <i>Postcondition:</i> <code>*this</code> contains a value.</del>
<p/>
<del>-20- <i>Throws:</i> Any exception thrown by the selected constructor of <code>T</code>.</del>
<p/>
<del>-21- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor.</del>
</p>
</blockquote>
<pre>
template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-26- <i>Remarks:</i> If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>This constructor shall not participate in overload
resolution unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-27- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is 
<tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-31- <i>Remarks:</i> <del>The function</del><ins>This constructor</ins> shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>. 
If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.
</p>
</blockquote>
<p>
<ins>[<i>Note:</i> The following constructors are conditionally specified
as explicit. This is typically implemented by declaring two such
constructors, of which at most one participates in overload
resolution. &mdash; <i>end note</i>]</ins>
</p>
<pre>
<ins>template &lt;class U = T&gt;
  <em>EXPLICIT</em> constexpr optional(U&amp;&amp; v);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Initializes the contained value as if
direct-non-list-initializing an object of type <tt>T</tt> with the expression
<tt>std::forward&lt;U&gt;(v)</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>*this</tt> contains a value.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt>
constructor, this constructor shall be a <tt>constexpr</tt> constructor. This
constructor shall not participate in overload resolution unless
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same_v&lt;U, 
in_place_t&gt;</tt> is <tt>false</tt>, and <tt>is_same_v&lt;optional&lt;T&gt;, decay_t&lt;U&gt;&gt;</tt> 
is <tt>false</tt>. The constructor is explicit if and only if 
<tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> optional(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> If <tt>rhs</tt> contains a value, initializes the
contained value as if direct-non-list-initializing an object of type <tt>T</tt>
with the expression <tt>*rhs</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in
overload resolution unless <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, 
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
and <tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>. 
The constructor is explicit if and only if <tt>is_convertible_v&lt;const U&amp;, T&gt;</tt> is 
<tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> optional(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> If <tt>rhs</tt> contains a value, initializes the
contained value as if direct-non-list-initializing an object of type <tt>T</tt>
with the expression <tt>std::move(*rhs)</tt>. <tt>bool(rhs)</tt> is unchanged.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in
overload resolution unless <tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
and <tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>. The constructor 
is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>

<li><p>Change 20.6.3.3 [optional.object.assign] as indicated:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-4- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-8- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
If an exception is thrown during the call to <tt>T</tt>'s copy constructor, no effect. If an exception is thrown
during the call to <tt>T</tt>'s copy assignment, the state of its contained value is as defined by the exception
safety guarantee of <tt>T</tt>'s copy assignment. <ins>This operator shall be defined as deleted unless
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_copy_assignable_v&lt;T&gt;</tt> is
<tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-9- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-13- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T&gt; &amp;&amp; is_nothrow_move_constructible_v&lt;T&gt;
</pre></blockquote>
<p>
-14- If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s move constructor, the state of <tt>*rhs.val</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s move constructor. If an exception is 
thrown during the call to <tt>T</tt>'s move assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s move assignment. <ins>This operator 
shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class U <ins>= T</ins>&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> 
remains unchanged. If an exception is thrown during the call to <tt>T</tt>'s constructor, the state 
of <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s constructor. If an 
exception is thrown during the call to <tt>T</tt>'s assignment, the state of <tt>*val</tt> and <tt>v</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s assignment. <del>The</del><ins>This</ins> function
shall not participate in overload resolution unless <del><tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt></del> 
<ins><tt>is_same_v&lt;optional&lt;T&gt;, decay_t&lt;U&gt;&gt;</tt> is <tt>false</tt>, 
<tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt>, and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt></ins> is <tt>true</tt>.
<p/>
<del>-20- <i>Notes:</i> The reason for providing such generic assignment and then constraining it so that effectively 
<tt>T == U</tt> is to guarantee that assignment of the form <tt>o = {}</tt> is unambiguous.</del>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: See Table ?.</ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(const optional&lt;U&gt;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>*rhs</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s assignment, 
the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s assignment. 
This function shall not participate in overload resolution unless <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is 
<tt>true</tt>, <tt>is_assignable_v&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
and <tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: See Table ?. The result of the expression <tt>bool(rhs)</tt> remains unchanged. </ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(optional&lt;U&gt;&amp;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>std::move(*rhs)</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>std::move(*rhs)</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. This function shall not participate in overload resolution unless <tt>is_constructible_v&lt;T, U&gt;</tt> is 
<tt>true</tt>, <tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
and <tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>

</blockquote>
  


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.6.3 [optional.object] as indicated:</p>

<blockquote>
<pre>
template &lt;class T&gt; class optional
{
public:
  using value_type = T;
  
  <i>// 20.6.3.1, Constructors</i>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional &amp;);
  optional(optional &amp;&amp;) noexcept(<i>see below</i>);
  <del>constexpr optional(const T &amp;);</del>
  <del>constexpr optional(T &amp;&amp;);</del>
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args &amp;&amp;...);
  <ins>template &lt;class U = T&gt; <em>EXPLICIT</em> constexpr optional(U &amp;&amp;);
  template &lt;class U&gt; <em>EXPLICIT</em> optional(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; <em>EXPLICIT</em> optional(optional&lt;U&gt; &amp;&amp;);</ins>
  
  [&hellip;]
  
  <i>// 20.6.3.3, Assignment</i>
  optional &amp;operator=(nullopt_t) noexcept;
  optional &amp;operator=(const optional &amp;);
  optional &amp;operator=(optional &amp;&amp;) noexcept(<i>see below</i>);
  template &lt;class U <ins>= T</ins>&gt; optional &amp;operator=(U &amp;&amp;);
  <ins>template &lt;class U&gt; optional&amp; operator=(const optional&lt;U&gt; &amp;);
  template &lt;class U&gt; optional&amp; operator=(optional&lt;U&gt; &amp;&amp;);</ins>
  template &lt;class... Args&gt; void emplace(Args &amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args &amp;&amp;...);

  [&hellip;]
  
};
</pre>
</blockquote>
</li>

<li><p>Change 20.6.3.1 [optional.object.ctor] as indicated:</p>

<blockquote>
<pre>
optional(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-3- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall be defined as deleted
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
optional(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-7- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to <tt>is_nothrow_move_constructible_v&lt;T&gt;</tt>.
<ins>This constructor shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
<del>constexpr optional(const T&amp; v);</del>
</pre>
<blockquote>
<p>
<del>-12- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
<del>-13- <i>Effects:</i> Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> 
with the expression <code>v</code>.</del>
<p/>
<del>-14- <i>Postcondition:</i> <code>*this</code> contains a value.</del>
<p/>
<del>-15- <i>Throws:</i> Any exception thrown by the selected constructor of <code>T</code>.</del>
<p/>
<del>-16- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor.</del>
</p>
</blockquote>
<pre>
<del>constexpr optional(T&amp;&amp; v);</del>
</pre>
<blockquote>
<p>
<del>-17- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
<del>-18- <i>Effects:</i> Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> 
with the expression <code>std::move(v)</code>.</del>
<p/>
<del>-19- <i>Postcondition:</i> <code>*this</code> contains a value.</del>
<p/>
<del>-20- <i>Throws:</i> Any exception thrown by the selected constructor of <code>T</code>.</del>
<p/>
<del>-21- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt> constructor, this constructor shall be 
a <tt>constexpr</tt> constructor.</del>
</p>
</blockquote>
<pre>
template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-22- <i>Requires:</i> <tt>is_constructible_v&lt;T, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-26- <i>Remarks:</i> If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, 
this constructor shall be a <tt>constexpr</tt> constructor. <ins>This constructor shall not participate in overload
resolution unless <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class U, class... Args&gt;
  constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<del>-27- <i>Requires:</i> <tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is 
<tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-31- <i>Remarks:</i> <del>The function</del><ins>This constructor</ins> shall not participate in overload resolution unless 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is <tt>true</tt>. 
If <tt>T</tt>'s constructor selected for the initialization is a <tt>constexpr</tt> constructor, this constructor 
shall be a <tt>constexpr</tt> constructor.
</p>
</blockquote>
<p>
<ins>[<i>Note:</i> The following constructors are conditionally specified
as explicit. This is typically implemented by declaring two such
constructors, of which at most one participates in overload
resolution. &mdash; <i>end note</i>]</ins>
</p>
<pre>
<ins>template &lt;class U = T&gt;
  <em>EXPLICIT</em> constexpr optional(U&amp;&amp; v);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> Initializes the contained value as if
direct-non-list-initializing an object of type <tt>T</tt> with the expression
<tt>std::forward&lt;U&gt;(v)</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>*this</tt> contains a value.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> If <tt>T</tt>'s selected constructor is a <tt>constexpr</tt>
constructor, this constructor shall be a <tt>constexpr</tt> constructor. This
constructor shall not participate in overload resolution unless
<tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, <tt>is_same_v&lt;U, 
in_place_t&gt;</tt> is <tt>false</tt>, and <tt>is_same_v&lt;optional&lt;T&gt;, decay_t&lt;U&gt;&gt;</tt> 
is <tt>false</tt>. The constructor is explicit if and only if 
<tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> optional(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> If <tt>rhs</tt> contains a value, initializes the
contained value as if direct-non-list-initializing an object of type <tt>T</tt>
with the expression <tt>*rhs</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in
overload resolution unless <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, 
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
and <tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>. 
The constructor is explicit if and only if <tt>is_convertible_v&lt;const U&amp;, T&gt;</tt> is 
<tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt;
  <em>EXPLICIT</em> optional(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects:</i> If <tt>rhs</tt> contains a value, initializes the
contained value as if direct-non-list-initializing an object of type <tt>T</tt>
with the expression <tt>std::move(*rhs)</tt>. <tt>bool(rhs)</tt> is unchanged.</ins>
<p/>
<ins>-?- <i>Postconditions:</i> <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.</ins>
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in
overload resolution unless <tt>is_constructible_v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
and <tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>. The constructor 
is explicit if and only if <tt>is_convertible_v&lt;U&amp;&amp;, T&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>

<li><p>Change 20.6.3.3 [optional.object.assign] as indicated:</p>

<blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; rhs);
</pre>
<blockquote>
<p>
<del>-4- <i>Requires:</i> <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_copy_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-8- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
If an exception is thrown during the call to <tt>T</tt>'s copy constructor, no effect. If an exception is thrown
during the call to <tt>T</tt>'s copy assignment, the state of its contained value is as defined by the exception
safety guarantee of <tt>T</tt>'s copy assignment. <ins>This operator shall be defined as deleted unless
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_copy_assignable_v&lt;T&gt;</tt> is
<tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; rhs) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
<del>-9- <i>Requires:</i> <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and 
<tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-13- <i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to:
</p>
<blockquote><pre>
is_nothrow_move_assignable_v&lt;T&gt; &amp;&amp; is_nothrow_move_constructible_v&lt;T&gt;
</pre></blockquote>
<p>
-14- If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s move constructor, the state of <tt>*rhs.val</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s move constructor. If an exception is 
thrown during the call to <tt>T</tt>'s move assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s move assignment. <ins>This operator 
shall not participate in overload resolution unless <tt>is_move_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_move_assignable_v&lt;T&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class U <ins>= T</ins>&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; v);
</pre>
<blockquote>
<p>
<del>-15- <i>Requires:</i> <tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt> and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>.</del>
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> 
remains unchanged. If an exception is thrown during the call to <tt>T</tt>'s constructor, the state 
of <tt>v</tt> is determined by the exception safety guarantee of <tt>T</tt>'s constructor. If an 
exception is thrown during the call to <tt>T</tt>'s assignment, the state of <tt>*val</tt> and <tt>v</tt> 
is determined by the exception safety guarantee of <tt>T</tt>'s assignment. <del>The</del><ins>This</ins> function
shall not participate in overload resolution unless <del><tt>is_same_v&lt;decay_t&lt;U&gt;, T&gt;</tt></del> 
<ins><tt>is_same_v&lt;optional&lt;T&gt;, decay_t&lt;U&gt;&gt;</tt> is <tt>false</tt>,
conjunction_v&lt;is_scalar&lt;T&gt;, is_same&lt;T, decay_t&lt;U&gt;&gt;&gt; is <tt>false</tt>,
<tt>is_constructible_v&lt;T, U&gt;</tt> is <tt>true</tt>, and 
<tt>is_assignable_v&lt;T&amp;, U&gt;</tt></ins> is <tt>true</tt>.
<p/>
<del>-20- <i>Notes:</i> The reason for providing such generic assignment and then constraining it so that effectively 
<tt>T == U</tt> is to guarantee that assignment of the form <tt>o = {}</tt> is unambiguous.</del>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(const optional&lt;U&gt;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: See Table ?.</ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(const optional&lt;U&gt;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>*rhs</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s assignment, 
the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s assignment. 
This function shall not participate in overload resolution unless <tt>is_constructible_v&lt;T, const U&amp;&gt;</tt> is 
<tt>true</tt>, <tt>is_assignable_v&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
and <tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>
<pre>
<ins>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(optional&lt;U&gt;&amp;&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: See Table ?. The result of the expression <tt>bool(rhs)</tt> remains unchanged. </ins>
</p>
<table border="1">
<caption><ins>Table ? &mdash; <tt>optional::operator=(optional&lt;U&gt;&amp;&amp;)</tt> effects</ins></caption>

<tr>
<th></th>
<th><ins><b><tt>*this</tt> contains a value</b></ins></th>
<th><ins><b><tt>*this</tt> does not contain a value</b></ins></th>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> contains a value</b></ins></td>
<td><ins>assigns <tt>std::move(*rhs)</tt> to the contained value</ins></td>
<td><ins>initializes the contained value as if direct-non-list-initializing an object of type 
<tt>T</tt> with <tt>std::move(*rhs)</tt></ins></td>
</tr>

<tr>
<td><ins><b><tt>rhs</tt> does not contain a value</b></ins></td>
<td><ins>destroys the contained value by calling <tt>val-&gt;T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>

</table> 
<p>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Postconditions</i>: <tt>bool(rhs) == bool(*this)</tt>.</ins>
<p/>
<ins>-?- <i>Remarks</i>: If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged. 
If an exception is thrown during the call to <tt>T</tt>'s constructor, the state of <tt>*rhs.val</tt> is determined by the 
exception safety guarantee of <tt>T</tt>'s constructor. If an exception is thrown during the call to <tt>T</tt>'s 
assignment, the state of <tt>*val</tt> and <tt>*rhs.val</tt> is determined by the exception safety guarantee of <tt>T</tt>'s 
assignment. This function shall not participate in overload resolution unless <tt>is_constructible_v&lt;T, U&gt;</tt> is 
<tt>true</tt>, <tt>is_assignable_v&lt;T&amp;, U&gt;</tt> is <tt>true</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_constructible_v&lt;T, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible_v&lt;const optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible&lt;const optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_convertible&lt;optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>,
<tt>is_assignable_v&lt;T&amp;, const optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>,
and <tt>is_assignable_v&lt;T&amp;, optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>.</ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>





<hr>
<h3><a name="2757" href="#2757">2757.</a> <tt>std::string{}.insert(3, "ABCDE", 0, 1)</tt> is ambiguous</h3>
<p><b>Section:</b> 21.3.1.6.4 [string::insert] <b>Status:</b> <a href="lwg-active.html#Resolved">Tentatively Resolved</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-07-30 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#string::insert">issues</a> in [string::insert].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Resolved">Tentatively Resolved</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Before C++17, we had the following signature to <tt>std::basic_string</tt>:
</p>
<blockquote><pre>
basic_string&amp;
  insert(size_type pos1, const basic_string&amp; str, size_type pos2, size_type n = npos);
</pre></blockquote>
<p>
Unlike most of the other member functions on <tt>std::basic_string</tt>, there were not corresponding
versions that take a <tt>charT*</tt> or <tt>(charT *, size)</tt>.
<p/>
In <a href="http://wg21.link/p0254r2">p0254r2</a>, we added:
</p>
<blockquote><pre>
basic_string&amp;
  insert(size_type pos1, basic_string_view&lt;charT, traits&gt; sv, size_type pos2, size_type n = npos);
</pre></blockquote>
<p>
which made the code above ambiguous. There are two conversions from "<tt>const charT*</tt>", 
one to <tt>basic_string</tt>, and the other to <tt>basic_string_view</tt>, and they're both equally 
good (in the view of the compiler).
<p/>
This ambiguity also occurs with the calls
</p>
<blockquote><pre>
assign(const basic_string&amp; str,             size_type pos, size_type n = npos);
assign(basic_string_view&lt;charT, traits&gt; sv, size_type pos, size_type n = npos);
</pre></blockquote>
<p>
but I will file a separate issue (<a href="lwg-active.html#2758">2758</a>) for that.
<p/>
A solution is to add <em>even more</em> overloads to <tt>insert</tt>, to make it match all the other member
functions of <tt>basic_string</tt>, which come in fours (<tt>string</tt>, <tt>pointer</tt>, <tt>pointer + size</tt>, 
<tt>string_view</tt>).
</p>

<p><i>[2016-08-03, Chicago, Robert Douglas provides wording]</i></p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.1 [basic.string] modify the synopsis for <tt>basic_string</tt> as follows:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
  public:
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                         size_type pos2, size_type n = npos);
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>In 21.3.1.6.4 [string::insert], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt;</del><ins>T</ins> sv,
                     size_type pos2, size_type n = npos);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_same_v&lt;T, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-08-04, Chicago, Robert Douglas comments]</i></p>

<p>
For the sake of simplicity, the previous wording suggestion has been merged into the proposed wording
of LWG <a href="lwg-active.html#2758">2758</a>.
</p>

<p><i>[08-2016, Chicago]</i></p>

<p>Fri PM: Move to Tentatively Ready (along with <a href="lwg-active.html#2758">2758</a>).</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>Since <a href="lwg-active.html#2758">2758</a> has been moved back to Open, move this one, too</p>

<p><i>[2016-10 Telecom]</i></p>

<p>Ville's wording for <a href="lwg-active.html#2758">2758</a> has been implemented in libstdc++ and libc++. Move <a href="lwg-active.html#2758">2758</a> to Tentatively Ready and this one to Tentatively Resolved</p>


<p><b>Proposed resolution:</b></p>
<p>
This issue is resolved by the proposed wording for LWG <a href="lwg-active.html#2758">2758</a>.
</p>





<hr>
<h3><a name="2758" href="#2758">2758.</a> <tt>std::string{}.assign("ABCDE", 0, 1)</tt> is ambiguous</h3>
<p><b>Section:</b> 21.3.1.6.3 [string::assign] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2016-07-30 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#string::assign">issues</a> in [string::assign].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Before C++17, we had the following signature to <tt>std::basic_string</tt>:
</p>
<blockquote><pre>
basic_string&amp;
  assign(const basic_string&amp; str, size_type pos, size_type n = npos);
</pre></blockquote>
<p>
Unlike most of the other member functions on <tt>std::basic_string</tt>, there were not corresponding
versions that take a <tt>charT*</tt> or <tt>(charT *, size)</tt>.
<p/>
In <a href="http://wg21.link/p0254r2">p0254r2</a>, we (I) added:
</p>
<blockquote><pre>
basic_string&amp;
  assign(basic_string_view&lt;charT, traits&gt; sv, size_type pos, size_type n = npos);
</pre></blockquote>
<p>
which made the code above ambiguous. There are two conversions from "<tt>const charT*</tt>", 
one to <tt>basic_string</tt>, and the other to <tt>basic_string_view</tt>, and they're both equally 
good (in the view of the compiler).
<p/>
This ambiguity also occurs with the calls
</p>
<blockquote><pre>
insert(size_type pos1, const basic_string&amp; str,             size_type pos2, size_type n = npos);
insert(size_type pos1, basic_string_view&lt;charT, traits&gt; sv, size_type pos2, size_type n = npos);
</pre></blockquote>
<p>
but I will file a separate issue (<a href="lwg-active.html#2757">2757</a>) for that.
<p/>
A solution is to add <em>even more</em> overloads to <tt>assign</tt>, to make it match all the other member
functions of <tt>basic_string</tt>, which come in fours (<tt>string</tt>, <tt>pointer</tt>, <tt>pointer + size</tt>, 
<tt>string_view</tt>).
</p>

<p><i>[2016-08-03, Chicago, Robert Douglas provides wording]</i></p>


<p><i>[2016-08-05, Tim Song comments]</i></p>

<p>
On the assumption that the <tt>basic_string</tt> version is untouchable, I like the updated P/R, with a couple comments:
</p>
<ol>
<li><p>If it's constraining on <tt>is_convertible</tt> to <tt>basic_string_view</tt>, then I think it should take 
by reference to avoid copying <tt>T</tt>, which can be arbitrarily expensive. Both <tt>const T&amp;</tt> and 
<tt>T&amp;&amp;</tt> should work; the question is whether to accommodate non-const <tt>operator basic_string_view()</tt>s 
(which arguably shouldn't exist).</p></li>
<li><p>Minor issue: <tt>compare</tt> tests <tt>is_convertible</tt> and then uses direct-initialization syntax 
(which is <tt>is_constructible</tt>). They should match, because it's possible to have <tt>basic_string_view sv = t;</tt> 
succeed yet <tt>basic_string_view sv(t);</tt> fail.</p></li>
</ol>

<p><i>[2016-08-05, Chicago LWG]</i></p>

<ol>
<li>breaking ABI was a non-starter</li>
<li>we want to convert <tt>char const*</tt> to <tt>basic_string_view</tt> if possible</li>
<li>we want to take the original type by reference, to avoid new user string types from being copied</li>
<li>it is unfortunate that each length of string literal will generate a new entry in the symbol table</li>
</ol>
<p>Given feedback from discussion, we wish to go with the <tt>is_convertible_v</tt> method, but change:</p>
<ol>
<li>the function parameter type to <tt>T const&amp;</tt> for each overload</li>
<li>the parameter type in <tt>is_convertible_v</tt> to <tt>T const&amp;</tt></li>
<li>the initialization of <tt>sv(t)</tt> to <tt>sv = t</tt></li>
</ol>

<p><i>[2016-08, Chicago]</i></p>

<p>Fri PM: Move to Tentatively Ready</p>

<p><i>[2016-08-16, Jonathan Wakeley reopens]</i></p>

<p>
The P/R is not correct, the new overloads get chosen in preference to
the overloads taking <tt>const char*</tt> when passed a <tt>char*</tt>:
</p>
<blockquote><pre>
#include &lt;string&gt;

int main () {
  std::string str("a");
  char c = 'b';
  str.replace(0, 1, &amp;c, 1);
  if (str[0] != 'b')
    __builtin_abort();
}
</pre></blockquote>
<p>
With the resolution of 2758 this is now equivalent to:
</p>
<blockquote><pre>
str.replace(0, 1, string_view{&amp;c, 1}, 1);
</pre></blockquote>
<p>
which replaces the character with <tt>string_view{"b", 1}.substr(1, npos)</tt>
i.e. an empty string.
<p/>
The SFINAE constraints need to disable the new overloads for (at
least) the case of non-const <tt>value_type*</tt> arguments.
<p/>
I've implemented an alternative resolution, which would be specified as:
</p>
<blockquote><p>
<i>Remarks:</i> This function shall not participate in overload resolution
unless <tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is
<tt>true</tt> <ins>and <tt>is_convertible_v&lt;const T&amp;, const charT*&gt;</tt> is <tt>false</tt></ins>.
</p></blockquote>
<p>
All the overloads have the same problem.
<p/>
This program prints no output in C++14, and we should make sure it prints no output in C++17 too:
</p>
<blockquote><pre>
#include &lt;string&gt;

int main()
{
  std::string str("a");
  char c[1] = { 'b' };
  str.append(c, 1);
  if (str != "ab")
    puts("bad append");
  str.assign(c, 1);
  if (str != "b")
    puts("bad assign");
  str.insert(0, c, 1);
  if (str != "bb")
    puts("bad insert");
  str.replace(0, 2, c, 1);
  if (str != "b")
    puts("bad replace");
  if (str.compare(0, 1, c, 1))
    puts("bad compare");
}
</pre></blockquote>
<p>
Ville and I considered "<tt>is_same_v&lt;decay_t&lt;T&gt;, char*&gt;</tt> is <tt>false</tt>" but
that would still select the wrong overload for an array of const <tt>char</tt>,
because the new function template would be preferred to doing an array-to-pointer conversion to 
call the old overload.
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>Ville to provide updated wording; Marshall to implement</p>
  
<p><i>[2016-10-05]</i></p>

<p>
Ville provides revised wording.
</p>

<p><i>[2016-10 Telecom]</i></p>

<p>Ville's wording has been implemented in libstdc++ and libc++. Move this to Tentatively Ready and <a href="lwg-active.html#2757">2757</a> to Tentatively Resolved</p>


<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.1 [basic.string] modify the synopsis for <tt>basic_string</tt> as follows:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
  public:
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos2, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; replace(size_type pos1, size_type n1,
                          <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                          size_type pos2, size_type n2 = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    int compare(size_type pos1, size_type n1,
                <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                size_type pos2, size_type n2 = npos) const;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>In 21.3.1.6.2 [string::append], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos, size_type n = npos);
</pre>
<blockquote>
<p>
-7- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos &gt; sv.size()</tt>.
<p/>
-8- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length 
<tt>rlen</tt> of the string to append as the smaller of <tt>n</tt> and <tt>sv.size() - pos</tt> 
and calls <tt>append(sv.data() + pos, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-9- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.1.6.3 [string::assign], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos, size_type n = npos);
</pre>
<blockquote>
<p>
-9- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos &gt; sv.size()</tt>.
<p/>
-10- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length 
<tt>rlen</tt> of the string to assign as the smaller of <tt>n</tt> and <tt>sv.size() - pos</tt> 
and calls <tt>assign(sv.data() + pos, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-11- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>


<li><p>In 21.3.1.6.4 [string::insert], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos2, size_type n = npos);
</pre>
<blockquote>
<p>
-6- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos1 &gt; size()</tt> or <tt>pos2 &gt; sv.size()</tt>.
<p/>
-7- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length <tt>rlen</tt> 
of the string to assign as the smaller of <tt>n</tt> and <tt>sv.size() - pos2</tt> and calls 
<tt>insert(pos1, sv.data() + pos2, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-8- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.1.6.6 [string::replace], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; replace(size_type pos1, size_type n1, 
                     <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos2, size_type n2 = npos);
</pre>
<blockquote>
<p>
-6- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos1 &gt; size()</tt> or <tt>pos2 &gt; sv.size()</tt>.
<p/>
-7- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length <tt>rlen</tt> 
of the string to be inserted as the smaller of <tt>n2</tt> and <tt>sv.size() - pos2</tt> and calls 
<tt>replace(pos1, n1, sv.data() + pos2, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
<p/>
-8- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.1.7.9 [string::compare], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
int compare(size_type pos1, size_type n1,
            <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
            size_type pos2, size_type n2 = npos) const;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return basic_string_view&lt;charT, traits&gt;(this.data(), pos1, n1).compare(sv, pos2, n2);
<ins>}</ins>
</pre></blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>
</blockquote>

<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>In 21.3.1 [basic.string] modify the synopsis for <tt>basic_string</tt> as follows:</p>

<blockquote>
<pre>
namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
    class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
  public:
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                         size_type pos2, size_type n = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    basic_string&amp; replace(size_type pos1, size_type n1,
                          <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                          size_type pos2, size_type n2 = npos);
    [&hellip;]
    <ins>template&lt;class T&gt;</ins>
    int compare(size_type pos1, size_type n1,
                <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                size_type pos2, size_type n2 = npos) const;
    [&hellip;]
  };
}
</pre>
</blockquote>
</li>

<li><p>In 21.3.1.6.2 [string::append], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; append(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos, size_type n = npos);
</pre>
<blockquote>
<p>
-7- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos &gt; sv.size()</tt>.
<p/>
-8- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length 
<tt>rlen</tt> of the string to append as the smaller of <tt>n</tt> and <tt>sv.size() - pos</tt> 
and calls <tt>append(sv.data() + pos, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
<p/>
-9- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.1.6.3 [string::assign], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; assign(<del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos, size_type n = npos);
</pre>
<blockquote>
<p>
-9- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos &gt; sv.size()</tt>.
<p/>
-10- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length 
<tt>rlen</tt> of the string to assign as the smaller of <tt>n</tt> and <tt>sv.size() - pos</tt> 
and calls <tt>assign(sv.data() + pos, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
<p/>
-11- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>


<li><p>In 21.3.1.6.4 [string::insert], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; insert(size_type pos1, <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos2, size_type n = npos);
</pre>
<blockquote>
<p>
-6- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos1 &gt; size()</tt> or <tt>pos2 &gt; sv.size()</tt>.
<p/>
-7- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length <tt>rlen</tt> 
of the string to assign as the smaller of <tt>n</tt> and <tt>sv.size() - pos2</tt> and calls 
<tt>insert(pos1, sv.data() + pos2, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
<p/>
-8- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.3.1.6.6 [string::replace], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
basic_string&amp; replace(size_type pos1, size_type n1, 
                     <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
                     size_type pos2, size_type n2 = npos);
</pre>
<blockquote>
<p>
-6- <i>Throws:</i> <tt>out_of_range</tt> if <tt>pos1 &gt; size()</tt> or <tt>pos2 &gt; sv.size()</tt>.
<p/>
-7- <i>Effects:</i> <ins>Creates a variable, <tt>sv</tt>, as if by 
<tt>basic_string_view&lt;charT, traits&gt; sv = t</tt>.</ins> Determines the effective length <tt>rlen</tt> 
of the string to be inserted as the smaller of <tt>n2</tt> and <tt>sv.size() - pos2</tt> and calls 
<tt>replace(pos1, n1, sv.data() + pos2, rlen)</tt>.
<p/>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
<p/>
-8- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote>
</blockquote>
</li>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording changes below are for the same part of the standard as <a href="lwg-active.html#2771">2771</a>. 
However, they do not conflict. This one changes the definition of the routine, while the other changes the "Effects".
&mdash; <i>end drafting note</i>]
</p>
</blockquote>

<li><p>In 21.3.1.7.9 [string::compare], modify <tt>basic_string_view</tt> overload as follows:</p>

<blockquote>
<pre>
<ins>template&lt;class T&gt;</ins>
int compare(size_type pos1, size_type n1,
            <del>basic_string_view&lt;charT, traits&gt; sv</del><ins>const T&amp; t</ins>,
            size_type pos2, size_type n2 = npos) const;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
<ins>{</ins>
  <ins>basic_string_view&lt;charT, traits&gt; sv = t;</ins>
  return basic_string_view&lt;charT, traits&gt;(this.data(), pos1, n1).compare(sv, pos2, n2);
<ins>}</ins>
</pre></blockquote>
<p>
<ins>-?- <i>Remarks:</i> This function shall not participate in overload resolution unless
<tt>is_convertible_v&lt;const T&amp;, basic_string_view&lt;charT, traits&gt;&gt;</tt> is <tt>true</tt>
and is_convertible_v&lt;const T&amp;, const charT*&gt; is <tt>false</tt>.</ins>
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2759" href="#2759">2759.</a> <tt>gcd</tt> / <tt>lcm</tt> and <tt>bool</tt> for the WP</h3>
<p><b>Section:</b> 26.8.13 [numeric.ops.gcd], 26.8.14 [numeric.ops.lcm] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Walter Brown <b>Opened:</b> 2016-08-01 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
With the acceptance of <tt>gcd</tt> and <tt>lcm</tt> in the working draft, the same problem as pointed out by
LWG <a href="lwg-active.html#2733">2733</a> exists here as well and should be fixed accordingly.
</p>

<p><i>[2016-08, Chicago]</i></p>

<p>Monday PM: Moved to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Adjust 26.8.13 [numeric.ops.gcd] p2 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; gcd(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>

<li><p>Adjust 26.8.14 [numeric.ops.lcm] p2 as indicated:</p>

<blockquote>
<pre>
template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M, N&gt; lcm(M m, N n);
</pre>
<blockquote>
<p>
[&hellip;]
<p/>
-2- <i>Remarks:</i> If either <tt>M</tt> or <tt>N</tt> is not an integer type, <ins>or if either is (possibly <i>cv</i>-qualified) 
<tt>bool</tt>,</ins> the program is ill-formed. 
</p>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2760" href="#2760">2760.</a> non-const <tt>basic_string::data</tt> should not invalidate iterators</h3>
<p><b>Section:</b> 21.3.1.1 [string.require] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Baker <b>Opened:</b> 2016-08-03 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.require">active issues</a> in [string.require].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
21.3.1.1 [string.require]/4 does not list non-const <tt>basic_string::data()</tt> as being a 
function that may be called with the guarantee that it will not invalidate references, pointers, and 
iterators to elements of a <tt>basic_string</tt> object.
</p>

<p><i>[2016-08 Chicago]</i></p>

<p>Wed PM: Move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Change 21.3.1.1 [string.require]/4 as indicated:</p>

<blockquote>
<p>
-4- References, pointers, and iterators referring to the elements of a <tt>basic_string</tt> sequence 
may be invalidated by the following uses of that <tt>basic_string</tt> object:
</p>
<ul>
<li><p>as an argument to any standard library function taking a reference to non-const <tt>basic_string</tt> as an
argument.(footnote 230)</p></li>
<li><p>Calling non-const member functions, except <tt>operator[]</tt>, <tt>at</tt>, <ins>data,</ins> <tt>front</tt>, 
<tt>back</tt>, <tt>begin</tt>, <tt>rbegin</tt>, <tt>end</tt>, and <tt>rend</tt>.</p></li>
</ul>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2762" href="#2762">2762.</a> <tt>unique_ptr operator*()</tt> should be <tt>noexcept</tt></h3>
<p><b>Section:</b> 27.10.12.3 [directory_entry.obs] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2016-08-04 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View other</b> <a href="lwg-index-open.html#directory_entry.obs">active issues</a> in [directory_entry.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#directory_entry.obs">issues</a> in [directory_entry.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
See LWG <a href="lwg-active.html#2337">2337</a>. Since we aren't removing <tt>noexcept</tt> from <tt>shared_ptr</tt>'s 
<tt>operator*</tt>, we should consider adding <tt>noexcept</tt> to <tt>unique_ptr</tt>'s <tt>operator*</tt>.
</p>

<p><i>[2016-08 &mdash; Chicago]</i></p>

<p>Thurs PM: P3, and status to 'LEWG'</p>

<p><i>[2016-08-05 Chicago]</i></p>

<p>
Ville provides an initial proposed wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<blockquote class="note">
<p>
[Drafting note: since this issue is all about consistency, <tt>optional</tt>'s pointer-like operators 
are additionally included.]
</p>
</blockquote>

<ol>
<li><p>In 20.11.1.2 [unique.ptr.single] synopsis, edit as follows:</p>

<blockquote>
<pre>
add_lvalue_reference_t&lt;T&gt; operator*() const <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Before 20.11.1.2.4 [unique.ptr.single.observers]/1, edit as follows:</p>

<blockquote>
<pre>
add_lvalue_reference_t&lt;T&gt; operator*() const <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>In 20.6.3 [optional.object] synopsis, edit as follows:</p>

<blockquote>
<pre>
constexpr T const *operator-&gt;() const <ins>noexcept</ins>;
constexpr T *operator-&gt;() <ins>noexcept</ins>;
constexpr T const &amp;operator*() const &amp; <ins>noexcept</ins>;
constexpr T &amp;operator*() &amp; <ins>noexcept</ins>;
constexpr T &amp;&amp;operator*() &amp;&amp; <ins>noexcept</ins>;
constexpr const T &amp;&amp;operator*() const &amp;&amp; <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Before 20.6.3.5 [optional.object.observe]/1, edit as follows:</p>

<blockquote>
<pre>
constexpr T const* operator-&gt;() const <ins>noexcept</ins>;
constexpr T* operator-&gt;() <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Before 20.6.3.5 [optional.object.observe]/5, edit as follows:</p>

<blockquote>
<pre>
constexpr T const&amp; operator*() const &amp; <ins>noexcept</ins>;
constexpr T&amp; operator*() &amp; <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

<li><p>Before 20.6.3.5 [optional.object.observe]/9, edit as follows:</p>

<blockquote>
<pre>
constexpr T&amp;&amp; operator*() &amp;&amp; <ins>noexcept</ins>;
constexpr const T&amp;&amp; operator*() const &amp;&amp; <ins>noexcept</ins>;
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2763" href="#2763">2763.</a> <code>common_type_t&lt;void, void&gt;</code> is undefined</h3>
<p><b>Section:</b> 20.15.7.6 [meta.trans.other] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tim Song <b>Opened:</b> 2016-08-10 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.trans.other">active issues</a> in [meta.trans.other].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.trans.other">issues</a> in [meta.trans.other].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are no xvalues of type <i>cv</i> <code>void</code> (see [basic.lval]/6), so the current wording appears 
to mean that there is no <code>common_type_t&lt;void, void&gt;</code>. Is that intended?
</p>

<p><i>[2016-08-11, Daniel comments]</i></p>

<p>
This is strongly related to LWG <a href="lwg-active.html#2465">2465</a>. It should be considered to resolve <a href="lwg-active.html#2465">2465</a>
by this revised wording.
</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Edit 20.15.7.6 [meta.trans.other]/3 as indicated:</p>
<blockquote class="note">
<p>
[<i>Drafting note</i>: The proposed wording below simply goes back to using <code>declval</code>, which already does the right 
thing. To describe this in words would be something like "if <tt>D1</tt> is <tt>void</tt>, a prvalue of type 
<tt>void</tt> that is not a (possibly parenthesized) <i>throw-expression</i>, otherwise an xvalue of type <tt>D1</tt>", which 
seems unnecessarily convoluted at best. &mdash; <i>end drafting note</i>]
</p>
</blockquote>
<blockquote>
<p>
For the <tt>common_type</tt> trait applied to a parameter pack <tt>T</tt> of types, the member <tt>type</tt> 
shall be either defined or not present as follows:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If <tt>sizeof...(T)</tt> is zero, there shall be no member <tt>type</tt>.</p></li>
<li><p>(3.2) &mdash; If <tt>sizeof...(T)</tt> is one, let <tt>T0</tt> denote the sole type in the pack <tt>T</tt>. 
The member typedef <tt>type</tt> shall denote the same type as <tt>decay_t&lt;T0&gt;</tt>.</p></li>
<li><p>(3.3) &mdash; If <tt>sizeof...(T)</tt> is greater than two, let <tt>T1</tt>, <tt>T2</tt>, and <tt>R</tt>, 
respectively, denote the first, second, and (pack of) remaining types comprising <tt>T</tt>. 
[<i>Note:</i> <tt>sizeof...(R)</tt> may be zero. &mdash; <i>end note</i>] Let <tt>C</tt> denote the
type, if any, of an unevaluated conditional expression (5.16 [expr.cond]) whose first operand is an arbitrary value
of type <tt>bool</tt>, whose second operand is <del>an xvalue of type <tt>T1</tt></del><ins><code>declval&lt;T1&gt;()</code></ins>,
and whose third operand is <del>an xvalue of type <tt>T2</tt></del><ins><code>declval&lt;T2&gt;()</code></ins>. If there is 
such a type <tt>C</tt>, the member typedef <tt>type</tt> shall denote the same type, if any, 
as <tt>common_type_t&lt;C, R...&gt;</tt>. Otherwise, there shall be no member <tt>type</tt>.</p></li>
</ol>
</blockquote>
</li>
<li><p> The following wording is a merge of the above with the current proposed resolution of <a href="lwg-active.html#2465">2465</a>, to provide 
editorial guidance if both proposed resolutions are accepted:</p>

<blockquote>
<p>
-3- <ins>Note A:</ins> For the <tt>common_type</tt> trait applied to a parameter pack <tt>T</tt> of types, the 
member <tt>type</tt> shall be either defined or not present as follows:
</p>
<ol style="list-style-type: none">
<li><p>(3.1) &mdash; If <tt>sizeof...(T)</tt> is zero, there shall be no member <tt>type</tt>.</p></li>
<li><p>(3.2) &mdash; If <tt>sizeof...(T)</tt> is one, let <tt>T0</tt> denote the sole type in the pack <tt>T</tt>. 
The member typedef <tt>type</tt> shall denote the same type as <tt>decay_t&lt;T0&gt;</tt>.</p></li>
<li><p>(3.3) &mdash; <ins>If <tt>sizeof...(T)</tt> is two, let <code>T1</code> and <code>T2</code>, respectively,
denote the first and second types comprising <code>T</code>, and let <code>D1</code> and <code>D2</code>, 
respectively, denote <code>decay_t&lt;T1&gt;</code> and <code>decay_t&lt;T2&gt;</code>.</ins></p>
<ol style="list-style-type: none">
<li><p>(3.3.1) &mdash; <ins>If <code>is_same_v&lt;T1, D1&gt;</code> and <code>is_same_v&lt;T2, D2&gt;</code>,
let <code>C</code> denote the type of an unevaluated conditional expression (5.16 [expr.cond])
whose first operand is an arbitrary value of type <code>bool</code>,
whose second operand is <code>declval&lt;D1&gt;()</code>,
and whose third operand is <code>declval&lt;D2&gt;()</code>.
[<i>Note:</i> This will not apply if there is a specialization <code>common_type&lt;D1, D2&gt;</code>. &mdash; 
<i>end note</i>]</ins></p></li>
<li><p>(3.3.2) &mdash; <ins>Otherwise, let <code>C</code> denote the type
<code>common_type_t&lt;D1, D2&gt;</code>.</ins></p></li>
</ol>
<p><ins> In either case, if there is such a type <code>C</code>,
the member typedef <code>type</code> shall denote <code>C</code>.
Otherwise, there shall be no member <code>type</code>.</ins></p>
</li>
<li><p>(3.4) &mdash; If <tt>sizeof...(T)</tt> is greater than <del>one</del><ins>two</ins>, let <tt>T1</tt>, <tt>T2</tt>, and 
<tt>R</tt>, 
respectively, denote the first, second, and (pack of) remaining types comprising <tt>T</tt>. 
<del>[<i>Note:</i> <tt>sizeof...(R)</tt> may be zero. &mdash; <i>end note</i>] Let <tt>C</tt> denote the
type, if any, of an unevaluated conditional expression (5.16 [expr.cond]) whose first operand is an arbitrary value
of type <tt>bool</tt>, whose second operand is an xvalue of type <tt>T1</tt>, and whose third operand is 
an xvalue of type <tt>T2</tt>.</del> <ins>Let <code>C</code> denote <code>common_type_t&lt;T1, T2&gt;</code>.</ins> 
If there is such a type <tt>C</tt>, the member typedef <tt>type</tt> 
shall denote the same type, if any, as <tt>common_type_t&lt;C, R...&gt;</tt>. Otherwise, there shall 
be no member <tt>type</tt>.</p></li>
</ol>
<p>
<ins>-?- Note B: A program may specialize the <code>common_type</code> trait for two <i>cv</i>-unqualified 
non-reference types if at least one of them is a user-defined type. [<i>Note:</i> Such specializations are
needed when only explicit conversions are desired among the template
arguments. &mdash; <i>end note</i>] Such a specialization need not have a member named <code>type</code>,
but if it does, that member shall be a <i>typedef-name</i> for a <i>cv</i>-unqualified non-reference type
that need not otherwise meet the specification set forth in Note A, above.</ins>
<p/>
-4- [<i>Example:</i> Given these definitions: [&hellip;]
</p>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="2764" href="#2764">2764.</a> Are <code>&lt;cstddint&gt;</code> macros optional?</h3>
<p><b>Section:</b> 18.4.1 [cstdint.syn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Thomas Koeppe <b>Opened:</b> 2016-08-10 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#cstdint.syn">issues</a> in [cstdint.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Are the macros <code>INT[8, 16, 32, 64]_MAX</code> etc. optional?
<p/>
The entire <code>&lt;cstddint&gt;</code> header is specified to have all types and macros "defined the same as in C". 
But C is also unclear about this: the fixed-width types like <code>int32_t</code> are optional in C and in C++. 
The corresponding macro <code>INT32_MAX</code> is defined in terms of an expression of the same type as the 
"corresponding type converted according to the integral promotions". But if the "corresponding type" does not exist, 
then surely the macro too cannot exist? It seems that the macros should also be optional.
<p/>
Suggested resolution: See e.g. <a href="https://github.com/cplusplus/draft/pull/843">here</a>, or equivalent wording 
to the effect that the macros <code>INT*_MAX</code> etc are defined if and only if the corresponding integer type is 
defined.
<p/>
(Note that the types <code>intptr_t</code> and <code>uintptr_t</code> are also optional.)
</p>

<p><i>[2016-08-11, Richard comments]</i></p>

<p>
C allows other values for <code>N</code> in addition to 8, 16, 32, 64, whereas it appears that C++ does not. 
Is the difference intentional?
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>We need to answer Richard's question before making this ready</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2765" href="#2765">2765.</a> Did LWG 1123 go too far?</h3>
<p><b>Section:</b> 27.5.3.1.6 [ios::Init] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-08-13 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all other</b> <a href="lwg-index.html#ios::Init">issues</a> in [ios::Init].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="lwg-defects.html#1123">1123</a> fixed a bug where users of <tt>&lt;iostream&gt;</tt> were not guaranteed to have their streams flushed 
on program shutdown. However, it also added this rule:
</p>
<blockquote><p>
"Similarly, the entire program shall behave as if there were at least one instance of <tt>ios_base::Init</tt> with static 
lifetime."
</p></blockquote>
<p>
This seems pointless: it only affects the behavior of programs that never include <tt>&lt;iostream&gt;</tt> (because programs 
that do include it are already guaranteed at least one such instance), and those programs do not need an implicit flush 
because they cannot have written to the relevant streams.
<p/>
It's also actively harmful, because it requires the iostreams component to be linked into programs that do not use it, 
apparently even including freestanding implementations! Fortunately, C++ implementations appear to uniformly ignore this rule.
<p/>
Can it be removed?
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>P0; move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 27.5.3.1.6 [ios::Init] p3 as indicated:</p>
<blockquote><p>
-3- The objects are constructed and the associations are established at some time prior to or during the first
time an object of class <tt>ios_base::Init</tt> is constructed, and in any case before the body of <tt>main</tt> begins
execution.(footnote 293) The objects are not destroyed during program execution.(footnote 294) The results of including 
<tt>&lt;iostream&gt;</tt> in a translation unit shall be as if <tt>&lt;iostream&gt;</tt> defined an instance of 
<tt>ios_base::Init</tt> with static storage duration. <del>Similarly, the entire program shall behave as if there were at 
least one instance of <tt>ios_base::Init</tt> with static storage duration.</del>
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2766" href="#2766">2766.</a> Swapping non-swappable types</h3>
<p><b>Section:</b> 20.4.3 [pairs.spec], 20.5.2.10 [tuple.special], 20.6.9 [optional.specalg], 20.7.9 [variant.specalg], 20.11.1.5 [unique.ptr.special], 23.3.7.3 [array.special], 23.6.4.5 [queue.special], 23.6.5.4 [priqueue.special], 23.6.6.5 [stack.special] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Agust&iacute;n K-ballo Berg&eacute; <b>Opened:</b> 2016-08-15 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>3
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Related: <a href="lwg-active.html#2748">2748</a> swappable traits for optionals, <a href="lwg-active.html#2749">2749</a> swappable traits for variants.
</p>
<p>
The adoption of <a href="http://wg21.link/p0185r1">P0185R1</a> "Adding [nothrow-]swappable traits" makes certain 
non-swappable types indirectly swappable. Consider a type defined as follows:
</p>
<blockquote><pre>
struct non_swappable {
  friend void swap(non_swappable&amp;, non_swappable&amp;) = delete;
};

non_swappable ns1, ns2;
using std::swap;
swap(ns1, ns2); // ill-formed

static_assert(std::is_swappable_v&lt;non_swappable&gt; == false); // holds
</pre></blockquote>
<p>
Lvalues of type <tt>non_swappable</tt> are not swappable, as defined by 17.6.3.2 [swappable.requirements], 
overload resolution selects the deleted function. Consistently, <tt>is_swappable_v&lt;non_swappable&gt;</tt> yields 
false. It should be noted that since <tt>non_swappable</tt> is move constructible and move assignable, a qualified 
call to <tt>std::swap</tt> would be well-formed, even under P0185. Now consider the following snippet:
</p>
<blockquote><pre>
std::tuple&lt;non_swappable&gt; tns1, tns2;
using std::swap;
swap(tns1, tns2); // previously ill-formed, now well-formed

static_assert(std::is_swappable_v&lt;std::tuple&lt;non_swappable&gt;&gt; == false); // fires
</pre></blockquote>
<p>
Before P0185, this snippet would violate the implicit requirement of specialized swap for tuples that each tuple 
element be swappable. After P0185, this specialized swap overload for tuples would be SFINAEd away, resulting 
in overload resolution selecting the base swap overload, and performing the exchange via move construction and 
move assignment of tuples.
<p/>
This issue affects all of <tt>pair</tt>, <tt>tuple</tt>, <tt>unique_ptr</tt>, <tt>array</tt>, <tt>queue</tt>, 
<tt>priority_queue</tt>, <tt>stack</tt>, and should eventually also apply to <tt>optional</tt> and <tt>variant</tt>.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606, except when otherwise noted.</p>

<ol>
<li><p>Modify 20.4.3 [pairs.spec] as indicated:</p>
<blockquote>
<pre>
template&lt;class T1, class T2&gt; void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y)
  noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-7- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
<p/>
-8- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as 
deleted</ins> unless <tt>is_swappable_v&lt;T1&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;T2&gt;</tt> 
is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.5.2.10 [tuple.special] as indicated:</p>
<blockquote>
<pre>
template &lt;class... Types&gt;
  void swap(tuple&lt;Types...&gt;&amp; x, tuple&lt;Types...&gt;&amp; y) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;<tt>T<sub>i</sub></tt>&gt;</tt> is <tt>true</tt> for all <tt><i>i</i></tt>, where 
<tt>0 &lt;= <i>i</i></tt> and <tt><i>i</i> &lt; sizeof...(Types)</tt>. The expression inside <tt>noexcept</tt> 
is equivalent to:
</p>
<blockquote><pre>
noexcept(x.swap(y))
</pre></blockquote>
<p>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.11.1.5 [unique.ptr.special] as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;D&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> Calls <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.3.7.3 [array.special] as indicated:</p>
<blockquote>
<pre>
template &lt;class T, size_t N&gt;
  void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>N == 0</tt> or <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.6.4.5 [queue.special] as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container&gt;
  void swap(queue&lt;T, Container&gt;&amp; x, queue&lt;T, Container&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;Container&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.6.5.4 [priqueue.special] as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container, class Compare&gt;
  void swap(priority_queue&lt;T, Container, Compare&gt;&amp; x,
            priority_queue&lt;T, Container, Compare&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <tt>Remarks:</tt> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;Container&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;Compare&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 23.6.6.5 [stack.special] as indicated:</p>
<blockquote>
<pre>
template &lt;class T, class Container&gt;
  void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_swappable_v&lt;Container&gt;</tt> is <tt>true</tt>.
<p/>
-2- <i>Effects:</i> As if by <tt>x.swap(y)</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.6.9 [optional.specalg] as indicated:</p>
<blockquote class="note">
<p>
This change should be performed if and only if LWG <a href="lwg-active.html#2748">2748</a> is accepted and is against the wording of <a href="lwg-active.html#2748">2748</a>:
</p>
</blockquote>
<blockquote>
<pre>
template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; x, optional&lt;T&gt;&amp; y) noexcept(noexcept(x.swap(y)));
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Calls <tt>x.swap(y)</tt>.
<p/>
-2- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_move_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_swappable_v&lt;T&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Modify 20.7.9 [variant.specalg] as indicated:</p>
<blockquote class="note">
<p>
This change should be performed if and only if LWG <a href="lwg-active.html#2749">2749</a> is accepted and is against the wording of <a href="lwg-active.html#2749">2749</a>:
</p>
</blockquote>
<blockquote>
<pre>
template &lt;class... Types&gt; void swap(variant&lt;Types...&gt;&amp; v, variant&lt;Types...&gt;&amp; w) noexcept(<i>see below</i>);
</pre>
<blockquote>
<p>
-1- <i>Effects:</i> Equivalent to <tt>v.swap(w)</tt>.
<p/>
-2- <i>Remarks:</i> This function shall <del>not participate in overload resolution</del><ins>be defined as deleted</ins> 
unless <tt>is_move_constructible_v&lt;<i>T<sub>i</sub></i>&gt; &amp;&amp; is_swappable_v&lt;<i>T<sub>i</sub></i>&gt;</tt> 
is <tt>true</tt> for all <tt><i>i</i></tt>. The expression inside <tt>noexcept</tt> is equivalent to <tt>noexcept(v.swap(w))</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2767" href="#2767">2767.</a> <tt>not_fn <i>call_wrapper</i></tt> can form invalid types</h3>
<p><b>Section:</b> 20.14.9 [func.not_fn] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2016-08-19 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definition of the <tt><i>call_wrapper</i></tt> type in the C++17 CD means this
fails to compile:
</p>
<blockquote><pre>
#include &lt;functional&gt;

struct abc { virtual void f() const = 0; };
struct derived : abc{ void f() const { } };
struct F { bool operator()(abc&amp;) { return false; } };
bool b = std::not_fn(F{})(derived{});
</pre></blockquote>
<p>
The problem is that the return types use <tt>result_of_t&lt;F(abc)&gt;</tt> and
<tt>F(abc)</tt> is not a valid function type, because it takes an abstract
class by value.
<p/>
The return types should use <tt>result_of_t&lt;F(Args<ins>&amp;&amp;</ins>...)&gt;</tt> instead.
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>P0; move to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.14.9 [func.not_fn], class <tt><i>call_wrapper</i></tt> synopsis, as indicated:</p>
<blockquote>
<pre>
class <i>call_wrapper</i>
{
  [&hellip;]
  template&lt;class... Args&gt;
    auto operator()(Args&amp;&amp;...) &amp;
      -&gt; decltype(!declval&lt;result_of_t&lt;FD&amp;(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
  template&lt;class... Args&gt;
    auto operator()(Args&amp;&amp;...) const&amp;
      -&gt; decltype(!declval&lt;result_of_t&lt;FD const&amp;(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
  template&lt;class... Args&gt;
    auto operator()(Args&amp;&amp;...) &amp;&amp;
      -&gt; decltype(!declval&lt;result_of_t&lt;FD(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
  template&lt;class... Args&gt;
    auto operator()(Args&amp;&amp;...) const&amp;&amp;
      -&gt; decltype(!declval&lt;result_of_t&lt;FD const(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());  
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Modify the prototype declarations of 20.14.9 [func.not_fn] as indicated:</p>
<blockquote>
<pre>
template&lt;class... Args&gt;
  auto operator()(Args&amp;&amp;... args) &amp;
    -&gt; decltype(!declval&lt;result_of_t&lt;FD&amp;(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
template&lt;class... Args&gt;
  auto operator()(Args&amp;&amp;... args) const&amp;
    -&gt; decltype(!declval&lt;result_of_t&lt;FD const&amp;(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
<pre>
template&lt;class... Args&gt;
  auto operator()(Args&amp;&amp;... args) &amp;&amp;
    -&gt; decltype(!declval&lt;result_of_t&lt;FD(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
template&lt;class... Args&gt;
  auto operator()(Args&amp;&amp;... args) const&amp;&amp;
    -&gt; decltype(!declval&lt;result_of_t&lt;FD const(Args<ins>&amp;&amp;</ins>...)&gt;&gt;());
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2768" href="#2768">2768.</a> <tt>any_cast</tt> and move semantics</h3>
<p><b>Section:</b> 20.8.4 [any.nonmembers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-08-27 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.nonmembers">active issues</a> in [any.nonmembers].</p>
<p><b>View all other</b> <a href="lwg-index.html#any.nonmembers">issues</a> in [any.nonmembers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
LWG <a href="lwg-defects.html#2509">2509</a> made two changes to the specification of <tt>any</tt> in v2 of the library fundamentals TS:
</p>

<ol>
<li>It altered the effects of the <tt>any_cast(any&amp;&amp;)</tt> overload to enable moving the value out of the <tt>any</tt> 
object and/or obtaining an rvalue reference to the contained value.</li>

<li>It made changes to support pathological copyable-but-not-movable contained values, which is madness.</li>
</ol>

<p>
Change 1 has very desirable effects; I propose that we apply the sane part of LWG <a href="lwg-defects.html#2509">2509</a> to <tt>any</tt> 
in the C++17 WP, for all of the reasons cited in the discussion of LWG <a href="lwg-defects.html#2509">2509</a>.
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>P0; move to Tentatively Ready</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 20.8.4 [any.nonmembers] p5, edit as follows:</p>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
<blockquote>
<p>
-4- <i>Requires</i>: <tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or <tt>is_copy_constructible_v&lt;ValueType&gt;</tt> 
is <tt>true</tt>. Otherwise the program is ill-formed. 
</p>
<p>
-5- <i>Returns</i>: For the first form, <tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. 
For the second <del>and third</del> form<del>s</del>, <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>. 
<ins>For the third form, <tt>std::forward&lt;ValueType&gt;(*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand))</tt>.</ins>
</p>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>
</ol>

</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
Resolved by the wording provided by LWG <a href="lwg-active.html#2769">2769</a>.
</p>






<hr>
<h3><a name="2769" href="#2769">2769.</a> Redundant <tt>const</tt> in the return type of <tt>any_cast(const any&amp;)</tt></h3>
<p><b>Section:</b> 20.8.4 [any.nonmembers] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Casey Carter <b>Opened:</b> 2016-09-02 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#any.nonmembers">active issues</a> in [any.nonmembers].</p>
<p><b>View all other</b> <a href="lwg-index.html#any.nonmembers">issues</a> in [any.nonmembers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The overload of <tt>any_cast</tt> that accepts a reference to constant <tt>any</tt>:
</p>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
</pre>
</blockquote>
<p>
is specified to return <tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt> in [any.nonmembers]/5. This calls the pointer-to-constant overload of <tt>any_cast</tt>:
</p>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  const ValueType* any_cast(const any* operand) noexcept;
</pre>
</blockquote>
<p>
which is specified as:
</p>
<blockquote>
<i>Returns:</i> If <tt>operand != nullptr &amp;&amp; operand-&gt;type() == typeid(ValueType)</tt>, a pointer to the object contained by <tt>operand</tt>; otherwise, <tt>nullptr</tt>.
</blockquote>
<p>
Since <tt>typeid(T) == typeid(const T)</tt> for all types <tt>T</tt>, <tt>any_cast&lt;add_const_t&lt;T&gt;&gt;(&amp;operand)</tt> is equivalent to <tt>any_cast&lt;T&gt;(&amp;operand)</tt> for all types <tt>T</tt> when operand is a constant lvalue <tt>any</tt>. 
The <tt>add_const_t</tt> in the return specification of the first overload above is therefore redundant.
</p>

<p><i>[2016-09-09 Issues Resolution Telecon]</i></p>

<p>P0; move to Tentatively Ready</p>
<p>Casey will provide combined wording for this and <a href="lwg-active.html#2768">2768</a>, since they modify the same paragraph.</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.4 [any.nonmembers] as indicated:</p>
<blockquote>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
</blockquote>
<p>
-4- <i>Requires:</i> <tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or 
<tt>is_copy_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt>. Otherwise the program is ill-formed.
<p/>
-5- <i>Returns:</i> <del>For the first form, 
<tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. 
For the second and third forms,</del> <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>.
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-09-09 Casey improves wording as determined by telecon]</i></p>

<p>
The presented resolution is intended as the common wording for both LWG <a href="lwg-active.html#2768">2768</a> and LWG <a href="lwg-active.html#2769">2769</a>.
</p>

<p><strong>Previous resolution [SUPERSEDED]:</strong></p>
<blockquote class="note">
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.4 [any.nonmembers] as indicated:</p>
<blockquote>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
</blockquote>
<p>
-4- <i>Requires:</i> <tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or 
<tt>is_copy_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt>. Otherwise the program is ill-formed.
<p/>
-5- <i>Returns:</i> For the first <del>form, 
<tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. 
For the</del> <ins>and</ins> second <del>and third</del> form<del>s</del>, 
<tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>. <ins>For the third form, 
<tt>std::forward&lt;ValueType&gt;(*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand))</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>
</blockquote>

<p><i>[2016-10-05, Tomasz and Casey reopen and improve the wording]</i></p>

<p>
The constraints placed on the non-pointer <tt>any_cast</tt> overloads are neither necessary nor sufficient to 
guarantee that the specified effects are well-formed. The current PR for LWG <a href="lwg-active.html#2769">2769</a> also makes it 
possible to retrieve a dangling lvalue reference to a temporary any with e.g. <tt>any_cast&lt;int&amp;&gt;(any{42})</tt>, 
which should be forbidden.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.8.4 [any.nonmembers] as indicated:</p>
<blockquote>
<blockquote>
<pre>
template&lt;class ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;class ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);
</pre>
</blockquote>
<p>
-4- <i>Requires:</i> <del><tt>is_reference_v&lt;ValueType&gt;</tt> is <tt>true</tt> or 
<tt>is_copy_constructible_v&lt;ValueType&gt;</tt> is <tt>true</tt>.</del><ins>For the first 
overload, <tt>is_constructible_v&lt;ValueType, const remove_reference_t&lt;remove_cv_t&lt;ValueType&gt;&gt;&amp;&gt;</tt> 
is <tt>true</tt>. For the second overload, <tt>is_constructible_v&lt;ValueType, remove_reference_t&lt;remove_cv_t&lt;ValueType&gt;&gt;&amp;&gt;</tt> is <tt>true</tt>. For the third overload, <tt>is_constructible_v&lt;ValueType, 
remove_reference_t&lt;remove_cv_t&lt;ValueType&gt;&gt;&gt;</tt> is <tt>true</tt>.</ins> Otherwise the program is ill-formed.
<p/>
-5- <i>Returns:</i> <del>For the first form, 
<tt>*any_cast&lt;add_const_t&lt;remove_reference_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)</tt>. For the second and third 
forms, <tt>*any_cast&lt;remove_reference_t&lt;ValueType&gt;&gt;(&amp;operand)</tt>.</del><ins>For the first and second 
overload, <tt>static_cast&lt;ValueType&gt;(*any_cast&lt;remove_reference_t&lt;remove_cv_t&lt;ValueType&gt;&gt;&gt;(&amp;operand))</tt>. For the third overload, <tt>static_cast&lt;ValueType&gt;(std::move(*any_cast&lt;remove_reference_t&lt;remove_cv_t&lt;ValueType&gt;&gt;&gt;(&amp;operand)))</tt>.</ins>
<p/>
[&hellip;]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2770" href="#2770">2770.</a> <tt>tuple_size&lt;const T&gt;</tt> specialization is not SFINAE compatible and breaks decomposition declarations</h3>
<p><b>Section:</b> 20.5.2.6 [tuple.helper] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2016-08-15 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>1
</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider:
</p>
<blockquote><pre>
#include &lt;utility&gt;

struct X { int a, b; };
const auto [x, y] = X();
</pre></blockquote>
<p>
This is ill-formed: it triggers the instantiation of <tt>std::tuple_size&lt;const X&gt;</tt>, which hits a hard error 
because it tries to use <tt>tuple_size&lt;X&gt;::value</tt>, which does not exist. The code compiles if 
<tt>&lt;utility&gt;</tt> (or another header providing <tt>tuple_size</tt>) is not included.
<p/>
It seems that we either need a different strategy for decomposition declarations, or we need to change the library to 
make the <tt>tuple_size</tt> partial specializations for <i>cv</i>-qualifiers SFINAE-compatible.
<p/>
The latter seems like the better option to me, and like a good idea regardless of decomposition declarations.
</p>

<p><i>[2016-09-05, Daniel comments]</i></p>

<p>
This is partially related to LWG <a href="lwg-active.html#2446">2446</a>.
</p>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>Geoffrey to provide wording</p>

<p><i>[2016-09-14 Geoffrey provides wording]</i></p>


<p><i>[2016-10 Telecom]</i></p>

<p>Alisdair to add his concerns here before Issaquah. Revisit then. Status to 'Open'</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Edit 20.5.2.6 [tuple.helper] as follows:</p>
<blockquote>
<pre>
template &lt;class T&gt; class tuple_size&lt;const T&gt;;
template &lt;class T&gt; class tuple_size&lt;volatile T&gt;;
template &lt;class T&gt; class tuple_size&lt;const volatile T&gt;;
</pre>
<blockquote>
<p>
-4- Let <tt><i>TS</i></tt> denote <tt>tuple_size&lt;T&gt;</tt> of the <i>cv</i>-unqualified type <tt>T</tt>. 
<ins>If the expression <tt><i>TS</i>::value</tt> is well-formed when treated as an unevaluated operand, 
t</ins><del>T</del>hen each of the three templates shall meet the <tt>UnaryTypeTrait</tt> requirements (20.15.1) 
with a <tt>BaseCharacteristic</tt> of
</p>
<blockquote>
<pre>
integral_constant&lt;size_t, <i>TS</i>::value&gt;
</pre>
</blockquote>
<p>
<ins>Access checking is performed as if in a context unrelated to <tt><i>TS</i></tt> and <tt>T</tt>. Only the 
validity of the immediate context of the expression is considered. [<i>Note:</i> The compilation of the expression 
can result in side effects such as the instantiation of class template specializations and function template 
specializations, the generation of implicitly-defined functions, and so on. Such side effects are not in the 
"immediate context" and can result in the program being ill-formed. &mdash; <i>end note</i>]</ins>
<p/>
-5- In addition to being available via inclusion of the <tt>&lt;tuple&gt;</tt> header, the three templates are available
when either of the headers <tt>&lt;array&gt;</tt> or <tt>&lt;utility&gt;</tt> are included.
</p>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2771" href="#2771">2771.</a> Broken <i>Effects</i> of some <tt>basic_string::compare</tt> functions in terms of <tt>basic_string_view</tt></h3>
<p><b>Section:</b> 21.3.1.7.9 [string::compare] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2016-09-05 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>1
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Some <tt>basic_string::compare</tt> functions are specified in terms of a non-existing <tt>basic_string_view</tt>
constructor, namely 21.3.1.7.9 [string::compare] p3,
</p>
<blockquote><pre>
return basic_string_view&lt;charT, traits&gt;(this.data(), pos1, n1).compare(sv);
</pre></blockquote>
<p>
and 21.3.1.7.9 [string::compare] p4:
</p>
<blockquote><pre>
return basic_string_view&lt;charT, traits&gt;(this.data(), pos1, n1).compare(sv, pos2, n2);
</pre></blockquote>
<p>
because there doesn't exist a <tt>basic_string_view</tt> constructor with three arguments.
<p/>
Albeit this can be easily fixed by a proper combination of the existing constructor
</p>
<blockquote><pre>
constexpr basic_string_view(const charT* str, size_type len);
</pre></blockquote>
<p>
with the additional member function
</p>
<blockquote><pre>
constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
</pre></blockquote>
<p>
it should be decided whether adding the seemingly natural constructor
</p>
<blockquote><pre>
constexpr basic_string_view(const charT* str, size_type pos, size_type n);
</pre></blockquote>
<p>
could simplify matters. A counter argument for this addition might be, that <tt>basic_string</tt>
doesn't provide this constructor either.
<p/>
Another problem is related to the specification of 21.3.1.7.9 [string::compare] p4, which attempts to
call a non-existing <tt>basic_string_view::compare</tt> overload that would match the signature:
</p>
<blockquote><pre>
constexpr int compare(basic_string_view str, size_type pos1, size_type n1) const;
</pre></blockquote>

<p><i>[2016-09-09 Issues Resolution Telecom]</i></p>

<p>Marshall to investigate using P/R vs. adding the missing constructor.</p>

<p><i>[2016-10 Issues Resolution Telecom]</i></p>

<p>Marshall reports that P/R is better. Status to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording changes below are for the same part of the standard as <a href="lwg-active.html#2758">2758</a>. 
However, they do not conflict. This one changes the "Effects" of the routine, while the other changes the definition.
&mdash; <i>end drafting note</i>]
</p>
</blockquote>

<ol>
<li><p>Change 21.3.1.7.9 [string::compare] as indicated:</p>

<blockquote>
<pre>
int compare(size_type pos1, size_type n1,
            basic_string_view&lt;charT, traits&gt; sv) const;
</pre>
<blockquote>
<p>
-3- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
return basic_string_view&lt;charT, traits&gt;(<del>this.</del>data(), <ins>size()).substr(</ins>pos1, n1).compare(sv);
</pre>
</blockquote>
</blockquote>
<pre>
int compare(size_type pos1, size_type n1,
            basic_string_view&lt;charT, traits&gt; sv,
            size_type pos2, size_type n2 = npos) const;
</pre>
<blockquote>
<p>
-4- <i>Effects:</i> Equivalent to:
</p>
<blockquote>
<pre>
return basic_string_view&lt;charT, traits&gt;(<del>this.</del>data(), <ins>size()).substr(</ins>pos1, n1).compare(sv<del>,</del><ins>.substr(</ins>pos2, n2<ins>)</ins>);
</pre>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2772" href="#2772">2772.</a> Inconsistency in the <tt>insert(node)</tt> interface</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.2.5 [unord.req], 23.4.2 [associative.map.syn], 23.5.2 [unord.map.syn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Tomasz Kami&nacute;ski <b>Opened:</b> 2016-09-06 <b>Last modified:</b> 2016-10-06</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In C++17 the interface of the unique <tt>map</tt> was extended to include following function:
</p>
<blockquote><pre>
pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; k, Args&amp;&amp;... args); //and move version
iterator try_emplace(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args); //and move version
iterator insert(const_iterator hint, node_type&amp;&amp; nh)
insert_return_type insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
All of the functions share a common property, that they are performing basically no-operation in case when element 
with given key (part of node) is already stored in the map. However there is major difference in their interface. 
The first three functions:
</p>
<blockquote><pre>
pair&lt;iterator, bool&gt; try_emplace(key_type&amp;&amp; k, Args&amp;&amp;... args); //and copy version
iterator try_emplace(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args); //and copy version
iterator insert(const_iterator hint, node_type&amp;&amp; nh)
</pre></blockquote>
<p>
are guaranteeing that the value of the arguments (<tt>k, nh, args...</tt>) will not be changed if the map already 
contains a key with given value, so the programmer is free to reuse it for their own purpose.
<p/>
However, the interface of the fourth function is a bit different:
</p>
<blockquote><pre>
insert_return_type insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
The <tt>insert_return_type</tt> is an unspecified type that contains:
</p>
<blockquote><pre>
bool inserted;
X::iterator position;
X::node_type node;
</pre></blockquote>
<p>
As  we can see, the <tt>insert</tt> function is returning a <tt>node</tt>. This difference is actually
misleading, as the programmer may start to wonder, why the function returns a <tt>node</tt> handle, 
instead of being guaranteed that the argument will not be modified (as other functions do). Most reasonable 
explanation is that, this function actually return a handle to a different <tt>node</tt>, that one passed 
as the argument, i.e. this function replaces an existing node with the <tt>nh</tt> argument and returns the
handle to the old <tt>node</tt>. However, this function actually has the same semantics as the other <tt>insert</tt> 
function and returns a <tt>node</tt> that was passed as argument.
<p/>
In addition, this design makes the interface of the <tt>insert</tt> function for the map inconsistent. Value 
inserting functions are returning <tt>pair&lt;iterator, bool&gt;</tt> while node inserting function is 
returning an unspecified type with guaranteed set of members.
<p/>
The only potential benefit of this signature is that it could potentially allow programmer to use 
decomposition declaration, so instead of:
</p>
<blockquote><pre>
auto nh = node_provider();
if (map.insert(std::move(nh)).second)
  handle_node_in_other_way(std::move(nh));
</pre></blockquote>
<p>
The user would be able to write:
</p>
<blockquote><pre>
if (auto [it, ins, nh] = map.insert(node_provider); ins)
   handle_node_in_other_way(std::move(nh));
</pre></blockquote>
<p>
However, the <tt>insert_return_type</tt> is not currently required to work with decomposition declaration, so 
this is only "potential" benefit that could be added in future.
<p/>
Furthermore, this change is preventing a user to use structured binding with combination with <tt>insert</tt> 
in generic code:
</p>
<blockquote><pre>
template&lt;typename UniqMap, typename Elem&gt;
void log_duplicate_insertion(UniqMap&amp; map, Elem&amp;&amp; elem)
{
  if (auto [it, ins] = map.insert(std::forward&lt;Elem&gt;(elem)); !ins)
    std::cout &lt;&lt; "attempt to insert duplicate for " &lt;&lt; *it;
}
</pre></blockquote>
<p>
Currently, <tt>log_duplicate_insertion</tt> will not work with <tt>node_handle_type</tt>.
<p/>
So, I am proposing to change the interface of the <tt>insert(node_handle)</tt> function for associative containers 
with unique keys, to be consistent with the other <tt>insert</tt> operation and <tt>try_emplace</tt> function. I.e. 
change the signature to:
</p>
<blockquote><pre>
std::pair&lt;iterator, bool&gt; insert(node_type&amp;&amp; nh);
</pre></blockquote>
<p>
and provide the guarantee that <tt>nh</tt> will be unchanged if an element was not inserted.
</p>

<p><i>[2016-09-06, Howard comments]</i></p>

<p>
This is related to LWG <a href="lwg-active.html#839">839</a>.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2773" href="#2773">2773.</a> Making <tt>std::ignore constexpr</tt></h3>
<p><b>Section:</b> 20.5.1 [tuple.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Vincent Reverdy <b>Opened:</b> 2016-09-10 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#tuple.general">active issues</a> in [tuple.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.general">issues</a> in [tuple.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently <tt>std::ignore</tt> is not specified <tt>constexpr</tt> according to the C++ draft N4606 in the paragraph 
20.5.1 [tuple.general]. It prevents some use in <tt>constexpr</tt> context: for example declaring a 
<tt>constexpr</tt> variable equals to the result of a function to which <tt>std::ignore</tt> has been passed as a parameter:
</p>
<blockquote><pre>
constexpr int i = f(std::ignore); // Won't compile
</pre></blockquote>
<p>
If there is no fundamental reason preventing <tt>std::ignore</tt> to be <tt>constexpr</tt>, then we propose to declare 
it as <tt>constexpr</tt> instead of as <tt>const</tt>.
</p>

<p><i>[Issues processing Telecom 2016-10-7]</i></p>

<p>P0; set to Tentatively Ready</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N4606.</p>

<ol>
<li><p>Modify 20.5.1 [tuple.general] as indicated:</p>
<blockquote>
<pre>
<i>// 20.5.2.4, tuple creation functions:</i>
<del>const</del><ins>constexpr</ins> <i>unspecified</i> ignore;
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2774" href="#2774">2774.</a> <tt>std::function</tt> construction vs assignment</h3>
<p><b>Section:</b> 20.14.12.2.1 [func.wrap.func.con] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Barry Revzin <b>Opened:</b> 2016-09-14 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>3
</p>
<p><b>View all other</b> <a href="lwg-index.html#func.wrap.func.con">issues</a> in [func.wrap.func.con].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think there's a minor defect in the <tt>std::function</tt> interface. The constructor template is:
</p>
<blockquote><pre>
template &lt;class F&gt; function(F f);
</pre></blockquote>
<p>
while the assignment operator template is 
</p>
<blockquote><pre>
template &lt;class F&gt; function&amp; operator=(F&amp;&amp; f);
</pre></blockquote>
<p>
The latter came about as a result of LWG <a href="lwg-defects.html#1288">1288</a>, but that one was dealing with a specific issue that 
wouldn't have affected the constructor. I think the constructor should also take <tt>f</tt> by forwarding reference, 
this saves a move in the lvalue/xvalue cases and is also just generally more consistent. Should just make sure 
that it's stored as <tt>std::decay_t&lt;F&gt;</tt> instead of <tt>F</tt>. 
<p/>
Is there any reason to favor a by-value constructor over a forwarding-reference constructor?
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2776" href="#2776">2776.</a> <tt>shared_ptr unique()</tt> and <tt>use_count()</tt></h3>
<p><b>Section:</b> 20.11.2.2.5 [util.smartptr.shared.obs] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2016-09-22 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#util.smartptr.shared.obs">active issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.shared.obs">issues</a> in [util.smartptr.shared.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The removal of the "debug only" restriction for <tt>use_count()</tt> and <tt>unique()</tt> in <tt>shared_ptr</tt>  
by LWG <a href="lwg-defects.html#2434">2434</a> introduced a bug. In order for <tt>unique()</tt> to produce a useful and reliable value, 
it needs a synchronize clause to ensure that prior accesses through another reference are visible to the successful 
caller of <tt>unique()</tt>. Many current implementations use a relaxed load, and do not provide this guarantee, 
since it's not stated in the standard. For debug/hint usage that was OK. Without it the specification is unclear 
and probably misleading.
<p/>
I would vote for making <tt>unique()</tt> use <tt>memory_order_acquire</tt>, and specifying that reference count 
decrement operations synchronize with <tt>unique()</tt>. That still doesn't give us sequential consistency by default, 
like we're supposed to have. But the violations seem sufficiently obscure that I think it's OK. All uses that 
anybody should care about will work correctly, and the bad uses are clearly bad. I agree with Peter that this 
version of <tt>unique()</tt> may be quite useful.
<p/>
I would prefer to specify <tt>use_count()</tt> as only providing an unreliable hint of the actual count (another way 
of saying debug only). Or deprecate it, as JF suggested. We can't make <tt>use_count()</tt> reliable without adding 
substantially more fencing. We really don't want someone waiting for <tt>use_count() == 2</tt> to determine that 
another thread got that far. And unfortunately, I don't think we currently say anything to make it clear that's a 
mistake.
<p/>
This would imply that <tt>use_count()</tt> normally uses <tt>memory_order_relaxed</tt>, and <tt>unique</tt> is 
neither specified nor implemented in terms of <tt>use_count()</tt>.
</p>


<p><b>Proposed resolution:</b></p>






<hr>
<h3><a name="2777" href="#2777">2777.</a> <tt>basic_string_view::copy</tt> should use <tt>char_traits::copy</tt></h3>
<p><b>Section:</b> 21.4.2.6 [string.view.ops], 21.3.1.6.7 [string::copy] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-09-27 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>0
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>basic_string_view::copy</tt> is inconsistent with <tt>basic_string::copy</tt>, in that the
former uses <tt>copy_n</tt> and the latter uses <tt>traits::copy</tt>. We should have this
handling be consistent. 
<p/>
Moreover, the <tt>basic_string::copy</tt> description is excessively roundabout due to
copy-on-write era wording.
</p>

<p><i>[Issues processing Telecom 2016-10-7]</i></p>

<p>P0; set to Tentatively Ready</p>
<p>Removed "Note to project editor", since the issue there has been fixed in the current draft.</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>Change 21.3.1.6.7 [string::copy] as indicated:</p>

<blockquote>
<pre>
size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>

</blockquote>
<p>
<ins>-?- Let <tt>rlen</tt> be the smaller of <tt>n</tt> and <tt>size() - pos</tt>.</ins>
</p>
<p>
-2- <em>Throws: </em><tt>out_of_range</tt> if <tt>pos &gt; size()</tt>.
</p>
<p>
<ins>-?- <em>Requires:</em> <tt>[s, s + rlen)</tt> is a valid range.</ins>
</p>
<p>
-3- <em>Effects:</em> <del>Determines the effective length <tt>rlen</tt> of the string
to copy as the smaller of <tt>n</tt> and <tt>size() - pos</tt>. <tt>s</tt> shall
designate an array of at least <tt>rlen</tt> elements.</del><ins>Equivalent to: <tt>traits::copy(s, data() + pos, rlen)</tt>.
[<em>Note:</em> This does not terminate <tt>s</tt> with a null object. &mdash; <em>end note</em>]</ins>
</p>
<p><del>The function then replaces the string designated by <tt>s</tt> with a string of
length <tt>rlen</tt> whose elements are a copy of the string controlled by
<tt>*this</tt> beginning at position <tt>pos</tt>.</del>
</p>
<p>
<del>The function does not append a null object to the string designated by <tt>s</tt>.</del>
</p>
<p>
-4- <em>Returns: </em><tt>rlen</tt>.
</p>
</li>

<li><p>Change 21.4.2.6 [string.view.ops] as indicated:</p>

<blockquote>
<pre>
size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>

</blockquote>
<p>
-1- Let <tt>rlen</tt> be the smaller of <tt>n</tt> and <tt>size() - pos</tt>.
</p>
<p>
-2- <em>Throws:</em> <tt>out_of_range</tt> if <tt>pos &gt; size()</tt>.
</p>
<p>
-3- <em>Requires:</em> <tt>[s, s + rlen)</tt> is a valid range.
</p>
<p>
-4- <em>Effects:</em> Equivalent to: <del><tt>copy_n(begin() + pos, rlen, s)</tt></del><ins><tt>traits::copy(s, 
data() + pos, rlen)</tt></ins>
</p>
<p>
-5- <em>Returns:</em> <tt>rlen</tt>.
</p>
<p>
-6- <em>Complexity:</em> &#x1d4aa;(<tt>rlen</tt>).
</p>
</li>
</ol>






<hr>
<h3><a name="2778" href="#2778">2778.</a> <tt>basic_string_view</tt> is missing <tt>constexpr</tt></h3>
<p><b>Section:</b> 21.4 [string.view] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-09-30 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>0
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.view">active issues</a> in [string.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view">issues</a> in [string.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>basic_string_view</tt> was not updated to account for other library
machinery made <tt>constexpr</tt> in Oulu. Now that <tt>reverse_iterator</tt> is
<tt>constexpr</tt> there's no reason the reverse range functions can't be.
Also, now that we have C++14 relaxed <tt>constexpr</tt>, we can also take care
of the assignment operator and <tt>copy</tt>.
</p>

<p><i>[Issues processing Telecom 2016-10-7]</i></p>

<p>split off the copy into its' own issue <a href="lwg-active.html#2780">2780</a></p>
<p>P0; set what's left to Tentatively Ready</p>

<p>
<strong>Previous resolution [SUPERSEDED]:</strong>
</p>
<blockquote class="note">
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 21.4.2 [string.view.template], add <tt>constexpr</tt> to the assignment operator:</p>

<blockquote>
<pre>
<ins>constexpr </ins>basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;
</pre>
</blockquote>
</li>

<li><p>In 21.4.2 [string.view.template], add <tt>constexpr</tt> to the reverse range functions:</p>

<blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator rend() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crend() const noexcept;
</pre>
</blockquote>
</li>

<li><p>In 21.4.2.2 [string.view.iterators], add <tt>constexpr</tt> to the reverse range functions:</p>

<blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crbegin() const noexcept;
</pre>
<blockquote>
<p>
-6- <em>Returns:</em> <tt>const_reverse_iterator(end())</tt>
</p>
</blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rend() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crend() const noexcept;
</pre>
<blockquote>
<p>
-7- <em>Returns:</em> <tt>const_reverse_iterator(begin())</tt>
</p>
</blockquote>
</blockquote>
</li>

<li><p>In 21.4.2 [string.view.template], add <tt>constexpr</tt> to <tt>copy</tt>:</p>

<blockquote>
<pre>
<ins>constexpr </ins>size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>
</blockquote>
</li>

<li><p>In 21.4.2.6 [string.view.ops], add <tt>constexpr</tt> to <tt>copy</tt>:</p>

<blockquote>
<pre>
<ins>constexpr </ins>size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>
</blockquote>
</li>
</ol>
</blockquote>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 21.4.2 [string.view.template], add <tt>constexpr</tt> to the assignment operator:</p>

<blockquote>
<pre>
<ins>constexpr </ins>basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;
</pre>
</blockquote>
</li>

<li><p>In 21.4.2 [string.view.template], add <tt>constexpr</tt> to the reverse range functions:</p>

<blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator rend() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crend() const noexcept;
</pre>
</blockquote>
</li>

<li><p>In 21.4.2.2 [string.view.iterators], add <tt>constexpr</tt> to the reverse range functions:</p>

<blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rbegin() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crbegin() const noexcept;
</pre>
<blockquote>
<p>
-6- <em>Returns:</em> <tt>const_reverse_iterator(end())</tt>
</p>
</blockquote>
<pre>
<ins>constexpr </ins>const_reverse_iterator rend() const noexcept;
<ins>constexpr </ins>const_reverse_iterator crend() const noexcept;
</pre>
<blockquote>
<p>
-7- <em>Returns:</em> <tt>const_reverse_iterator(begin())</tt>
</p>
</blockquote>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2779" href="#2779">2779.</a> [networking.ts] Relax strict aliasing requirement for user-defined buffer sequence iterators</h3>
<p><b>Section:</b> 99 [networking.ts::buffer.reqmts.mutablebuffersequence] <b>Status:</b> <a href="lwg-active.html#LEWG">LEWG</a>
 <b>Submitter:</b> Vinnie Falco <b>Opened:</b> 2016-10-05 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>Not Prioritized
</p>
<p><b>View all issues with</b> <a href="lwg-status.html#LEWG">LEWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4588.pdf">N4588</a>
(Networking TS) 16.2 [buffer.reqmts] the requirements for buffer
sequence iterators indirectly adopt the C++ standard strict aliasing
requirements of <tt>ForwardIterator</tt>. From C++Std 24.2.5 [forward.iterators]
</p>

<blockquote>
<p>
6. If <tt>a</tt> and <tt>b</tt> are both dereferenceable, then <tt>a == b</tt> if and
only if <tt>*a</tt> and <tt>*b</tt> are bound to the same object.
</p>
</blockquote>

<p>
The strict aliasing requirement is widely recognized as a
defect. Ample rationale for fixing it is given in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4128.html">N4128</a>
3.3.7 (Ranges for the Standard Library).
</p>

<p>
Consider a user defined function <tt>trim</tt> which lazily adapts a
<tt>ConstBufferSequence</tt>, such that when iterating the buffers in the new
sequence, each buffer appears one byte shorter than in the underlying sequence:
</p>

<blockquote><pre>
#include &lt;boost/range/adaptor/transformed.hpp&gt;

struct trim
{
    using result_type = const_buffer;
    result_type operator()(const_buffer b)
    {
        return const_buffer{b.data(), b.size() - 1};
    }
};

template &lt;ConstBufferSequence&gt;
auto
trim(ConstBufferSequence const&amp; buffers)
{
    using namespace boost::adaptors;
    return buffers | transformed(trim{});
}
</pre></blockquote>

<p>
<tt>trim</tt> returns a <tt>BidirectionalRange</tt>, whose
<tt>const_iterator</tt> returns an rvalue when dereferenced. This breaks the
requirements of <tt>ForwardIterator</tt>. A solution that meets the strict
aliasing rules of <tt>ForwardIterator</tt>, would be to evaluate the transformed
sequence upon construction (for example, by storing each transformed
<tt>const_buffer</tt> in a <tt>vector</tt>). Unfortunately this work-around is
more expensive since it fails to avoid the heap allocation in the original
example.
</p>

<p>
The requirement of <tt>InputIterator</tt> <tt>operator-&gt;</tt> is also
unnecessary for buffer sequence iterators, and should be removed. Because
[networking.ts] only requires that a buffer sequence iterator's
<tt>value_type</tt> be convertible to <tt>const_buffer</tt> or
<tt>mutable_buffer</tt>, implementations of [networking.ts] cannot assume the
existence of any particular member functions or data members other than an
implicit conversion to <tt>const_buffer</tt> or <tt>mutable_buffer</tt>.
Removing the requirement for <tt>operator-&gt;</tt> to be present, provides
additional relief from the strict aliasing requirements of
<tt>ForwardIterator</tt> and allows transformations of buffer sequences to meet
the requirements of buffer sequences.
</p>

<p>
This proposal imposes no changes on existing implementations of [networking.ts].
It does not change anything in the standard. The proposal is precise, minimal,
and allows range adapters to transform buffer sequences in optimized, compatible
ways.
</p>

<p><i>[Issues processing Telecom 2016-10-7]</i></p>

<p>Status set to LEWG</p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4588.pdf">N4588</a>.
</p>

<ol>
<li>
<p>
Modify 16.2.1 [buffer.reqmts.mutablebuffersequence] as indicated:
</p>
<blockquote>
<p>
<del>An iterator type meeting the requirements for bidirectional
iterators (C++Std [bidirectional.iterators]) whose value type is
convertible to <tt>mutable_buffer</tt></del>
</p>
<p><ins>
An iterator type whose <tt>reference</tt> type is convertible to
<tt>mutable_buffer</tt>, and which satisfies all the requirements for
bidirectional iterators (C++Std [bidirectional.iterators]) except
that:
</ins></p>
<ol type="a">
<li>
<ins>there is no requirement that <tt>operator-&gt;</tt> is provided, and</ins>
</li>
<li>
<ins>there is no requirement that <tt>reference</tt> be a reference type.</ins>
</li>
</ol>
</blockquote>
</li>

<li>
<p>
Modify 16.2.2 [buffer.reqmts.constbuffersequence] as indicated:
</p>
<blockquote>
<p>
<del>An iterator type meeting the requirements for bidirectional
iterators (C++Std [bidirectional.iterators]) whose value type is
convertible to <tt>const_buffer</tt>.</del>
</p>

<p>
<ins>An iterator type whose <tt>reference</tt> type is convertible to
<tt>const_buffer</tt>, and which satisfies all the requirements for
bidirectional iterators (C++Std [bidirectional.iterators]) except
that:
</ins></p>
<ol type="a">
<li>
<ins>there is no requirement that <tt>operator-&gt;</tt> is provided, and</ins>
</li>
<li>
<ins>there is no requirement that <tt>reference</tt> be a reference type.</ins>
</li>
</ol>
</blockquote>
</li>
</ol>







<hr>
<h3><a name="2780" href="#2780">2780.</a> <tt>basic_string_view::copy</tt> is missing <tt>constexpr</tt></h3>
<p><b>Section:</b> 21.4 [string.view] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Billy Robert O'Neal III <b>Opened:</b> 2016-10-07 <b>Last modified:</b> 2016-10-14</p>
<p><b>Priority: </b>2
</p>
<p><b>View other</b> <a href="lwg-index-open.html#string.view">active issues</a> in [string.view].</p>
<p><b>View all other</b> <a href="lwg-index.html#string.view">issues</a> in [string.view].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Now that we have C++14 relaxed <tt>constexpr</tt>, we can also take care
of the assignment operator and <tt>copy</tt>.
</p>
<p><i>[Issues processing Telecom 2016-10-7]</i></p>

<p>Split off from <a href="lwg-active.html#2778">2778</a></p>


<p><b>Proposed resolution:</b></p>
<p>
This wording is relative to N4606.
</p>

<ol>
<li><p>In 21.4.2 [string.view.template], add <tt>constexpr</tt> to <tt>copy</tt>:</p>

<blockquote>
<pre>
<ins>constexpr </ins>size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>
</blockquote>
</li>

<li><p>In 21.4.2.6 [string.view.ops], add <tt>constexpr</tt> to <tt>copy</tt>:</p>

<blockquote>
<pre>
<ins>constexpr </ins>size_type copy(charT* s, size_type n, size_type pos = 0) const;
</pre>
</blockquote>
</li>
</ol>






</body>
</html>
